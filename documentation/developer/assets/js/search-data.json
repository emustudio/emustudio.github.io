{"0": {
    "doc": "Plugin contexts",
    "title": "Plugin contexts",
    "content": "Plugin contexts are answer to the question “how plugins communicate?”. Plugin root classes are seen by emuStudio, but not by plugins. Instead, plugins can register custom objects (called “contexts”) in the ContextPool object during plugin instantiation (in the constructor). ContextPool is a shared container of all plugin contexts. Plugins can also obtain contexts of other plugins, during plugin initialization. Then, plugin communicate by calling regular Java methods on the plugin context objects, obtained from context pool. ContextPool is not thread-safe, so all operations on it should be performed in the same thread which called method Plugin.initialize(). Each plugin context must implement a Context interface (or it’s derivative). Interfaces which extend Context must be then annotated with PluginContext annotation. There are prepared some standard context interfaces in the API (CompilerContext, MemoryContext, CpuContext and DeviceContext), and those can be used when implementing plugin context class - or they can be further extended to provide customized versions of contexts. Plugin context objects are registered in ContextPool as key-value pair, where the key is an context interface which the context implements, and value is the context object. A plugin can register none, one or many contexts. Single context object can be registered multiple times, if the keys (context interfaces) are different. Sample custom context might be created like this: . @PluginContext public interface SampleContext extends CpuContext { // custom methods... } . And the context class might look as follows: . public class SampleContextImpl implements SampleContext { // implementation ... } . Registration of this context might look as follows: . @PluginRoot(type = PLUGIN_TYPE.CPU, title = \"Sample CPU emulator\") public class SamplePlugin implements CPU { public SamplePlugin(long pluginID, ApplicationApi emustudio, PluginSettings settings) { ContextPool contextPool = emustudio.getContextPool(); SampleContext context = new SampleContextImpl(); // We will register the same context two times, but by different context interfaces contextPool.register(pluginID, context, CpuContext.class); contextPool.register(pluginID, context, SampleContext.class); } } . If another plugin wants to obtain the context, it should do it in the Plugin.initialize() method: . @PluginRoot(type = PLUGIN_TYPE.DEVICE, title = \"Sample device\") public class SampleDevice implements Device { ... @Override public void initialize() throws PluginInitializationException { // If obtaining the context is not vital, catch the exception SampleContext cpuContext = contextPool.getCPUContext(pluginID, SampleContext.class); ... } ... } . If the requested context could not be found, or the plugins were not connected, an exception is thrown. If the plugin needs to obtain the context, the plugin should let the exception propagate to the caller, otherwise it should be caught. ",
    "url": "/documentation/developer/plugin_basics/context#plugin-contexts",
    "relUrl": "/plugin_basics/context#plugin-contexts"
  },"1": {
    "doc": "Plugin contexts",
    "title": "Plugin contexts",
    "content": " ",
    "url": "/documentation/developer/plugin_basics/context",
    "relUrl": "/plugin_basics/context"
  },"2": {
    "doc": "How to contribute",
    "title": "How to contribute",
    "content": "There are several options on how to contribute. One option is to test, fix, or enhance the application or plugins. Another option is to implement a completely new computer which can be used with emuStudio. The latter is not considered a contribution unless it is a FOSS. Last option is to support the project by spreading the word or providing a financial support. Each contribution topic should be tracked in a separate ticket in particular GitHub repository. Code contributors should start with forking particular GitHub repository, and branch off the development branch in a feature/bugfix branch named: . | feature-XXX when it’s a feature, and XXX is a ticket number | bugfix-XXX when it’s a bugfix, and XXX is a ticket number | . When you are satisfied with your work, make a git commit in your branch. A commit message should be in the following form: . [#XXX] Description of commit . where XXX represents a ticket number. Please make sure the description is accurate, not too short and not too long. Next step is to make a pull request to the upstream repository (original one), into branch development. Then, someone will review the PR, test it, and can suggest some changes. When reviewers are satisfied, they will merge the PR. If the commit message follows the formatting standard, the commit will appear in the ticket as a comment. ",
    "url": "/documentation/developer/getting_started/contributing#how-to-contribute",
    "relUrl": "/getting_started/contributing#how-to-contribute"
  },"3": {
    "doc": "How to contribute",
    "title": "Code style",
    "content": "Code should be “clean”, in terms of sticking to various good practices and principles (e.g. SOLID, GRASP, YAGNI, KISS, DRY, etc.). The repositories are supplied with .editorconfig file which is supposed to be used in your favourite IDE. ",
    "url": "/documentation/developer/getting_started/contributing#code-style",
    "relUrl": "/getting_started/contributing#code-style"
  },"4": {
    "doc": "How to contribute",
    "title": "Definition of DONE",
    "content": "Some requirements need to be fulfilled before we can say that the contribution is “done” and can be accepted or released. The list is very simple: . | Code should work and be fully tested | Code should be clean, conforming the code style | Code must have proper unit tests, if applicable or possible | Documentation should be updated | . ",
    "url": "/documentation/developer/getting_started/contributing#definition-of-done",
    "relUrl": "/getting_started/contributing#definition-of-done"
  },"5": {
    "doc": "How to contribute",
    "title": "How to contribute",
    "content": " ",
    "url": "/documentation/developer/getting_started/contributing",
    "relUrl": "/getting_started/contributing"
  },"6": {
    "doc": "Disassembler",
    "title": "Disassembler",
    "content": "Disassembler is not needed for the emulation itself. It is needed for emuStudio to be able to visually show the instructions. You can create a disassembler by implementing interface Disassembler from emuLib. Or you can use Edigen, a disassembler generator for emuStudio. Edigen works similarly as parser generator: developer writes a specification file. Then, Edigen (either from the command line or using Gradle) generates disassembler and decoder of the source code, using predefined templates, bundled in Edigen. Specification files have .eds file extension. A SSEM CPU specification file looks as follows: . # Decoder section instruction = \"JMP\": line(5) ignore8(8) 000 ignore16(16) | \"JPR\": line(5) ignore8(8) 100 ignore16(16) | \"LDN\": line(5) ignore8(8) 010 ignore16(16) | \"STO\": line(5) ignore8(8) 110 ignore16(16) | \"SUB\": line(5) ignore8(8) 001 ignore16(16) | \"CMP\": 00000 ignore8(8) 011 ignore16(16) | \"STP\": 00000 ignore8(8) 111 ignore16(16); line = arg: arg(5); ignore8 = arg: arg(8); ignore16 = arg: arg(16); %% # Disassembler section \"%s %d\" = instruction line(shift_left, shift_left, shift_left, bit_reverse, absolute) ignore8 ignore16; \"%s\" = instruction ignore8 ignore16; . The specification file might look a bit cryptic at first sight, but it’s quite easy. The content is divided into two sections (decoder and disassembler), separated with two %% chars on a separate line. ",
    "url": "/documentation/developer/cpu/disassembler#disassembler",
    "relUrl": "/cpu/disassembler#disassembler"
  },"7": {
    "doc": "Disassembler",
    "title": "Decoder section",
    "content": "The decoder section contains rules which are used for parsing the instruction binary codes and assign labels to the codes. Decoding always starts with the first rule (in this case, instruction). Each rule has one or more variants. A variant consists of a mixture of constants and subrules. A constant can be hexadecimal (e.g., 0xF) or binary (01). Constants are used to unambiguously match exactly one variant for each rule. A subrule has a name and length in bits – e.g., dst_reg(2). The bits located at the position of a subrule are passed to the corresponding rule. A variant can return a value - either a constant string (\"add\"), or a binary value taken from a subrule (imm). The result of decoding is an associative array in the form {rule: value, …}. For example, let us decode the instruction “1111 0100 0000 0011”, The second variant of the rule instruction is matched, since 0xF is 1111. So far, the result is {instruction: “sub”}. The following bits (01) are passed to the rule dst_reg, where the second variant matches, so the result is updated: {instruction: “sub”, dst_reg: “Y”}. Finally, the bits 00 0000 0011 are passed to the rule immediate, which just returns the passed binary value. The final result is {instruction: “sub”, dst_reg: “Y”, immediate: 3}. ",
    "url": "/documentation/developer/cpu/disassembler#decoder-section",
    "relUrl": "/cpu/disassembler#decoder-section"
  },"8": {
    "doc": "Disassembler",
    "title": "Disassembler section",
    "content": "The disassembler section specifies the disassembled string formats for particular rules. More precisely, disassembler part matches a set of rules (on the right side of =) to a formatting string (on the left side). The first set of rules which is a subset of the result rule-set is selected. The corresponding formatting string is used, substituting the formats with concrete values. In our example, the first rule-set cannot be used, since our result does not contain src_reg. However, our result contains all rules specified in the second rule-set (instruction dst_reg immediate), so the disassembled instruction is “sub Y, 3”. By default, these format specifiers are available: . | %c - one character, in the platform’s default charset | %d - arbitrarily long signed integer, decimal | %f - a 4-byte of 8-byte floating point number | %s - a string (typically used for string constants returned from variants) | %x - arbitrarily long unsigned integer, hexadecimal, lowercase | %X - arbitrarily long unsigned integer, hexadecimal, uppercase | %% - a percent sign | . The rule-set on the right side of = can take decoding strategy as a parameter in brackets (). The following decoding strategies are available: . | bit_reverse - reverses the bits | big_endian - decodes the bits as they are stored in big-endian format | little_endian - decodes the bits as they are stored in little-endian format | absolute - decodes the bits as stored in 2’s complement if they are negative; the negative sign is then thrown away | shift_left - shifts the number to the left by 1 bit. Does it in “big endian” way. Meaning bytes [0] = 1, [1] = 2 will result in [0] = 2, [1] = 4 | shift_right - shifts the number to the right by 1 bit. Dies it in “big endian” way. Meaning bytes [0] = 1, [1] = 2 will result in [0] = 0, [1] = 0x81 | . The strategies can be combined. Multiple strategies will be applied in the left-to-right order. ",
    "url": "/documentation/developer/cpu/disassembler#disassembler-section",
    "relUrl": "/cpu/disassembler#disassembler-section"
  },"9": {
    "doc": "Disassembler",
    "title": "Disassembler",
    "content": " ",
    "url": "/documentation/developer/cpu/disassembler",
    "relUrl": "/cpu/disassembler"
  },"10": {
    "doc": "Documenting",
    "title": "Documenting",
    "content": "There are two types of documentation - user and developer. Only the current version of the documentation is maintained. Older versions can be accessed from git. Both types of documentation use separate Jekyll static site project. The structure of the documentation is as follows: . _documentation | + developer | + ... jekyll static site ... + user + ... jekyll static site ... Based on the type of documentation, you can navigate to the right place where to contribute. The documentation is built manually, not by GitHub pages. The reason for having separate Jekyll projects is that the documentation uses a different template than the main website, and those cannot be combined easily. When you update the documentation, please run script: . _documentation/build.sh . which will generate the sites in the correct place, where the main website will recognize it. Commits should include rendered documentation as well. ",
    "url": "/documentation/developer/getting_started/documenting#documenting",
    "relUrl": "/getting_started/documenting#documenting"
  },"11": {
    "doc": "Documenting",
    "title": "User documentation",
    "content": "Plugins are usually part of virtual computers. Therefore, virtual computers are “chapters” in the documentation in a separate directory (e.g. _documentation/user/0.40/altair8800, and plugins are described there, in a separate file (e.g. byte-mem.md). The documentation of virtual computer should document all possible configurations, and all possible plugins, even if their use is optional (which should be documented as well). User documentation should focus on the interaction part with the user of emuStudio, and should not go in details of what’s going under the hood. Keep the information useful. Do not bloat text with obvious. Structure . Virtual computer documentation should start with a short introduction: . | How the computer is related to computer history? | Is it abstract or real? | The purpose of the computer | Possible computer configurations | Comparison of features which are supported vs. features of real computer | . Then, every plug-in should be described, in a separate file, in the following order: . | compiler (“programming language” tutorial) | CPU | memory | devices | . The last chapters should be devoted to emulation automation and debugging problems (e.g. how to do some analysis when something doesn’t work). ",
    "url": "/documentation/developer/getting_started/documenting#user-documentation",
    "relUrl": "/getting_started/documenting#user-documentation"
  },"12": {
    "doc": "Documenting",
    "title": "Developer’s documentation",
    "content": "Developer documentation (as you read this one) focuses on introducing new contributors to emuStudio internals and plugin development. You can contribute by fixing or extending the existing plugin. Developer documentation of a particular plugin is optional. The reason is that plugin documentation will not be published separately, just as part of the documentation of the whole computer. In the developer documentation, only technical details should be explained, not the structure of the plugin code. Majority of things which the documentation should include are the “why”s instead of “how”s. ",
    "url": "/documentation/developer/getting_started/documenting#developers-documentation",
    "relUrl": "/getting_started/documenting#developers-documentation"
  },"13": {
    "doc": "Documenting",
    "title": "Documenting",
    "content": " ",
    "url": "/documentation/developer/getting_started/documenting",
    "relUrl": "/getting_started/documenting"
  },"14": {
    "doc": "Emulator engine",
    "title": "Emulator engine",
    "content": "Emulator engine is the core of the emulator. It interprets binary-encoded instructions stored in a memory (emuStudio assumes it’s a von-Neumann-like CPU). Execution of one instruction involves four basic steps: fetch, decode and execute, and store, executed in order. Those steps can overlap in the implementation. A pseudo-algorithm for emulator engine can look as follows: . public class EmulatorEngine { private final CPU cpu; private final MemoryContext&lt;Byte&gt; memory; // internal CPU registers private int currentInstruction; EmulatorEngine(MemoryContext&lt;Byte&gt; memory, CPU cpu) { this.memory = Objects.requireNonNull(memory); this.cpu = Objects.requireNonNull(cpu); } CPU.RunState step(CPU.RunState currentRunState) { int instruction = memory.read(currentInstruction); currentInstruction = currentInstruction + 1; switch (instruction) { case 0: // ADD ... return CPU.RunState.STATE_STOPPED_BREAK; case 4: // JMP ... return CPU.RunState.STATE_STOPPED_BREAK; case 99: // HLT return CPU.RunState.STATE_STOPPED_NORMAL; } } CPU.RunState run(CPU.RunState currentRunState) { while (currentRunState == CPU.RunState.STATE_STOPPED_BREAK) { try { if (cpu.isBreakpointSet(currentInstruction)) { return currentRunState; } currentRunState = step(); } catch (...){ currentRunState = CPU.RunState.STATE_STOPPED_XXX; break; } } return currentRunState; } ... } . It uses interpretation emulation technique (the simplest one). Note that breakpoints must be manually handled - after execution of each instruction it should be checked if the current instruction hasn’t a breakpoint, and if yes, return. ",
    "url": "/documentation/developer/cpu/engine#emulator-engine",
    "relUrl": "/cpu/engine#emulator-engine"
  },"15": {
    "doc": "Emulator engine",
    "title": "Emulator engine",
    "content": " ",
    "url": "/documentation/developer/cpu/engine",
    "relUrl": "/cpu/engine"
  },"16": {
    "doc": "Git workflow",
    "title": "Git workflow",
    "content": "Since emuStudio is available at GitHub, it is using git as the version control system (VCS). The basic workflow is a much-simplified version of the official Git Flow model. The simplifications are as follows: . | There is maintained just one version of emuStudio (the not-yet-released). Releasing older versions with hotfixes is not supported. | There are no “release branches”. Branch development is considered as an always-stable branch, from which are performed releases. | . ",
    "url": "/documentation/developer/getting_started/gitflow#git-workflow",
    "relUrl": "/getting_started/gitflow#git-workflow"
  },"17": {
    "doc": "Git workflow",
    "title": "Releases",
    "content": "The release is performed in several steps. | Pre-check everything. Build, documentation, etc. | Merge development branch into master branch | The last commit in the master branch is tagged with tag RELEASE-XXX, where XXX is the released version | The release is edited in GitHub to add release notes and binary artifacts | . ",
    "url": "/documentation/developer/getting_started/gitflow#releases",
    "relUrl": "/getting_started/gitflow#releases"
  },"18": {
    "doc": "Git workflow",
    "title": "Git workflow",
    "content": " ",
    "url": "/documentation/developer/getting_started/gitflow",
    "relUrl": "/getting_started/gitflow"
  },"19": {
    "doc": "Writing a compiler",
    "title": "Writing a compiler",
    "content": "A compiler plugin must either implement Compiler interface, or extend more bloat-free AbstractCompiler class. Common practice is to utilize ANTLR parser generator, which has a direct runtime support in emuStudio. As every plug-in root class, compiler class must use annotation PluginRoot. Sample implementation of a compiler might look as follows (just some methods are implemented): . @PluginRoot( type = PLUGIN_TYPE.COMPILER, title = \"Sample compiler\" ) public class CompilerImpl extends AbstractCompiler { private final static Logger LOGGER = LoggerFactory.getLogger(CompilerImpl.class); private final static List&lt;SourceFileExtension&gt; SOURCE_FILE_EXTENSIONS = List.of( new SourceFileExtension(\"asm\", \"Assembler source file\") ); private MemoryContext&lt;Byte&gt; memory; private int programLocation; public CompilerImpl(long pluginID, ApplicationApi applicationApi, PluginSettings settings) { super(pluginID, applicationApi, settings); } @SuppressWarnings(\"unchecked\") @Override public void initialize() throws PluginInitializationException { Optional.ofNullable(applicationApi.getContextPool()).ifPresent(pool -&gt; { try { memory = pool.getMemoryContext(pluginID, MemoryContext.class); if (memory.getDataType() != Byte.class) { throw new InvalidContextException( \"Unexpected memory cell type. Expected Byte but was: \" + memory.getDataType() ); } } catch (InvalidContextException | ContextNotFoundException e) { LOGGER.warn(\"Memory is not available\", e); } }); } @Override public boolean compile(String inputFileName, String outputFileName) { notifyCompileStart(); notifyInfo(getTitle() + \", version \" + getVersion()); try (Reader reader = new FileReader(inputFileName)) { SampleLexer lexer = createLexer(CharStreams.fromReader(reader)); lexer.addErrorListener(new ParserErrorListener()); CommonTokenStream tokens = new CommonTokenStream(lexer); SampleParser parser = createParser(tokens); parser.addErrorListener(new ParserErrorListener()); Program program = new Program(); // TODO: Create your AST program.setFileName(inputFileName); new CreateProgramVisitor(program).visit(parser.rStart()); // TODO: Create AST creator visitor IntelHEX hex = new IntelHEX(); NodeVisitor[] visitors = new NodeVisitor[]{ // TODO: create your semantic analysis and code generating visitors }; for (NodeVisitor visitor : visitors) { visitor.visit(program); } programLocation = 0; if (program.env().hasNoErrors()) { hex.generate(outputFileName); programLocation = hex.findProgramLocation(); notifyInfo(String.format( \"Compile was successful.\\n\\tOutput: %s\\n\\tProgram starts at 0x%s\", outputFileName, RadixUtils.formatWordHexString(programLocation) )); if (memory != null) { hex.loadIntoMemory(memory, b -&gt; b); notifyInfo(\"Compiled file was loaded into memory.\"); } else { notifyWarning(\"Memory is not available.\"); } return true; } else { for (CompileError error : program.env().getErrors()) { notifyError(error.line, error.column, error.msg); } return false; } } catch (CompileException e) { notifyError(e.line, e.column, e.getMessage()); return false; } catch (IOException e) { notifyError(\"Compilation error: \" + e); return false; } finally { notifyCompileFinish(); } } @Override public boolean compile(String inputFileName) { String outputFileName = Objects.requireNonNull(inputFileName); SourceFileExtension srcExtension = SOURCE_FILE_EXTENSIONS.get(0); int i = inputFileName.toLowerCase(Locale.ENGLISH).lastIndexOf(\".\" + srcExtension.getExtension()); if (i &gt;= 0) { outputFileName = outputFileName.substring(0, i); } return compile(inputFileName, outputFileName + \".hex\"); } @Override public LexicalAnalyzer createLexer(String s) { SampleLexer lexer = createLexer(CharStreams.fromString(s)); return new LexicalAnalyzerImpl(lexer); } @Override public int getProgramLocation() { return programLocation; } @Override public List&lt;SourceFileExtension&gt; getSourceFileExtensions() { return SOURCE_FILE_EXTENSIONS; } @Override public String getVersion() { return \"1.0.0\"; } @Override public String getCopyright() { return \"(c) Copyright 2006-2023, you\"; } @Override public String getDescription() { return \"Sample compiler\"; } private SampleLexer createLexer(CharStream input) { return null; // TODO: create your lexer } private SampleParser createParser(TokenStream tokenStream) { return null; // TODO: create your parser } } . Main outcomes are: . | this sample compiler uses ANTLR parser generator for generating parser and lexer - they must be written manually | it optionally loads program output into memory | it generates output file in Intel HEX format | AST (abstract syntax tree) in form of classes must be written manually | All semantic-analysis visitors must be written manually, including code generation (this is probably the hardest compiler work) | . The compiler does not register any plugin context, but when initialized, it obtains optional memory context (in this example, memory must have cells of Byte type). If the memory is available, after compilation the program will be loaded in the memory. Lexer and parser are not shown here, but they are created using mentioned ANTLR parser generator. Please check out this nice ANTLR tutorial. The compiler utilizes a helper class IntelHEX from emuLib for generating output files. Abstract syntax tree is the most important part of the compiler. In general, the flow of transforming the source code into output is going through AST. In the beginning, AST is isomorphic to the parse tree. Then some transformations are applied - like expression evaluation, include files expansion, by-value identifiers replacements, intermediate code generation with relative addresses, macro expansion, preprocessor code evaluation, absolute address assignment and final transformation into binary code or whatever the compiler produces. So in time, AST changes, nodes are moved, replaced by others, or removed. At the final stage, AST represents program output. Transformations of AST is best done using visitors (see Visitor pattern). A visitor is accepting some or all node types from the AST and performs changes to the nodes, or the whole AST. It’s a detached, isolated functionality operating on AST, which can be separately tested. For more information, see the code of some existing compilers. ",
    "url": "/documentation/developer/compiler/#writing-a-compiler",
    "relUrl": "/compiler/#writing-a-compiler"
  },"20": {
    "doc": "Writing a compiler",
    "title": "Lexical analyzer",
    "content": "emuStudio application uses standardized token types in order to support syntax highlighting in general, for any compiler kind. It is thus required to provide a lexer which returns emuStudio-like token types: . public interface LexicalAnalyzer extends Iterable&lt;Token&gt; { Token nextToken(); boolean isAtEOF(); void reset(InputStream is) throws IOException; } . The implementation is usually manual, tokens generated by ANTLR are converted into the standardized variants, e.g.: . public class LexicalAnalyzerImpl implements LexicalAnalyzer { public static final int[] tokenMap = new int[SampleLexer.EOL + 1]; // highest number static { // TODO: not complete tokenMap[COMMENT] = Token.COMMENT; tokenMap[EOL] = Token.WHITESPACE; tokenMap[WS] = Token.WHITESPACE; tokenMap[OPCODE_ADC] = Token.RESERVED; tokenMap[OPCODE_AND] = Token.RESERVED; tokenMap[OPCODE_ADD] = Token.RESERVED; tokenMap[PREP_ORG] = Token.PREPROCESSOR; tokenMap[PREP_EQU] = Token.PREPROCESSOR; tokenMap[PREP_VAR] = Token.PREPROCESSOR; tokenMap[REG_A] = Token.REGISTER; tokenMap[REG_B] = Token.REGISTER; tokenMap[REG_C] = Token.REGISTER; tokenMap[SEP_LPAR] = Token.SEPARATOR; tokenMap[SEP_RPAR] = Token.SEPARATOR; tokenMap[SEP_COMMA] = Token.SEPARATOR; tokenMap[OP_ADD] = Token.OPERATOR; tokenMap[OP_SUBTRACT] = Token.OPERATOR; tokenMap[OP_MULTIPLY] = Token.OPERATOR; tokenMap[OP_DIVIDE] = Token.OPERATOR; tokenMap[LIT_NUMBER] = Token.LITERAL; tokenMap[LIT_HEXNUMBER] = Token.LITERAL; tokenMap[LIT_OCTNUMBER] = Token.LITERAL; tokenMap[LIT_STRING] = Token.LITERAL; tokenMap[ID_IDENTIFIER] = Token.IDENTIFIER; tokenMap[ID_LABEL] = Token.IDENTIFIER; tokenMap[ERROR] = Token.ERROR; } private final SampleLexer lexer; public LexicalAnalyzerImpl(SampleLexer lexer) { this.lexer = Objects.requireNonNull(lexer); } @Override public Token nextToken() { org.antlr.v4.runtime.Token token = lexer.nextToken(); return new Token() { @Override public int getType() { return convertLexerTokenType(token.getType()); } @Override public int getOffset() { return token.getStartIndex(); } @Override public String getText() { return token.getText(); } }; } @Override public boolean isAtEOF() { return lexer._hitEOF; } @Override public void reset(InputStream inputStream) throws IOException { lexer.setInputStream(CharStreams.fromStream(inputStream)); } private int convertLexerTokenType(int tokenType) { if (tokenType == EOF) { return Token.EOF; } return tokenMap[tokenType]; } } . ",
    "url": "/documentation/developer/compiler/#lexical-analyzer",
    "relUrl": "/compiler/#lexical-analyzer"
  },"21": {
    "doc": "Writing a compiler",
    "title": "Writing a compiler",
    "content": " ",
    "url": "/documentation/developer/compiler/",
    "relUrl": "/compiler/"
  },"22": {
    "doc": "Writing a CPU",
    "title": "Writing a CPU",
    "content": "CPU plugins in emuStudio are not just plain emulators. They must cooperate with emuStudio and provide capabilities allowing debugging and some interaction. A CPU plugin must implement: . Emulation “engine” It is the CPU emulator itself, and it should be implemented using some emulation technique. In Java there are not many options, so usually either interpretation or threaded dispatch are used, both described e.g. here or here. Disassembler It will be used by emuStudio for creating the list of instructions in the debugger panel. Java Swing GUI panel It should implement the visualization of CPU registers, possibly current frequency and CPU run state. Both disassembler and GUI panel should be instantiated just once. It is good practice to instantiate disassembler during plugin instantiation or initialization, and GUI in the CPU.getStatusPanel() method call. emuStudio application will call the method just once from Swing Event dispatch thread. Programming a disassembler might be tedious and error-prone. That’s why we encourage to use a tool which can generate the disassembler from a specification file. The tool is called Edigen, an abbreviation for Emulator DIsassembler GENerator. It can be nicely incorporated into Gradle build using edigen-gradle-plugin. ",
    "url": "/documentation/developer/cpu/#writing-a-cpu",
    "relUrl": "/cpu/#writing-a-cpu"
  },"23": {
    "doc": "Writing a CPU",
    "title": "Writing a CPU",
    "content": " ",
    "url": "/documentation/developer/cpu/",
    "relUrl": "/cpu/"
  },"24": {
    "doc": "Writing a device",
    "title": "Writing a device",
    "content": "In emuStudio, plugin root class must either implement Device interface, or can extend more bloat-free AbstractDevice class. A device in emuStudio has three components: . | a device “engine” (device functionality) | optional main GUI window | optional settings GUI window | . Communication with devices is realized through device contexts. A device, as any other plugin, can have none, one or more contexts, which should be registered in plugin root class constructor. Device context should implement a DeviceContext interface. Sample implementation of a device root class might look as follows: . @PluginRoot( type = PLUGIN_TYPE.DEVICE, title = \"Sample device\" ) public class DeviceImpl extends AbstractDevice { private final DeviceContext deviceEngine = new DeviceEngine(); private MainWindow mainWindow; private SettingsWindow settingsWindow; public DeviceImpl(long pluginID, ApplicationApi applicationApi, PluginSettings settings) { super(pluginID, applicationApi, settings); try { applicationApi.getContextPool().register(pluginID, deviceEngine, DeviceContext.class); } catch (InvalidContextException | ContextAlreadyRegisteredException e) { applicationApi.getDialogs().showError( \"Could not register Sample Device.\", getTitle() ); } } @Override public void showGUI(JFrame parent) { if (mainWindow == null) { mainWindow = new MainWindow(parent); } mainWindow.setVisible(true); } @Override public void showSettings(JFrame parent) { if (settingsWindow == null) { settingsWindow = new SettingsWindow(parent); } settingsWindow.setVisible(true); } @Override public boolean isShowSettingsSupported() { return true; } } . ",
    "url": "/documentation/developer/device/#writing-a-device",
    "relUrl": "/device/#writing-a-device"
  },"25": {
    "doc": "Writing a device",
    "title": "Writing a device",
    "content": " ",
    "url": "/documentation/developer/device/",
    "relUrl": "/device/"
  },"26": {
    "doc": "Getting started",
    "title": "Getting started",
    "content": "emuStudio is a Java Swing application that implements editor of virtual computer, source code editor, and emulation “controller” (sometimes known as “debugger”). The emulation controller is used for controlling the emulation, and also supports interaction in application GUI. Under the hood, it operates with an instance of the so-called “virtual computer”. The virtual computer - or a computer emulator - is loaded from the computer configuration, selected by the user on the application startup. Virtual computer is assembled from plugin object instances, possibly interconnected, according to the definition of given computer configuration. Each plugin is a single, almost a self-contained JAR file. It means almost all dependencies the plugin uses are present in the JAR file, except the following, which are bundled with emuStudio and will always be available in the class-path: . | emuLib (Maven here) | ANTLR4 runtime | SLF4J logging | Picoli for command-line parsing | . The application provides also: . | plugin configuration management - implementation of PluginSettings allowing plugins to register themselves or get instances of other registered plugins | runtime API for the communication between plugins and emuStudio application - implementation of ApplicationApi | . Plugins get those objects in the constructor. Details are provided in further chapters, but here can be revealed just this: there are four types of plugins: a compiler (which can produce code loadable in the emulated memory), one CPU emulator, one operating memory, and none, one or more virtual devices. The core concept of a virtual computer is inspired by the von Neumann model. Each plugin implements API from emuLib, following some predefined rules. Plugin physically is compiled into a JAR file and copied into particular subdirectory in emuStudio installation. ",
    "url": "/documentation/developer/getting_started/#getting-started",
    "relUrl": "/getting_started/#getting-started"
  },"27": {
    "doc": "Getting started",
    "title": "GitHub repositories",
    "content": "From architecture perspective, emuStudio is a family of GitHub repositories, a combination of multiple sister projects: . | emuStudio - application and plugins | emuLib - a shared run-time library used by emuStudio and plugins. Javadoc is here. | Edigen - CPU instruction decoder and disassembler generator based on a specification file. | Edigen Gradle plugin | CPU testing suite - a general unit-testing framework for testing CPU plug-ins. Tests are specified in a declarative way. | emuStudio website | . ",
    "url": "/documentation/developer/getting_started/#github-repositories",
    "relUrl": "/getting_started/#github-repositories"
  },"28": {
    "doc": "Getting started",
    "title": "Getting started",
    "content": " ",
    "url": "/documentation/developer/getting_started/",
    "relUrl": "/getting_started/"
  },"29": {
    "doc": "Writing a memory",
    "title": "Writing a memory",
    "content": "In emuStudio, plugin root class must either implement Memory interface, or can extend more bloat-free AbstractMemory class. Generally, a memory in an emulator is usually implemented as an array of bytes. Indexes to the array represent addresses, and values are the memory cell values. In emuStudio, this kind of implementation is reflected by memory context. Memory context should be a class which either implements MemoryContext interface, or extends AbstractMemoryContext class. The latter provide additional functionality - management of memory “listeners”. A memory listener (implementing Memory.MemoryListener interface) can observe memory value changes on all address range. But when the emulation is in running state, emuStudio turns off the memory notifications to speed up the emulation. ",
    "url": "/documentation/developer/memory/#writing-a-memory",
    "relUrl": "/memory/#writing-a-memory"
  },"30": {
    "doc": "Writing a memory",
    "title": "Writing a memory",
    "content": " ",
    "url": "/documentation/developer/memory/",
    "relUrl": "/memory/"
  },"31": {
    "doc": "Plugin basics",
    "title": "Plugin basics",
    "content": "Each plugin is a separate Java module (source code can be written in any JVM language), compiled into a single JAR file. The JAR file is then placed in the proper directory (e.g. compiler/, cpu/, memory/, and device/) in emuStudio installation. In the source code, plugins are located in plugins/ subdirectory, then branched further by plugin type. ",
    "url": "/documentation/developer/plugin_basics/#plugin-basics",
    "relUrl": "/plugin_basics/#plugin-basics"
  },"32": {
    "doc": "Plugin basics",
    "title": "Naming conventions",
    "content": "Plugin names are derived from JAR file names. A naming convention defines how the name should be picked. Each plugin type has a different naming convention. General idea is that the JAR file name should say clearly what the plugin is about. A plugin JAR file name should be in the form of: . [specific abbreviation]-[plugin type].jar . where [specific abbreviation] means some custom abbreviation of the real world “device” the plugin emulates or is part of, optionally preceded with the manufacturer (e.g. intel-8080, adm-3A, etc.). Then [plugin type] follows, but in a form, as it is shown in the following table: . | Plugin type | Naming convention | Examples | . | Compiler | [language]-compiler (for compiler of higher language), or as-[cpu type] (for assembler) | as-8080, as-z80, brainc-compiler, ram-compiler | . | CPU | [cpu model]-cpu, or [computer type]-cpu | 8080-cpu, z80-cpu, ram-cpu, brainduck-cpu | . | Memory | [some feature]-mem, or [computer type]-mem | byte-mem, ram-mem, rasp-mem | . | Device | [device model]-[device type] | 88-dcdd, 88-sio, adm3a-terminal, simh-pseudo, vt100-terminal | . Plugin names can contain digits, small and capital letters (regex: [a-zA-Z0-9]+). Capital letters shall be used only just for word separation (e.g. zilogZ80). ",
    "url": "/documentation/developer/plugin_basics/#naming-conventions",
    "relUrl": "/plugin_basics/#naming-conventions"
  },"33": {
    "doc": "Plugin basics",
    "title": "Plugin structure",
    "content": "A plugin must contain a public class which is considered as plugin root. The plugin root is automatically found, then instantiated by emuStudio, then assigned into a virtual computer and used. A class which is to be plugin root, must: . | implement some plugin interface (i.e. CPU, Device, Memory or Compiler) | annotate the class with PluginRoot annotation | implement a public constructor with three arguments of types (long, ApplicationApi, PluginSettings) | . A sample plugin root class might look like this: . @PluginRoot(type = PLUGIN_TYPE.CPU, title = \"Sample CPU emulator\") public class SamplePlugin implements CPU { public SamplePlugin(long pluginId, ApplicationApi emustudio, PluginSettings settings) { ... } ... } . If more classes implement some plugin interface, just one of them has to be annotated with PluginRoot. If there are more classes like this, the plugin might not work correctly. The constructor parameters have the following meaning: . | pluginId is a unique plugin identification, assigned by emuStudio. Some operations require it as an input argument. | emustudio is a runtime API implementation, provided by emuStudio application, to be used by plugins. | settings are plugin’s settings. A plugin can use it for reading/writing its custom or emuStudio settings. Updated settings are saved immediately in the configuration file, in the same thread. | . ",
    "url": "/documentation/developer/plugin_basics/#plugin-structure",
    "relUrl": "/plugin_basics/#plugin-structure"
  },"34": {
    "doc": "Plugin basics",
    "title": "Third-party dependencies",
    "content": "Each plugin can depend on third-party libraries (or other plugins). In this case, the dependencies should be either bundled with the plugin, or the location should be present in the Class-Path attribute in the plugin’s Manifest file. Some libraries are preloaded by emuStudio and those shouldn’t be included in plugin JAR file: . | emuLib | ANTLR4 runtime | SLF4J logging | Picoli for command-line parsing | . Plugins that want to use the dependencies above should specify them as “provided” in the project. ",
    "url": "/documentation/developer/plugin_basics/#third-party-dependencies",
    "relUrl": "/plugin_basics/#third-party-dependencies"
  },"35": {
    "doc": "Plugin basics",
    "title": "Incorporating a plugin in emuStudio",
    "content": "A new plugin is another Gradle submodule, which should be “registered” in settings.gradle file. If a plugin is part of a new computer, the new configuration should be created (in TOML format) and put in application/src/main/files/config directory. Plugin can have static example files, or shell scripts. Plugin must copy them into build directory, e.g. plugins/compiler/as-8080/build/libs/examples or plugins/compiler/as-8080/build/libs/scripts. Then, in application/build.gradle are sections marked with // Examples or // Scripts comments: ... // Examples [\"as-8080\", \"as-z80\", \"as-ssem\", \"brainc-brainduck\", \"ramc-ram\", \"raspc-rasp\"].collect { compiler -&gt; from(examples(\":plugins:compiler:$compiler\")) { into \"examples/$compiler\" } } // Scripts [\"as-8080\", \"as-z80\", \"as-ssem\", \"brainc-brainduck\", \"ramc-ram\", \"raspc-rasp\"].collect { compiler -&gt; from(scripts(\":plugins:compiler:$compiler\")) { into \"bin\" } } [\"88-dcdd\"].collect { device -&gt; from(scripts(\":plugins:device:$device\")) { into \"bin\" } } ... It is necessary to put your plugin name in the particular collection. ",
    "url": "/documentation/developer/plugin_basics/#incorporating-a-plugin-in-emustudio",
    "relUrl": "/plugin_basics/#incorporating-a-plugin-in-emustudio"
  },"36": {
    "doc": "Plugin basics",
    "title": "Plugin basics",
    "content": " ",
    "url": "/documentation/developer/plugin_basics/",
    "relUrl": "/plugin_basics/"
  },"37": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": "This guide shall help you, the developer, to write your virtual computer for emuStudio. API is designed for simplicity and tries to save the developer from solving the most common problems. Created emulators can mimic either real or abstract computers. I hope you will have fun! . ",
    "url": "/documentation/developer/introduction/#introduction",
    "relUrl": "/introduction/#introduction"
  },"38": {
    "doc": "Introduction",
    "title": "Project references",
    "content": "emuStudio is a collection of repositories. Plugins and the application share a runtime library, CPU disassembler might be generated using a sister project edigen, and instructions tested using cpu-testsuite framework. Here you can find documentation references for these sister projects. | Project reference | Purpose | . | emuLib | Shared runtime library. Mandatory use. | . | Edigen | CPU instruction decoder and disassembler generator. Optional use for CPU plugins. | . | CPU testing suite | General unit-testing framework for testing CPU plug-ins. Optional use for CPU plugins. | . ",
    "url": "/documentation/developer/introduction/#project-references",
    "relUrl": "/introduction/#project-references"
  },"39": {
    "doc": "Introduction",
    "title": "Publications",
    "content": "There have been a few published papers about emuStudio, which could be helpful in getting additional context and some philosophical aspects for developers. | emuStudio version | Year | Reference | . | 0.40 | 2020 | Development of ATmega 328P micro-controller emulator for educational purposes | . | 0.39 | 2017 | RASP Abstract Machine Emulator — Extending the emuStudio Platform | . | 0.38 | 2012 | An instruction decoder and disassembler generator for EmuStudio platform - Proceeding of the Faculty of Electrical Engineering and Informatics of the Technical University of Košice. Page 660-663. ISBN 978-80-553-0890-6 | . | 0.36-rc1 | 2010 | Preserving host independent emulation speed | . | 0.36-rc1 | 2010 | Standardization of computer emulation | . | 0.36-rc1 | 2010 | Communication model of emuStudio emulation platform | . | 3.6b1 | 2008 | Software-based CPU emulation | . ",
    "url": "/documentation/developer/introduction/#publications",
    "relUrl": "/introduction/#publications"
  },"40": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": " ",
    "url": "/documentation/developer/introduction/",
    "relUrl": "/introduction/"
  },"41": {
    "doc": "Loading and initialization",
    "title": "Loading and initialization",
    "content": "Instantiating and initializing plugins is done by emuStudio application in one thread. All plugins share one class-loader, which creates a potential risk of naming conflicts. Therefore, each class and resource should be put in packages with a unique name. ",
    "url": "/documentation/developer/plugin_basics/loading#loading-and-initialization",
    "relUrl": "/plugin_basics/loading#loading-and-initialization"
  },"42": {
    "doc": "Loading and initialization",
    "title": "Plugin instantiation",
    "content": "Plugin JAR files are unzipped and loaded into memory as one mixed bunch. The class loader will recognize all found classes and resources. Dependencies explicitly specified in manifest files are recognized and loaded as well. In case of circular dependencies, plugins loading will fail. This process happens just once in the beginning, so adding another plugin at run-time is not possible. The result of this phase is that all plugin classes are loaded in memory and all plugin roots are instantiated. What should plugin do in the constructor . Plugin constructor has three arguments - plugin ID, emuStudio API and plugin settings. Here, plugin can for example read its settings, or instantiate some final objects used later. But the most important operation here is to register so-called “plugin contexts” (if a plugin has some) into ContextPool, obtainable from emuStudio API. Note that plugin contexts of connected plugins must NOT be obtained here - in constructor. Another chapter talks about plugin contexts in more detail. ",
    "url": "/documentation/developer/plugin_basics/loading#plugin-instantiation",
    "relUrl": "/plugin_basics/loading#plugin-instantiation"
  },"43": {
    "doc": "Loading and initialization",
    "title": "Plugin initialization",
    "content": "After plugins are instantiated, they are being “initialized”. It means just that emuStudio will call Plugin.initialize() method on each plugin. The plugin initializations are ordered by plugin type: . | Compiler | CPU | Memory | Devices in the order as they are defined in the virtual computer configuration | . What should plugin do here . The most important operation what a plugin should do in the Plugin.initialize() method is to obtain “plugin contexts” of another connected plugins. Plugin contexts can be obtained from already mentioned ContextPool class, obtainable from emuStudio API. ",
    "url": "/documentation/developer/plugin_basics/loading#plugin-initialization",
    "relUrl": "/plugin_basics/loading#plugin-initialization"
  },"44": {
    "doc": "Loading and initialization",
    "title": "Loading and initialization",
    "content": " ",
    "url": "/documentation/developer/plugin_basics/loading",
    "relUrl": "/plugin_basics/loading"
  },"45": {
    "doc": "Plugin Root",
    "title": "Plugin root class",
    "content": "A CPU plugin root class must implement either a CPU interface, or extend AbstractCPU class. AbstractCPU implements several mechanisms which save developer time, like: . | emulation control methods (run, step, stop, pause, reset) are queued for execution in the same thread, and implements run state notification. It means that it is possible to call them from any other thread (e.g. also from Swing Event dispatch thread) | implements notification of run states (see next chapter) | implements breakpoints management | . Sample implementation follows (only core methods are implemented): . @PluginRoot( type = PLUGIN_TYPE.CPU, title = \"Sample CPU emulator\" ) @SuppressWarnings(\"unused\") public class CpuImpl extends AbstractCPU { private final ContextImpl context = new ContextImpl(); private EmulatorEngine engine; private Disassembler disassembler; private StatusPanel statusPanel; public CpuImpl(long pluginID, ApplicationApi applicationApi, PluginSettings settings) { super(pluginID, applicationApi, settings); try { applicationApi.getContextPool().register(pluginID, context, ExtendedContext.class); } catch (InvalidContextException | ContextAlreadyRegisteredException e) { LOGGER.error(\"Could not register CPU context\", e); applicationApi.getDialogs().showError( \"Could not register CPU Context. Please see log file for details.\", super.getTitle() ); } } @Override public void initialize() throws PluginInitializationException { MemoryContext&lt;Short&gt; memory = contextPool.getMemoryContext(pluginId, MemoryContext.class); if (memory.getDataType() != Short.class) { throw new InvalidContextException( \"Unexpected memory cell type. Expected Short but was: \" + memory.getDataType() ); } // create disassembler and debug columns this.disassembler = new DisassemblerImpl(memory, new DecoderImpl(memory)); this.engine = new EmulatorEngine(memory, context); } @Override protected void destroyInternal() { context.clearDevices(); } @Override public void resetInternal(int location) { engine.reset(location); } @Override protected RunState stepInternal() throws Exception { return engine.step(); } @Override public JPanel getStatusPanel() { if (statusPanel == null) { statusPanel = new StatusPanel(engine, context); } return statusPanel; } @Override public RunState call() { return engine.run(this); } @Override public Disassembler getDisassembler() { return disassembler; } @Override public int getInstructionLocation() { return engine.PC; } @Override public boolean setInstructionLocation(int position) { if (position &lt; 0) { return false; } engine.PC = position &amp; 0xFFFF; return true; } } . What can be noticed here is: . | this CPU register custom context in constructor. The context is custom, because it will allow attaching devices to specific CPU “ports”. | obtaining MemoryContext is vital. If it is not successful, the PluginInitializationException will be propagated to the caller. | actual CPU emulation is implemented in EmulatorEngine class, which requires a memory and CPU context. | classes DisassemblerImpl and DecoderImpl are generated by Edigen | . ",
    "url": "/documentation/developer/cpu/rootclass#plugin-root-class",
    "relUrl": "/cpu/rootclass#plugin-root-class"
  },"46": {
    "doc": "Plugin Root",
    "title": "Plugin Root",
    "content": " ",
    "url": "/documentation/developer/cpu/rootclass",
    "relUrl": "/cpu/rootclass"
  },"47": {
    "doc": "Run states",
    "title": "Run states",
    "content": "Emulator “life” is a state machine. A state machine reacts on asynchronous events, which make the machine to transition the current state to another state. In emuStudio, whole emulation “state” depends on CPU run state. The run state is a name for the following states: breakpoint (starting state), running, stopped (more variants). The state machine, how it should work, can be seen in the following diagram: . The states of the state machine are encoded into an enum CPU.RunState in emuLib: . public static enum RunState { STATE_STOPPED_NORMAL(\"stopped\"), STATE_STOPPED_BREAK(\"breakpoint\"), STATE_STOPPED_ADDR_FALLOUT(\"stopped (address fallout)\"), STATE_STOPPED_BAD_INSTR(\"stopped (instruction fallout)\"), STATE_RUNNING(\"running\"); ... } . Implementation of the state machine is a sole responsibility of CPU plugin. emuStudio has some expectations of it, like: . | initial run state should be STATE_STOPPED_BREAK | calling reset() should set the run state to STATE_STOPPED_BREAK | calling pause() if the current state is not one of STATE_STOPPED_(how) variant, it should set the run state to STATE_STOPPED_BREAK. Otherwise, do nothing. | calling step() if the current state is one of STATE_STOPPED_(how) (except STATE_STOPPED_BREAK), it should do nothing. Otherwise, it should set the run state to: . | STATE_STOPPED_BREAK, if the execution of the current instruction did not cause error, or it wasn’t a “halt” instruction. | STATE_STOPPED_(how) state, where (how) should be replaced by: . | BAD_INSTR - if unknown instruction was encountered | ADDR_FALLOUT - if instruction pointed to unknown or forbidden memory location | NORMAL - if the instruction was “halt” causing CPU to “halt” | . | . | calling run() should set the state to STATE_RUNNING and run instructions “infinitely”, upon external event or some error, in which case it should set the state to: . | STATE_STOPPED_BREAK - if external call pause() method | STATE_STOPPED_(how) state, where (how) should be replaced by: . | BAD_INSTR - if unknown instruction was encountered | ADDR_FALLOUT - if instruction pointed to unknown or forbidden memory location | NORMAL - if the instruction was “halt” causing CPU to “halt” | . | . | calling stop() if the current state is one of STATE_STOPPED_(how) (except STATE_STOPPED_BREAK), it should do nothing. Otherwise, it should set the state to STATE_STOPPED_NORMAL. | . If the CPU plugin root class implements CPU interface, it is its responsibility to notify CPU run state changes and manage run state “listeners”. But if the plugin root class extends AbstractCPU, it does not have care about listeners and run state notifications, because the class implements it. ",
    "url": "/documentation/developer/cpu/runstate#run-states",
    "relUrl": "/cpu/runstate#run-states"
  },"48": {
    "doc": "Run states",
    "title": "Run states",
    "content": " ",
    "url": "/documentation/developer/cpu/runstate",
    "relUrl": "/cpu/runstate"
  },"49": {
    "doc": "Utility classes",
    "title": "Utility classes",
    "content": "emuLib offers a lot of utility classes which can be helpful to emuStudio plugin developers. This page brings some overview of some of them. Please refer to emuLib javadoc for more detailed information. ",
    "url": "/documentation/developer/plugin_basics/utility_classes#utility-classes",
    "relUrl": "/plugin_basics/utility_classes#utility-classes"
  },"50": {
    "doc": "Utility classes",
    "title": "Intel HEX file generator",
    "content": "Class name net.emustudio.emulib.runtime.io.IntelHEX Usage Generates binary output in ASCII form in famous Intel HEX format. Usually it is useful when writing compiler plugin. Upon code generation, the binary code is “added” to the IntelHEX object instance and then either a file is generated, or the content could be loaded into memory: . byte[] program = ...; // program doesn't necessarily be in this form, especially if program is spread non-continuously IntelHEX hex = new IntelHEX(); for (byte b : program) { hex.add(b); } hex.generate(\"output-file.bin\"); // alternative: // hex.generate(writer); // Loads content into memory // the function `b-&gt;b` is a conversion of bytes to the memory cell type. Here it is assumed memory has Byte cells hex.loadIntoMemory(memory, b -&gt; b); . ",
    "url": "/documentation/developer/plugin_basics/utility_classes#intel-hex-file-generator",
    "relUrl": "/plugin_basics/utility_classes#intel-hex-file-generator"
  },"51": {
    "doc": "Utility classes",
    "title": "Bits utilities",
    "content": "Class name net.emustudio.emulib.runtime.helpers.Bits Usage Wraps int number and allows various bit-like operations on it (int has 4 bytes) Few useful operations: . | Bits absolute(): Make the absolute value from the number stored in two’s complement. | Bits reverseBits(): Reverses bits in each byte (max 4 bytes). | Bits reverseBytes(): Reverses the bytes. | Bits shiftLeft(): Shift the value to the left. | Bits shiftRight(): Shift the value to the right. | byte[] toBytes(): Converts wrapped int into array of 4 bytes | . This class is heavily used by edigen dissasembler generator. ",
    "url": "/documentation/developer/plugin_basics/utility_classes#bits-utilities",
    "relUrl": "/plugin_basics/utility_classes#bits-utilities"
  },"52": {
    "doc": "Utility classes",
    "title": "Number utilities",
    "content": "Class name net.emustudio.emulib.runtime.helpers Usage Lot of useful conversions between various number types. Few useful operations: . | static int bcd2bin(int bcd): Converts packed BCD code (1 byte, 2 BCD digits) to binary It is assumed the BCD has little endian. | static int bin2bcd(int bin): Converts a binary number into packed BCD (1 byte, 2 BCD digits) | static int[] listToNativeInts(java.util.List&lt;java.lang.Integer&gt; list): Converts list of Integers into array of native ints. | static java.lang.Byte[] nativeBytesToBytes(byte[] array): Converts native byte[] array to boxed Byte[] array. | static java.lang.Integer[] nativeBytesToIntegers(byte[] array): Converts native byte[] array to boxed Integer[] array. | … | static int readBits(byte[] bytes, int start, int length, int bytesStrategy): Reads an arbitrary number of bits from bytes. | static int readInt(byte[] word, int strategy): Reads an integer from the array of numbers. | … | static int reverseBits(int value, int numberOfBits): Reverse bits in integer (max 32-bit) value. | … | static void writeInt(int value, byte[] output, int strategy): Split the value into 4 bytes. | … | . ",
    "url": "/documentation/developer/plugin_basics/utility_classes#number-utilities",
    "relUrl": "/plugin_basics/utility_classes#number-utilities"
  },"53": {
    "doc": "Utility classes",
    "title": "Radix utilities",
    "content": "Class name net.emustudio.emulib.runtime.helpers.RadixUtils Usage Utility functions for various radix conversions. At first, an instance of RadixUtils must be created, because of some pattern regex pre-compilation and possibility to add new radixes dynamically. Usually, a singleton instance is used throughout the application (it’s not thread-safe!). Few useful operations: . | void addNumberPattern(RadixUtils.NumberPattern pattern): Add NumberPattern for new radix recognition | static byte[] convertToNumber(java.lang.String number, int fromRadix): Convert an integer number in any radix (stored in String) to binary components (bytes) in little endian. | … | static java.lang.String convertToRadix(byte[] number, int toRadix, boolean littleEndian): Converts number in any length to a number with specified radix. | … | static java.lang.String formatBinaryString(int number, int length): Get formatted binary string of given number. | … | static RadixUtils getInstance(): returns a singleton instance | int parseRadix(java.lang.String number): Parses a number in known radix into integer. | … | . ",
    "url": "/documentation/developer/plugin_basics/utility_classes#radix-utilities",
    "relUrl": "/plugin_basics/utility_classes#radix-utilities"
  },"54": {
    "doc": "Utility classes",
    "title": "Sleep utilities",
    "content": "Class name net.emustudio.emulib.runtime.helpers.SleepUtils Usage Provides a function for accurate sleeping of the active thread in all host platforms (Windows, Linux). The function SleepUtils.preciseSleepNanos is more precise than LockSupport::sleepNanos. ",
    "url": "/documentation/developer/plugin_basics/utility_classes#sleep-utilities",
    "relUrl": "/plugin_basics/utility_classes#sleep-utilities"
  },"55": {
    "doc": "Utility classes",
    "title": "Timed event processing",
    "content": "Class name net.emustudio.emulib.plugins.cpu.TimedEventsProcessor Usage soft real-time system based on a logical system clock, interpreted as number of passed CPU cycles. Events are scheduled to be run every given cycles. This class is asynchronous, and thread safe event queue based on logical time. It means time is not advanced regularly, but it is advanced on external calls of TimedEventsProcessor.advanceClock() method, and by given number of “CPU cycles”. Events are scheduled to be executed every given “cycles” regularly. When the clock is advanced enough to pass over scheduled time of some events, those events are triggered. This class is part of plugins.cpu package, because advancing system clock is performed by CPU if the instance is obtained through CPUContext.getTimedEventsProcessor() method. Thus, it is part of CPU public API. It is still possible to use this class independently too, but then use must make new instance and make sure of advancing the clock for events to be triggered. Timed event processing can be used for accurate emulation of multiple devices which speed or actions depend on the number of executed CPU cycles. ",
    "url": "/documentation/developer/plugin_basics/utility_classes#timed-event-processing",
    "relUrl": "/plugin_basics/utility_classes#timed-event-processing"
  },"56": {
    "doc": "Utility classes",
    "title": "Utility classes",
    "content": " ",
    "url": "/documentation/developer/plugin_basics/utility_classes",
    "relUrl": "/plugin_basics/utility_classes"
  }
}
