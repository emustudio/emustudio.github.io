{"0": {
    "doc": "CPU \"8080-cpu\"",
    "title": "Intel 8080 CPU emulator",
    "content": "Altair 8800 originally came with processor Intel 8080. It is an 8-bit microprocessor, from 1974. The initial clock frequency was 2 MHZ. This processor was one of the first general-purpose and widespread processors, used not only in calculators but also in first personal computers. One of the key roles why this CPU become so popular is that Gary Kildall targeted his CP/M to this CPU; and CP/M was de facto a “standard” in personal computers those days. Main features of the emulator include: . | Threaded-dispatch combined with interpretation as emulation technique, | Correct real timing of instructions, | Ability to set clock frequency manually at run-time, | Emulation of all instructions including interrupts, | Disassembler implementation, | Ability to “dump” instruction history to console at run-time, | Support of breakpoints, | Ability of communication with up to 256 I/O devices, | Status window shows all registers, flags, and run-time frequency. | . ",
    "url": "/documentation/user/altair8800/8080-cpu#intel-8080-cpu-emulator",
    "relUrl": "/altair8800/8080-cpu#intel-8080-cpu-emulator"
  },"1": {
    "doc": "CPU \"8080-cpu\"",
    "title": "Configuration file",
    "content": "The following table shows all the possible settings of Intel 8080 CPU plugin: . | Name | Default value | Valid values | Description | . | printCode | false | true / false | Whether the emulator should print executed instructions, and its internal state to console (dump) | . | printCodeUseCache | false | true / false | If printCode is set to true, then a cache will be used which remembers already visited blocks of code so the instruction dump will not be bloated with infinite loops | . | frequency_khz | 2000 | &gt; 0 | CPU frequency set on emuStudio startup (it can be changed in runtime, but won’t be saved in settings) | . ",
    "url": "/documentation/user/altair8800/8080-cpu#configuration-file",
    "relUrl": "/altair8800/8080-cpu#configuration-file"
  },"2": {
    "doc": "CPU \"8080-cpu\"",
    "title": "Dumping executed instructions",
    "content": "The CPU offers a unique feature, which is the ability to dump executed instructions as a sequence to the console. When enabled, then each executed instruction - together with the content of flags and registers values after the execution is printed. This feature might be extremely useful in two cases: . | Reverse engineering of some unknown software | It allows us to build tools for automatic checking of register values during the emulation when performing automatic emulation. | . To enable this feature, please see the section “Configuration file”. For example, let’s take one example which computes a reverse text: . ; Print reversed text org 1000 dcx sp ; stack initialization (0FFFFh) lxi h,text1 call putstr ; print text1 lxi d,input ; address for string input call getline ; read from keyboard lxi b,input mvi d,0 ; chars counter char_loop: ldax b inx b ; bc = bc+1 cpi 10 ; end of input? jz char_end cpi 13 jz char_end inr d ; d =d+1 jmp char_loop char_end: dcx b ; bc = bc-1 dcx b call newline char2_loop: ldax b call putchar dcx b dcr d jz char2_end jmp char2_loop char2_end: hlt include 'include\\getchar.inc' include 'include\\getline.inc' include 'include\\putstr.inc' include 'include\\putchar.inc' include 'include\\newline.inc' text1: db 'Reversed text ...',10,13,'Enter text: ',0 text2: db 10,13,'Reversed: ',0 input: ds 30 . When the program is being run, and the dump instructions feature is turned on, on console you can see the following output: . 0000 | PC=03e8 | dcx SP | 3B || regs=00 00 00 00 00 00 00 00 | flags= | SP=ffff | PC=03e9 0001 | PC=03e9 | lxi HL, 485 | 21 85 04 || regs=00 00 00 00 04 85 00 00 | flags= | SP=ffff | PC=03ec 0001 | PC=03ec | call 46D | CD 6D 04 || regs=00 00 00 00 04 85 00 00 | flags= | SP=fffd | PC=046d 0002 | PC=046d | mov A, M | 7E || regs=00 00 00 00 04 85 00 52 | flags= | SP=fffd | PC=046e 0002 | PC=046e | inx HL | 23 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=046f 0003 | PC=046f | cpi 0 | FE 00 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=0471 0004 | PC=0471 | rz | C8 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=0472 0005 | PC=0472 | out 11 | D3 11 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=0474 0006 | PC=0474 | jmp 46D | C3 6D 04 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=046d 0006 | PC=046d | mov A, M | 7E || regs=00 00 00 00 04 86 00 65 | flags= | SP=fffd | PC=046e 0024 | Block from 0474 to 03EF; count=184 0024 | PC=03ef | lxi DE, 4B2 | 11 B2 04 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=ffff | PC=03f2 0025 | PC=03f2 | call 428 | CD 28 04 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=0428 0025 | PC=0428 | mvi C, 0 | 0E 00 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042a 0025 | PC=042a | in 10 | DB 10 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042c 0026 | PC=042c | ani 1 | E6 01 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042e 0026 | PC=042e | jz 42A | CA 2A 04 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042a 0027 | PC=042a | in 10 | DB 10 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042c 1548 | Block from 042E to 0431; count=181125 1548 | PC=0431 | in 11 | DB 11 || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=0433 1548 | PC=0433 | cpi D | FE 0D || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=0435 1548 | PC=0435 | jz 461 | CA 61 04 || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=0438 1548 | PC=0438 | cpi A | FE 0A || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=043a 1549 | PC=043a | jz 461 | CA 61 04 || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=043d 1549 | PC=043d | cpi 8 | FE 08 || regs=00 00 04 b2 04 a5 00 68 | flags= AP | SP=fffd | PC=043f 1549 | PC=043f | jnz 459 | C2 59 04 || regs=00 00 04 b2 04 a5 00 68 | flags= AP | SP=fffd | PC=0459 1549 | PC=0459 | out 11 | D3 11 || regs=00 00 04 b2 04 a5 00 68 | flags= AP | SP=fffd | PC=045b 1549 | PC=045b | stax DE | 12 || regs=00 00 04 b2 04 a5 00 68 | flags= AP | SP=fffd | PC=045c 1549 | PC=045c | inx DE | 13 || regs=00 00 04 b3 04 a5 00 68 | flags= AP | SP=fffd | PC=045d 1549 | PC=045d | inr C | 0C || regs=00 01 04 b3 04 a5 00 68 | flags= | SP=fffd | PC=045e 1549 | PC=045e | jmp 42A | C3 2A 04 || regs=00 01 04 b3 04 a5 00 68 | flags= | SP=fffd | PC=042a 1550 | PC=042a | in 10 | DB 10 || regs=00 01 04 b3 04 a5 00 00 | flags= | SP=fffd | PC=042c 2940 | Block from 045E to 0461; count=267777 2940 | PC=0461 | mvi A, A | 3E 0A || regs=00 05 04 b7 04 a5 00 0a | flags= ZAP | SP=fffd | PC=0463 2940 | PC=0463 | stax DE | 12 || regs=00 05 04 b7 04 a5 00 0a | flags= ZAP | SP=fffd | PC=0464 2940 | PC=0464 | inx DE | 13 || regs=00 05 04 b8 04 a5 00 0a | flags= ZAP | SP=fffd | PC=0465 2940 | PC=0465 | mvi A, D | 3E 0D || regs=00 05 04 b8 04 a5 00 0d | flags= ZAP | SP=fffd | PC=0467 2940 | PC=0467 | stax DE | 12 || regs=00 05 04 b8 04 a5 00 0d | flags= ZAP | SP=fffd | PC=0468 2940 | PC=0468 | inx DE | 13 || regs=00 05 04 b9 04 a5 00 0d | flags= ZAP | SP=fffd | PC=0469 2940 | PC=0469 | mvi A, 0 | 3E 00 || regs=00 05 04 b9 04 a5 00 00 | flags= ZAP | SP=fffd | PC=046b 2941 | PC=046b | stax DE | 12 || regs=00 05 04 b9 04 a5 00 00 | flags= ZAP | SP=fffd | PC=046c 2941 | PC=046c | ret | C9 || regs=00 05 04 b9 04 a5 00 00 | flags= ZAP | SP=ffff | PC=03f5 2941 | PC=03f5 | lxi BC, 4B2 | 01 B2 04 || regs=04 b2 04 b9 04 a5 00 00 | flags= ZAP | SP=ffff | PC=03f8 2941 | PC=03f8 | mvi D, 0 | 16 00 || regs=04 b2 00 b9 04 a5 00 00 | flags= ZAP | SP=ffff | PC=03fa 2941 | PC=03fa | ldax BC | 0A || regs=04 b2 00 b9 04 a5 00 68 | flags= ZAP | SP=ffff | PC=03fb 2941 | PC=03fb | inx BC | 03 || regs=04 b3 00 b9 04 a5 00 68 | flags= ZAP | SP=ffff | PC=03fc 2941 | PC=03fc | cpi A | FE 0A || regs=04 b3 00 b9 04 a5 00 68 | flags= | SP=ffff | PC=03fe 2941 | PC=03fe | jz 40A | CA 0A 04 || regs=04 b3 00 b9 04 a5 00 68 | flags= | SP=ffff | PC=0401 2942 | PC=0401 | cpi D | FE 0D || regs=04 b3 00 b9 04 a5 00 68 | flags= | SP=ffff | PC=0403 2942 | PC=0403 | jz 40A | CA 0A 04 || regs=04 b3 00 b9 04 a5 00 68 | flags= | SP=ffff | PC=0406 2942 | PC=0406 | inr D | 14 || regs=04 b3 01 b9 04 a5 00 68 | flags= | SP=ffff | PC=0407 2942 | PC=0407 | jmp 3FA | C3 FA 03 || regs=04 b3 01 b9 04 a5 00 68 | flags= | SP=ffff | PC=03fa 2942 | PC=03fa | ldax BC | 0A || regs=04 b3 01 b9 04 a5 00 65 | flags= | SP=ffff | PC=03fb 2942 | Block from 0407 to 040A; count=36 2942 | PC=040a | dcx BC | 0B || regs=04 b7 05 b9 04 a5 00 0a | flags= ZAP | SP=ffff | PC=040b 2943 | PC=040b | dcx BC | 0B || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=ffff | PC=040c 2943 | PC=040c | call 47A | CD 7A 04 || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffd | PC=047a 2943 | PC=047a | mvi A, A | 3E 0A || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffd | PC=047c 2943 | PC=047c | call 477 | CD 77 04 || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffb | PC=0477 2943 | PC=0477 | out 11 | D3 11 || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffb | PC=0479 2943 | PC=0479 | ret | C9 || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffd | PC=047f 2943 | PC=047f | mvi A, D | 3E 0D || regs=04 b6 05 b9 04 a5 00 0d | flags= ZAP | SP=fffd | PC=0481 2943 | PC=0481 | call 477 | CD 77 04 || regs=04 b6 05 b9 04 a5 00 0d | flags= ZAP | SP=fffb | PC=0477 2943 | PC=0477 | out 11 | D3 11 || regs=04 b6 05 b9 04 a5 00 0d | flags= ZAP | SP=fffb | PC=0479 2943 | Block from 0481 to 0484; count=2 2943 | PC=0484 | ret | C9 || regs=04 b6 05 b9 04 a5 00 0d | flags= ZAP | SP=ffff | PC=040f 2944 | PC=040f | ldax BC | 0A || regs=04 b6 05 b9 04 a5 00 6f | flags= ZAP | SP=ffff | PC=0410 2944 | PC=0410 | call 477 | CD 77 04 || regs=04 b6 05 b9 04 a5 00 6f | flags= ZAP | SP=fffd | PC=0477 2944 | PC=0477 | out 11 | D3 11 || regs=04 b6 05 b9 04 a5 00 6f | flags= ZAP | SP=fffd | PC=0479 2944 | Block from 0410 to 0413; count=2 2944 | PC=0413 | dcx BC | 0B || regs=04 b5 05 b9 04 a5 00 6f | flags= ZAP | SP=ffff | PC=0414 2944 | PC=0414 | dcr D | 15 || regs=04 b5 04 b9 04 a5 00 6f | flags= A | SP=ffff | PC=0415 2944 | PC=0415 | jz 41B | CA 1B 04 || regs=04 b5 04 b9 04 a5 00 6f | flags= A | SP=ffff | PC=0418 2944 | PC=0418 | jmp 40F | C3 0F 04 || regs=04 b5 04 b9 04 a5 00 6f | flags= A | SP=ffff | PC=040f 2944 | PC=040f | ldax BC | 0A || regs=04 b5 04 b9 04 a5 00 6c | flags= A | SP=ffff | PC=0410 2945 | Block from 0418 to 041B; count=31 2945 | PC=041b | hlt | 76 || regs=04 b1 00 b9 04 a5 00 68 | flags= ZAP | SP=ffff | PC=041c . The dump format consists of lines, each line represents one instruction execution. The line is separated by | chars, splitting it into so-called sections. Sections before the sequence || represent the state before instruction execution, and sections after it represent the state after instruction execution. Particular sections are described in the following table. | Column | Description | . | 1 | Timestamp from program start (seconds) | . | 2 | Program counter before instruction execution | . | 3 | Disassembled instruction | . | 4 | Instruction opcodes | . |   | Now follows the state after instruction execution | . | 5 | Register values (B,C,D,E,H,L, reserved (always 0), A) | . | 6 | Flags | . | 7 | Stack pointer register (SP) | . | 8 | Program counter after instruction execution | . ",
    "url": "/documentation/user/altair8800/8080-cpu#dumping-executed-instructions",
    "relUrl": "/altair8800/8080-cpu#dumping-executed-instructions"
  },"3": {
    "doc": "CPU \"8080-cpu\"",
    "title": "CPU \"8080-cpu\"",
    "content": " ",
    "url": "/documentation/user/altair8800/8080-cpu",
    "relUrl": "/altair8800/8080-cpu"
  },"4": {
    "doc": "Device \"88-dcdd\"",
    "title": "Altair Floppy Disk (88-DCDD)",
    "content": "Altair floppy disk (88-DCDD) offered the advantage of permanent store including relatively fast access to data. The speed of data transfer was 250 Kbit/s (The plugin does not emulate this). Data transfer was serial, byte after byte. (The image was borrowed from deramp.com). The 88-DCDD hardware contained three parts: . | disk drive (initially Pertec FD400), able to store ~330 kB of data on 8” diskette | two boards connected to S-100 bus . | the first one performed communication operations between the bus and CPU | the second one performed communication with the disk drives | . | . Original manual can be found at deramp.com or www.virtualaltair.com. ",
    "url": "/documentation/user/altair8800/88-dcdd#altair-floppy-disk-88-dcdd",
    "relUrl": "/altair8800/88-dcdd#altair-floppy-disk-88-dcdd"
  },"5": {
    "doc": "Device \"88-dcdd\"",
    "title": "Diskette formats",
    "content": "A diskette was introduced by IBM in 1971 for being able to load programs into IBM mainframes. Soon a revolution in personal computers brought diskettes into the world of microcomputers. Standard Altair 8” diskette had the following parameters: . | Description | Value | . | Maximum capacity | 330 kB | . | Recording density | 6331 bits per radian (3268 bits per inch) | . | Tracks | 77 | . | Sectors per track | 32 | . | Sector size | 137 bytes | . (info from Pertec FD400 manual, this blogpost and simh emulator) . ",
    "url": "/documentation/user/altair8800/88-dcdd#diskette-formats",
    "relUrl": "/altair8800/88-dcdd#diskette-formats"
  },"6": {
    "doc": "Device \"88-dcdd\"",
    "title": "Features of the plugin",
    "content": "The 88-dcdd plugin emulates basic functionality of the whole disk system for Altair 8800 computer. It is not only disk controller, but also includes 16 disk drives. Feature highlights are: . | Up to 16 disk images can be mounted, optionally mounted automatically on startup | CPU ports can be set manually | GUI showing disk activity in runtime | Interrupts are supported | . GUI can be seen in the following image: . The window shows runtime status of virtual disk drives. By clicking on a drive button, its details are revealed below. Port1 is showing 88-dcdd status, ordered from the MSB to LSB, and instead of showing 1 and 0s, every bit is mapped to a letter: . | R (bit 7): “New read data” available - indicates that one byte of data is available to be read from port 2 | Z (bit 6): Indicates when head is on outermost track (track 0) | I (bit 5): Indicates interrupts enabled (value=0) or disabled (value=1) | H (bit 2): Head status (loaded: value=0, unloaded: value=1) | M (bit 1): Indicates head movement allowed (allowed: value=0, disallowed: value=1) | W (bit 0): “Enter new write data” - indicates new byte of data can be written to port 2 | . You might notice on “true” condition the bit value of Port 1 is 0. Also, the drive button icon color reflects the head status: green means head is loaded, red means head is unloaded. See 88-dcdd manual for more details. ",
    "url": "/documentation/user/altair8800/88-dcdd#features-of-the-plugin",
    "relUrl": "/altair8800/88-dcdd#features-of-the-plugin"
  },"7": {
    "doc": "Device \"88-dcdd\"",
    "title": "Mounting disk images",
    "content": "In order to mount disk images to the device, please open device settings: . | 1 | Select drive (A - P) | . | 2 | Choose the image file and click on “Mount”. If there is a disk mounted already, it will be re-mounted with the new file. | . | 3 | If you want to un-mount all disk drives, click on “Umount all” button | . | 4 | Set sectors per track and sector size for the current drive. (NOTE: Be cautious with the settings. Incorrect values can result in disk image file damage. Existing default values were chosen from disk image files used by simh emulator). | . | 5 | Set default values for sectors per track and sector size for the current drive. | . ",
    "url": "/documentation/user/altair8800/88-dcdd#mounting-disk-images",
    "relUrl": "/altair8800/88-dcdd#mounting-disk-images"
  },"8": {
    "doc": "Device \"88-dcdd\"",
    "title": "CPU Ports settings",
    "content": "A control board of Altair disk communicates with CPU through its ports. There are three ports overall, each for different function. By default, the port mapping to CPU port numbers is as follows: . | Port 1: 0x08 - in: disk status information, out: select disk | Port 2: 0x09 - in: get number of sector, out: disk settings | Port 3: 0x0A - in: read data, out: write data | . Port mapping can be changed in the Settings window, tab “CPU Ports”: . | 1 | Set CPU port number value for the three 88-dcdd ports | . | 2 | Set used CPU interrupt vector and whether interrupts are actually supported by 88-dcdd. Interrupt vector is used when interrupt is signalled to the CPU which is implemented as equivalent to executing an instruction RST. When interrupts are globally disabled here, enabling them in runtime won’t work. | . | 3 | Setting default interrupt vector (which is 7) | . ",
    "url": "/documentation/user/altair8800/88-dcdd#cpu-ports-settings",
    "relUrl": "/altair8800/88-dcdd#cpu-ports-settings"
  },"9": {
    "doc": "Device \"88-dcdd\"",
    "title": "Programming",
    "content": "The basic idea is to programmatically select a drive, then set a “position”. After that data can be either read or written. For nice introduction with historical context see this nice blog post. The “position” in the floppy disk is determined by a track number, sector number and the offset within the sector. It is rudimentary to know how many tracks are available, so as how many sectors per track and the sector size. In Altair8800, drive Pertec FD400 used 8” diskettes. Each had 77 tracks. A track had 32 sectors with 137 bytes long. The capacity of a diskette was therefore 77 * 32 * 137 = 337568 B = 330 kB. Software used less capacity, because 9 bytes of each sector were used for the integrity checksum. Setting the position . In the original device, the position was changing automatically by the diskette rotation inside the disk drive. Since CPU was much faster than a rotation, the idea was to probe the current drive position (track and sector number) from the CPU and when the position matched the requested one, data could be read or written. emuStudio plugin does this in a more predictable way. Instead of automatic changing the position asynchronously, it is changed in time when a programmer actually performs the probing. For example, to set the sector number to - say - 5, the programmer must probe the sector 5 times. Setting the offset within a sector is more challenging. After the track and sector are set, programmer must - again - probe the status port telling if current disk position is actually set at the beginning of the sector. If so, then a programmer must read the data until which increments the position, until the position is as requested. CPU Ports . In the real world, two controller boards communicated with CPU using three I/O ports. The plugin utilizes the ports the same way as the real device. The following table shows the CPU ports and how they are used. | Port | Address | Input | Output | . | 1 | 0x08 | Disk and controller status | Select disk | . | 2 | 0x09 | Get number of sector | Disk settings | . | 3 | 0x0A | Read data | Write data | . Now, detailed description of the ports follow. Bits are ordered in a byte as follows: . D7 D6 D5 D4 D3 D2 D1 D0 . where D7 is the most significant bit, and D0 the least significant bit. Port 1 (default address: 0x08) . WRITE: . Selects and enables one of 16 disk devices. By selecting a drive, all further operations will be performed on that drive. If the disk has not mounted any disk image, all further operations will be ignored. The previously selected device will be disabled. | D7 : if the value is 1, disable the drive. If the value is 0, select and enable the drive. | D6 D5 D4 : unused bits | D3 D2 D1 D0: index of the drive to be selected. From 0-15. | . READ: . Read disk status of the selected drive. | D7 : New read data available. Indicates if there is at least 1 byte available for reading from Port 3 (value=0). It will be reset after data are read (value=1). If the value is 1, data read from Port 3 will be invalid or no new data is available. | D6 : Track 0. Indicates if the head is positioned at track 0 (value=0). | D5 : Interrupt Enabled. Indicates if interrupts are used (value=0). | D4 D3 : Unused bits; they are always 0. | D2 : Head Status. Indicates the correctness of the head setting. If the value is 0, reading sector number from Port 2 will be valid. | D1 : Move head. Indicates if the movement of the disk head is allowed. If the value is 1, all track number changes will be ignored. | D0 : Enter new write data. Indicates if the device is ready for writing data. If the value is 1, all written data will be ignored. | . Initial values of the bits are: 11100111. Port 2 (default address: 0x09) . WRITE: . Control the disk head, and other settings if a disk drive is selected. | D7 : Write Enable. Initializes write sequence (enables writing to the disk; value=1). The plugin sets the sector number to 0 and also value 0 to bit D0 of Port 1 (Enter new write data). According to the manual, a writing sequence holds only for short time, maximally until the end of sector is reached. The plugin does not limit the sequence period, it is deactivated only when the end of the sector is reached. In addition, each first byte and the last byte of a sector should have set its MSB (7th bit) to 1. It was called the “sync bit” for easier identification of start or end of a sector. However, the plugin does not require it. | D7 : Write Enable. Initializes write sequence (enables writing to the disk; value=1). The plugin sets the sector number to 0 and also value 0 to bit D0 of Port 1 (Enter new write data). According to the manual, a writing sequence holds only for short time, maximally until the end of sector is reached. The plugin does not limit the sequence period, it is deactivated only when the end of the sector is reached. In addition, each first byte and the last byte of a sector should have set its MSB (7th bit) to 1. It was called the “sync bit” for easier identification of start or end of a sector. However, the plugin does not require it. | D6 : Head Current Switch. On real disks the bit should be set to 1 when a program is writing data to tracks from 43-76. The plugin the bit is ignored. | D5 : Interrupt Disable. If set to 1, interrupts support will be disabled. | D4 : Interrupt Enable. If set to 1, interrupts support will be enabled. Interrupt will be signalled to CPU on “sector true” event. This effectively means on every other position reading (see READ part below). The device will emit interrupt vector equivalent to executing an RST instruction. The interrupt vector number is set up globally in the plugin settings. | D3 : Head unload. Removes head from the disk surface. Reading sector number will now become invalid. In addition, value of bit D7 from Port 1 (New read data available) become 1 (no new data). | D2 : Head load. Sets the disk head onto disk surface. Reading sector number now becomes valid. If additionally the bit D7 from Port 1 (New data available) is set, it is possible to read data from the disk. | D1 : Step Out. Move the disk head back by 1 track (the track number is decremented). It is required to check bit D1 of Port 1 (Move head) to have value 0. | D0 : Step In. Move the disk head ahead by 1 track (the track number is incremented). It is required to check bit D1 of Port 1 (Move head) to have value 0. | . READ: . Reads the number of the sector. The value can be read only if a disk drive is selected and the disk head is positioned at the disk surface (by setting the bit D2). | D7 D6 : Unused bits; they are always 1. | D5 D4 D3 D2 D1: Number of the sector, counted from 0. | D0 : Sector True. If the value is 0, the offset in sector is 0. According to manual, the bit is set for maximum 30 microseconds. Programs could detect the bit set and quickly start writing data until the Sector true came back again. It could be made in time easily, because CPU was much faster than disk itself. plugin does not limit the period. The value is 0 practically all the time, until first byte is written. | . Port 3 (default address: 0x0A) . WRITE: . Write a byte to disk. In order to perform valid write, the Write Enable D7 bit of Port 2 must be set to 1. Before data are written to disk, it is required to check bit D0 from Port 1 (Enter new write data). READ: . Read a byte from disk. In order to perform valid read, the Head load D2 bit of Port 2 must be set to 1. Only if bit D7 from Port 1 (New read data available) is set to 0, the read data are valid. Program example . In this section, an example is presented showing how to read/write data from/to the floppy disk. At first, it writes one byte (letter A with ASCII value 65) to track 1, sector 18 and offset 20. Then, it reads the byte to operating memory at address 0x200. The program uses 3 procedures (in assembler for Intel 8080) for setting the disk position (ltrack for loading the track number, lsector for loading the sector number, and loffset for loading the offset within the sector) and two more for data reading (read) and writing (write). disk0 equ 0 ; disk number track equ 1 ; track number sector equ 18 ; sector number offset equ 20 ; offset within the sector data equ 'A' ; data for writing dcx sp ; set stack register to 0xFFFF mvi a, disk0 ; select disk out 08h call ltrack ; set track number call we ; set 'write enable' sequence call lsector ; set sector number call loffset ; set sector offset call write ; write data call lsector ; set sector number (for clearing the offset) call loffset ; set sector offset call read ; read data lxi h, readdata ; load address for reading the data mov m, a ; move the data there hlt ; end ltrack0: ; the procedure will set track number to 0 in 08h ; read disk status ani 1000000b ; track 0 ? rz ; yes, return mvi a, 1000b ; head unload out 09h call movetrk ; wait until the disk head can be moved mvi a, 10b ; step out, decrement track number out 08h jmp ltrack0 ltrack: ; procedure sets a track number call ltrack0 ; at first, set track number to 0 mvi b, track+1 ; b = track + 1 stepin: ; stepin: { dcr b ; b--; rz ; if (b == 0) return; call movetrk ; wait until the disk head can be moved mvi a, 1 ; step in, increment track number out 09h jmp stepin ; goto stepin; ; } movetrk: ; procedure waits until the disk head can be moved in 08h ; read disk status ani 10b ; can the disk head be moved? jnz movetrk ; nope, try again... ret ; yes, return lsector: ; procedure sets a sector number mvi a, 100b ; head load out 09h waits: in 09h ; read sector number ani 3Fh ; clear unused bits rrc cpi sector ; is the number what is requested? jnz waits ; nope, try again ret ; yes, return loffset: ; procedure sets a sector offset mvi b, offset+1 ; b = offset + 1 stepoff: ; stepoff: { dcr b ; b--; rz ; if (b == 0) return; call read ; read data; the offset is incremented jmp stepoff ; goto stepoff; ; } read: ; procedure reads data from the disk in 08h ; read disk status ani 100b ; check if the disk head is loaded on the disk surface rnz ; if not, return waitr: in 08h ; read disk status ani 10000000b ; New read data available ? jnz waitr ; nope, try again... in 0Ah ; yes, read data ret ; return we: ; procedure enables 'write enable' sequence mvi a, 10000000b ; write enable out 09h ret write: ; procedure writes data to the disk in 08h ; read disk status ani 100b ; check if the disk head is loaded on the disk surface rnz ; if not, return waitw: in 08h ; read disk status ani 1 ; enter new write data ? jnz waitw ; nope, try again... mvi a, data ; yes, write data out 0Ah ret org 200h readdata: db 0 . ",
    "url": "/documentation/user/altair8800/88-dcdd#programming",
    "relUrl": "/altair8800/88-dcdd#programming"
  },"10": {
    "doc": "Device \"88-dcdd\"",
    "title": "Experimental CP/M support",
    "content": "88-dcdd plugin adds highly experimental support of handling files on a CP/M filesystem. It is now possible to create disk images, and read/write files from/to a disk image using CP/M filesystem. The CP/M tool can be accessed from command-line: . &gt; bin/88-dcdd --help Usage: 88-dcdd [-hV] [-F=FILE] (-l | (-f=FORMAT -i=FILE)) [COMMAND] 88-DCDD Altair floppy disk drive -f, --format=FORMAT disk format ID -F, --format-file=FILE disk format file (TOML) -h, --help Show this help message and exit. -i, --image=FILE disk image file -l, --list-formats lists available disk format IDs -V, --version Print version information and exit. Commands: cpmfs, cpm CP/M filesystem commands . In order to be able to work with a disk image, the tool needs to know disk image format. The disk format is selected using -f argument, followed by format ID. Example files reading/writing . In order to work with a disk image the image file and disk format must be selected, followed by a CP/M command: . &gt; bin/88-dcdd -i altcpm.dsk -f cpm2-simh cpm Missing required subcommand Usage: 88-dcdd cpmfs [-hV] [COMMAND] CP/M filesystem commands -h, --help Show this help message and exit. -V, --version Print version information and exit. Commands: cat Show file content copy, cp Copy files dates Show files dates format Format CP/M disk image info Volume information list, ls List files remove, rm Remove file . Now you can see all the options of the CP/M tool. Let’s list all the files in the disk image: . &gt; bin/88-dcdd -i altcpm.dsk -f cpm2-simh cpm ls St |File name |Flags |Ex |S2 |Rc |Bc |Al --------------------------------------------- 00 | STAT.COM |00 |00 |2a |00 |08 09 0A 0B 0C 0D 00 00 00 00 00 00 00 00 00 00 00 | PIP.COM |00 |00 |3a |00 |0E 0F 10 11 12 13 14 15 00 00 00 00 00 00 00 00 00 | ED.COM |00 |00 |34 |00 |16 17 18 19 1A 1B 1C 00 00 00 00 00 00 00 00 00 00 | DDT.COM |00 |00 |26 |00 |1D 1E 1F 20 21 00 00 00 00 00 00 00 00 00 00 00 00 | ASM.COM |00 |00 |40 |00 |22 23 24 25 26 27 28 29 00 00 00 00 00 00 00 00 00 | LOAD.COM |00 |00 |0e |00 |2A 2B 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | SUBMIT.COM |00 |00 |10 |00 |2C 2D 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | XSUB.COM |00 |00 |06 |00 |2E 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | MOVCPM.COM |00 |00 |60 |00 |2F 30 31 32 33 34 35 36 37 38 39 3A 00 00 00 00 00 | COPY.COM |00 |00 |06 |00 |3B 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | FORMAT.COM |00 |00 |0e |00 |3C 3D 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | DUMP.COM |00 |00 |03 |00 |3E 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | SYSGEN.SUB |00 |00 |02 |00 |3F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | DUMP.ASM |00 |00 |26 |00 |45 46 47 48 49 00 00 00 00 00 00 00 00 00 00 00 00 | PTD.HEX |00 |00 |06 |00 |4A 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ABOOT62.HEX |00 |00 |01 |00 |4B 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | CBIOS.HEX |00 |00 |16 |00 |4C 4D 4E 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | CBIOS.ASM |00 |00 |3d |00 |61 62 63 6D 6E 72 73 74 00 00 00 00 00 00 00 00 00 | PTD.ASM |00 |00 |0e |00 |5F 60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | LS.COM |00 |00 |18 |00 |40 41 42 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | CPM62.COM |00 |00 |48 |00 |64 65 66 67 68 69 6A 6B 6C 00 00 00 00 00 00 00 00 | SURVEY.COM |00 |00 |0a |00 |50 51 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ABOOT62.ASM |00 |00 |04 |00 |86 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 . In order to copy a file to host filesystem, it is possible to use copy subcommand, but for outputting it on screen let’s use cat: . &gt; bin/88-dcdd -i altcpm.dsk -f cpm2-simh cpm cat CBIOS.ASM ; ALTAIR 8800 BIOS WITH 8800 DISK DRIVES - 256 FILES EACH ; MSIZE EQU 62 ;MEMORY SIZE BIAS EQU (MSIZE-20)*1024 CCP EQU 3400H+BIAS ;START OF CCP BDOS EQU CCP+806H BIOS EQU CCP+1600H ORG BIOS NSECTS EQU ($-CCP)/128 ;# SECTORS TO BOOT LADDR EQU CCP+(51*128) PART2 EQU CCP+(27*128) IOBYTE EQU 3 CDISK EQU 4 ... In order to write a file to a disk image, let’s prepare one, name it test on a host filesystem: . Testing, testing! . In order to copy the file on the disk image, let’s use the already mentioned copy command: . &gt; bin/88-dcdd -i altcpm.dsk -f cpm2-simh cpm cp --help Copy files Usage: 88-dcdd cpmfs copy [-hV] SRC_FILE DST_FILE Copy a file between CP/M disk image and host SRC_FILE source file (cpm:// prefix if in CP/M disk image) DST_FILE destination file (cpm:// prefix if in CP/M disk image -h, --help Show this help message and exit. -V, --version Print version information and exit. So we know the destination is the disk image, thus the copy command would be: . &gt; bin/88-dcdd -i altcpm.dsk -f cpm2-simh cpm cp test cpm://test . And now “test” it: . &gt; bin/88-dcdd -i altcpm.dsk -f cpm2-simh cpm cat test Testing, testing! . Disk formats . Various disk file formats are stored in a file, by default located in examples/altair8800/cpm-formats.toml (possible to change location with -F argument). Example disk format for CP/M 2.2 and standard Altair 8” diskette: . # Altair 8\" floppy disks for SIMH CP/M 2.2 # # altcpm.dsk http://cpmarchives.classiccmp.org/cpm/mirrors/www.schorn.ch/cpm/zip/altsw.zip [[format]] id = 'cpm2-simh' sectorSize = 137 sectorSkew = 17 sectorOps = 'altair-floppy-mits' bcInterpretsAsUnused = false dateFormat = 'NOT_USED' [format.dpb] driveSpt = 32 spt = 32 bsh = 3 # or blm = 7 dsm = 254 drm = 255 al0 = 0xFF al1 = 0 ofs = 6 . The diskette format contains two sections: [[format]], which is the main (root) section, and [format.dpb] which is a subsection with disk-parameters-block (DPB). The main section supports the following parameters: . | Name | Default value | Valid values | Description | . | id |   | any string without spaces | Disk format ID | . | sectorSize |   | &gt; 0 | Raw sector size in bytes | . | sectorSkew | 1 | optional; &gt; 0 | Sector skew in bytes. It is not required to provide, if a sector skew table is provided. Used if sectorSkewTable is not provided. | . | sectorSkewTable |   | optional; array of sectors-per-track items (see driveSpt below) | Sector skew table. Used if sectorSkew is not provided. | . | sectorOps | dummy | altair-floppy-mits, altair-floppy-deramp, altair-minidisk-deramp, dummy | Sector operations - how to extract data from raw sector when reading, or how to encode data to raw sector when writing. See below for more information. | . | bcInterpretsAsUnused | false | true/false | BC is a value in a CP/M file record saying number of used bytes in the last data record for the file (false) or number of unused bytes in the record (true). | . | dateFormat | NOT_USED | NOT_USED, NATIVE, NATIVE2, DATE_STAMPER | What type of date format this CP/M filesystem uses. See a description below. | . | sectorsPerTrack0 … sectorsPerTrack15 | 32 | &gt; 0 | Count of sectors in a disk image, on disk A (0) up to P (15) | . | sectorSize0 … sectorSize15 | 137 | &gt; 0 | Size of one sector in bytes on disk A (0) up to P (15) | . | image0 … image15 | N/A | Path to existing file | File name to mount on disk A (0) up to P (15) | . | imageMounted0 … imageMounted15 | false | true/false | Whether disk image is mounted on start | . | interruptVector | 7 | 0 to 7 | Interrupt vector to be used when an interrupt is signalled to CPU | . | interruptsSupported | true | true/false | Whether interrupts are supported (independent on Port 2 runtime settings) | . Sector operations (sectorOps) . In CP/M, data records are usually prefixed and/or appended with additional data like checksum in order to obtain full sector. A CP/M data record has 128 bytes (this is fixed for all CP/M versions). But standard Altair 8” diskette had capacity of 137 bytes, thus still having available space of 9 bytes. On reading, these data/checksums were usually checked before the data is extracted. Various CP/M versions used different sector operations - meaning data records might be placed on various different positions (different offsets) in the raw sector. This section will describe sector operations supported in 88-dcdd CP/M tool. There are more possibilities of sector arrangement, but currently only the following are supported. Dummy . Value: dummy . Record is not manipulated at all. Sector size is respected, so the 128-byte record is placed in the beginning of the sector, padding the rest of available sector space with 0. Altair Floppy: MITS . Value: altair-floppy-mits . This sector ops are used in simh Altair8800 disk images, assuming standard 8” Altair diskette. Here the sector size is hardcoded to 137 bytes, regardless of what is in the settings. The sector is arranged as follows: . | Byte | Description | . | 0 | Track number + 0x80 | . | 1 | Skewed sector = (Sector number * 17) MOD 32 (the sectorSkew from the settings is overriden to 17, driveSpt overriden to 32) | . | 2 | 0 | . | 3 - 131 | Data | . | 132 | 0xFF (“stop byte”) | . | 133 | Data checksum (sum of bytes 3-131) | . | 134 | 0 | . | 135 | 0 | . | 136 | 0 | . Altair Floppy: DeRamp . Value: altair-floppy-deramp . This sector ops is described in DeRamp CP/M BIOS, assuming standard 8” Altair diskette. The sector size is hardcoded to 137 bytes, regardless of what is in the settings. The sector arrangement is different based on a track number. For tracks 0-5, the arrangement is: . | Byte | Description | . | 0 | 0 | . | 1 | 1 | . | 2 - 130 | Data | . | 131 | 0xFF (“stop byte”) | . | 132 | Data checksum (sum of bytes 2-130) | . | 133 | 0 | . | 134 | 0 | . | 135 | 0 | . | 136 | 0 | . For tracks 5-76, the arrangement is: . | Byte | Description | . | 0 | Sector number (not skewed) | . | 1 | 0 | . | 2 | 0 | . | 3 | 0 | . | 4 | 0 | . | 5 | 0 | . | 6 - 134 | Data | . | 135 | 0xFF (“stop byte”) | . | 136 | data checksum (sum of bytes 6-134) | . Altair Minidisk: DeRamp . Value: altair-minidisk-deramp . This sector ops is described in DeRamp CP/M BIOS, assuming 5.25” Altair Minidisk. The sector size is hardcoded to 137 bytes, regardless of what is in the settings. The sector arrangement is different based on a track number. For tracks 0-3, the arrangement is: . | Byte | Description | . | 0 | 0 | . | 1 | 1 | . | 2 - 130 | Data | . | 131 | 0xFF (“stop byte”) | . | 132 | Data checksum (sum of bytes 2-130) | . | 133 | 0 | . | 134 | 0 | . | 135 | 0 | . | 136 | 0 | . For tracks 4-34, the arrangement is: . | Byte | Description | . | 0 | Sector number (not skewed) | . | 1 | 0 | . | 2 | 0 | . | 3 | 0 | . | 4 | 0 | . | 5 | 0 | . | 6 - 134 | Data | . | 135 | 0xFF (“stop byte”) | . | 136 | data checksum (sum of bytes 6-134) | . Date formats (dateFormat) . Date formats are partially described in various manuals: CP/M tools manual, BDOS replacements for CP/M 2 and 3, CP/M 2.2 file format, CP/M 3.1 file format and CP/M 4.1 file format. Naive 1 . Value: NATIVE . Used in CP/M 2.2 in various BDOS replacements: Z80DOS, DOS+, P2DOS and CP/M Plus. Every 4th entry of a directory is considered to be a datestamp record. The structure of the record is as follows: . 21 00 C1 C1 M1 M1 M1 M1 A1 A1 A1 A1 C2 C2 M2 M2 M2 M2 A2 A2 A2 A2 C3 C3 M3 M3 M3 M3 A3 A3 A3 A3 . | C1 = File 1 Create date | M1 = File 1 Modify date/time | A1 = File 1 Access date/time | C2 = File 2 Create date | M2 = File 2 Modify date/time | A2 = File 2 Access date/time | C3 = File 3 Create date | M3 = File 3 Modify date/time | A3 = File 3 Access date/time | . Native 2 . Value: NATIVE2 . This file format is described only on single place (here) and Im not sure if it really existed. If yes, it’s possible to use it. The source claims the format was used in P2DOS or CP/M Plus BDOSes. Every 4th entry of a directory is considered to be a datestamp record. The structure is as follows: . 21 C1 C1 C1 C1 M1 M1 M1 M1 00 00 C2 C2 C2 C2 M2 M2 M2 M2 00 00 C3 C3 C3 C3 M3 M3 M3 M3 00 00 00 . | C1 = File 1 Create date | M1 = File 1 Modify date/time | C2 = File 2 Create date | M2 = File 2 Modify date/time | C3 = File 3 Create date | M3 = File 3 Modify date/time | . The source further says: CP/M Plus further allows optionally to record the access instead of creation date as first time stamp. | 2 bytes (little-endian) days starting with 1 at 01-01-1978 | 1 byte hour in BCD format | 1 byte minute in BCD format | . This is however not supported in this date format. Date stamper . Value: DATE_STAMPER . File date/times are saved in a special file called !!!TIME&amp;.DAT in the CP/M filesystem. The file during CP/M runtime is managed by the special software called DateStamper, which must be installed to BDOS manually ( described here, here and here). 88-dcdd CP/M tool does not support this type of date formats for now. Since the file !!!TIME&amp;.DAT has special requirements (it must be allocated as the first record in directory entry), the setting DATE_STAMPER only makes sure the first directory is ignored during entry allocation when writing files to disk image. ",
    "url": "/documentation/user/altair8800/88-dcdd#experimental-cpm-support",
    "relUrl": "/altair8800/88-dcdd#experimental-cpm-support"
  },"11": {
    "doc": "Device \"88-dcdd\"",
    "title": "Configuration file",
    "content": "The following table shows all the possible file configurations of the plugin: . | Name | Default value | Valid values | Description | . | port1CPU | 0x08 | &gt; 0 and &lt; 256 | Number of Port 1 | . | port2CPU | 0x09 | &gt; 0 and &lt; 256 | Number of Port 2 | . | port3CPU | 0x0A | &gt; 0 and &lt; 256 | Number of Port 3 | . | sectorsPerTrack0 … sectorsPerTrack15 | 32 | &gt; 0 | Count of sectors in a disk image, on disk A (0) up to P (15) | . | sectorSize0 … sectorSize15 | 137 | &gt; 0 | Size of one sector in bytes on disk A (0) up to P (15) | . | image0 … image15 | N/A | Path to existing file | File name to mount on disk A (0) up to P (15) | . | imageMounted0 … imageMounted15 | false | true/false | Whether disk image is mounted on start | . | interruptVector | 7 | 0 to 7 | Interrupt vector to be used when an interrupt is signalled to CPU | . | interruptsSupported | true | true/false | Whether interrupts are supported (independent on Port 2 runtime settings) | . ",
    "url": "/documentation/user/altair8800/88-dcdd#configuration-file",
    "relUrl": "/altair8800/88-dcdd#configuration-file"
  },"12": {
    "doc": "Device \"88-dcdd\"",
    "title": "Device \"88-dcdd\"",
    "content": " ",
    "url": "/documentation/user/altair8800/88-dcdd",
    "relUrl": "/altair8800/88-dcdd"
  },"13": {
    "doc": "Device \"88-sio\"",
    "title": "Serial board 88-SIO",
    "content": "Altair 8800 computer was equipped with serial board called 88-SIO, or 88-2SIO. It was a device which allowed connecting other devices using RS-232 interface. From one side it was attached to CPU on at least two ports (most commonly 0x10 and 0x11 for terminal). The other side ended with one physical port allowing to connect one device. A variant called 88-2SIO allowed to connect two devices at the same time. Usually, attached devices were: . | serial terminal | line printer | paper tape reader/punch | . The following image shows MITS 88-2SIO board. Original manual of MITS 88-SIO serial board can be found here, here or here. ",
    "url": "/documentation/user/altair8800/88-sio#serial-board-88-sio",
    "relUrl": "/altair8800/88-sio#serial-board-88-sio"
  },"14": {
    "doc": "Device \"88-sio\"",
    "title": "Features",
    "content": "The plugin emulates only basic functionality of the board (e.g. it does not emulate transfer rate). It has the following features: . | allows to connect one device | CPU ports are configurable | supports input/output interrupts | has a GUI | . GUI can be seen here: . The window shows attached device, control channel and data buffer. | 1 | Attached device name | . | 2 | Control channel status. Control channel is used to retrieve 88-sio status, or enable/disable interrupts. The displayed value shows the status. For details see the 88-sio manual. | . | 3 | 88-sio has internal buffer used for caching one byte coming from the connected device. If the CPU is not fast enough to read it, the data can be overwritten by new data coming from the device. However, the buffer is not used when sending data to the connected device from CPU. Thus writing data from CPU won’t clear data coming from device. | . | 4 | Clear internal data buffer | . ",
    "url": "/documentation/user/altair8800/88-sio#features",
    "relUrl": "/altair8800/88-sio#features"
  },"15": {
    "doc": "Device \"88-sio\"",
    "title": "Settings",
    "content": "88-sio plugin has a separate settings window with three sections, described below. General settings . The 88-sio plugin support various behaviors of the data transfer, which in reality was the behavior of connected devices and not 88-sio. The reason for supporting these features here is to allow some versatility, regardless of which device is connected. These general settings can be seen in the Settings window: . | 1 | TTY/ANSI mode. On TTY mode, clears input bit 8 (performs AND 0x7F on the byte coming from device). On ANSI mode, clears output bit 8 (performs AND 0x7F on the byte coming from CPU). | . | 2 | Converts input data to upper-case (the byte coming from device). | . | 3 | Maps input/output data Backspace or Delete character to some other character. Possibilities are: Backspace, Delete, Unchanged. | . CPU Ports settings . MITS 88-SIO board in emuStudio is attached to CPU through several ports. In order to support various Altair8800 configurations and thus using wider variety of original software, the device control and data channels are connected to multiple CPU ports. This makes effectively an impression as if there existed multiple 88-sio cards connected to the same device. By default, used CPU port allocation is: . | Control channel (or “status port”): 0x10, 0x14, 0x16, 0x18 (most commonly used: 0x10 for terminal) | Data channel (or “data port”): 0x11, 0x15, 0x17, 0x19 (most commonly used: 0x11 for terminal) | . A side note: there existed various additional boards which supported RS-232 communication besides 88-SIO (or 88-2SIO). These boards were compatible with S100 system board, thus they were usable for original Altair8800 computers as well as its clones. For example: CompuPro Support Board (status port 0x5C, data port 0x5D), CompuPro Interfacer (manual here, consuming 8 CPU ports), Cromemco TU-ART board, IMS C00480 4-line board, IMS I/O board, IMSAI SIO Board, Intersystems 6-SIO, etc. But back to 88-sio. The port numbers allocation can be changed in the Settings window: . | 1 | Attach/detach control channel (“status port”) to/from CPU port | . | 2 | Reset control channel CPU ports to default ones (0x10, 0x14, 0x16, 0x18) | . | 3 | Attach/detach data channel (“data port”) to/from CPU port | . | 4 | Reset data channel CPU ports to default ones (0x11, 0x15, 0x17, 0x19) | . Interrupts settings . 88-sio supports input and output interrupts. If enabled, input interrupt is signalled to CPU when a data becomes available from the connected device. An output interrupt is signalled when data is sent to device. Interrupts support can be generally enabled or disabled, along with interrupt vector configuration in Settings window: . | 1 | Enable/disable interrupt support and set interrupt vectors. If interrupts are disabled, they cannot be enabled in software (see “Port 1” section below). | . | 2 | Reset to default. Interrupts will be supported and interrupt vector is set to 7 (equivalent to calling RST 7 instruction) | . ",
    "url": "/documentation/user/altair8800/88-sio#settings",
    "relUrl": "/altair8800/88-sio#settings"
  },"16": {
    "doc": "Device \"88-sio\"",
    "title": "Configuration file",
    "content": "The following table shows all the possible settings of MITS 88-SIO plugin: . | Name | Default value | Valid values | Description | . | statusPorts | \"0x10, 0x14, 0x16, 0x18\" | &gt; 0 and &lt; 256; X range from 0 upwards | CPU-ports mapped to status port of 88-sio | . | dataPorts | \"0x11, 0x15, 0x17, 0x19\" | &gt; 0 and &lt; 256; X range from 0 upwards | CPU-ports mapped to data port of 88-sio | . | clearInputBit8 | false | true/false | Whether to clear 8th bit of the input written to 88-sio | . | clearOutputBit8 | false | true/false | Whether to clear 8th bit of the output, read from 88-sio | . | inputToUpperCase | false | true/false | Whether to convert the input written to 88-sio into upper-case | . | mapDeleteChar | \"UNCHANGED\" | BACKSPACE, DELETE, UNDERSCORE, UNCHANGED | Maps a “DEL” input key/character to given value. For example, if user presses “DEL” the 88-sio can map it as if user pressed “BACKSPACE”. | . | mapBackspaceChar | \"UNCHANGED\" | BACKSPACE, DELETE, UNDERSCORE, UNCHANGED | Maps a “BACKSPACE” input key/character to given value. For example, if user presses “BACKSPACE” the 88-sio can map it as if user pressed “DEL”. | . | interruptsSupported | true | true/false | Whether interrupts are supported in general. When disabled, they cannot be enabled in software. | . | inputInterruptVector | 7 | 0-7 | Set input interrupt vector. 88-sio will signal an interrupt to the CPU as RST instruction on the input (e.g. a key press) if input interrupts are enabled | . | outputInterruptVector | 7 | 0-7 | Set output interrupt vector. 88-sio will signal an interrupt to the CPU as RST instruction on the output (e.g. on displaying a char) if output interrupts are enabled | . ",
    "url": "/documentation/user/altair8800/88-sio#configuration-file",
    "relUrl": "/altair8800/88-sio#configuration-file"
  },"17": {
    "doc": "Device \"88-sio\"",
    "title": "Programming",
    "content": "In order to show something useful, let’s assume that a terminal LSI ADM-3A is attached to the board. Remember, the board only mediates the communication, it does not interpret any of the sent/received characters. CPU Ports . Whole communication between the board (and attached device) and CPU is controlled by programming the two ports: Status port and Data port. The following table shows the ports and how they are used. | Channel | Address | Input | Output | . | Control (port 1) | 0x10, 0x14, 0x16, 0x18 | Read board status | Used for enabling/disabling input/output interrupts. | . | Data (port 2) | 0x11, 0x15, 0x17, 0x19 | Read data | Write data | . Now, detailed description of the ports follow. Bits are ordered in a byte as follows: . D7 D6 D5 D4 D3 D2 D1 D0 . where D7 is the most significant bit, and D0 the least significant bit. Control channel (port 1) . WRITE: . Controls input/output interrupts enable. | D7 D6 D5 D4 D3 D2 : unused bits | D1 : Enable/disable output interrupts (0 - disable, 1 - enable) | D0 : Enable/disable input interrupts (0 - disable, 1 - enable) | . Interrupts (both input and output) are signalled to the CPU as RST instruction with the interrupt vector value used from the 88-SIO plugin settings (by default, RST 7 is signalled). Input interrupt is triggered when a device connected to 88-SIO sends data to it, so CPU will be notified to read it. Output interrupt is triggered when CPU sends data to 88-SIO, which effectively calls CPU again. READ: . Read status of the device. | D7 : Output device ready. Always 0 in the emulator. | D6 : Not used (always 0). | D5 : Data available (for writing to the attached device). Always 0 in the emulator, meaning that no data is pending to be written. Data are written immediately after OUT instruction. | D4 : Data overflow. Value 1 means a new word of data has been received before the previous word was inputted to the accumulator. In emuStudio, this never happens. | D3 : Framing error. Value 1 means that data bit has no valid stop bit. In emuStudio, this never happens. | D2 : Parity error. Value 1 means that received parity does not agree with selected parity. In emuStudio, this never happens. | D1 : Transmitter buffer empty. Value 1 means that the data word has been received from the attached device and it’s available for reading (from the Data port). | D0 : Input device ready. Value 1 means that the CPU can write data to the SIO (that the board is ready). Always 1 in the emulator. | . Data channel (port 2) . WRITE: . Write data to the attached device. READ: . Read data from the attached device. If the attached device sends asynchronously multiple data, the emulated board stores all in a buffer (queue) with unlimited capacity, so no data should be lost and can be read anytime. Program example . In this section it will be shown a small “How to” program terminal using 88-SIO ports. Print a character on screen . In emuStudio, it is enough to write data to Port 2, e.g.: . mvi a, 'H' out 11h mvi a, 'i' out 11h . Print a string on screen . For writing strings, it is more practical to have a procedure. lxi h, text ; load address of 'text' label to HL call print ; print text hlt ; halt CPU text: db 'Hello, world!',0 ; Procedure for printing text to terminal. ; Input: pair HL must contain the address of the ASCIIZ string print: mov a, m ; load character from HL inx h ; increment HL cpi 0 ; is the character = 0? rz ; yes; quit out 11h ; otherwise; show it jmp print ; and repeat from the beginning . Reading character from keyboard . For reading a character, it is required to read the Port 1 until the character is not ready. Then we can read it from Port 2. ; Procedure will read a single character from terminal ; Input: none ; Output: register A will contain the character. getchar: in 10h ; read Port 1 ani 1 ; is data ready ? jz getchar ; not; try again in 11h ; yes; read it (into A register) ret . Reading text from keyboard . Now follows an example, which will read a whole line of characters into memory starting at address in DE pair. The procedure will interpret some control keys, like: backspace and ENTER keys. lxi h, text ; load address of 'text' label to HL xchg ; DE &lt;-&gt; HL call getline ; read line from the keyboard into DE lxi h, text ; load 'text' address again call print ; print the text on screen hlt ; halt CPU text: ds 30 ; here will be stored the read text ;Procedure for reading a text from keyboard. ;Input: DE = address, where the text should be put after reading ; C = is used internally getline: mvi c, 0 ; register C will be used as a counter of ; read characters next_char: in 10h ; read Port 1: status ani 1 ; is the char ready for reading? jz next_char ; not; try again in 11h ; yes; read it to A register ; now ENTER and Backspace will be interpreted cpi 13 ; ENTER? jz getline_ret ; yes; it means end of input cpi 8 ; Backspace ? jnz save_char ; if not; store the character ; Backspace interpretation mov a, c ; A &lt;- number of read characters cpi 0 ; are we at the beginning? jz next_char ; yes; ignore the backspace dcx d ; not; decrement DE dcr c ; decrement count of read characters mvi a,8 ; \"show\" the backspace (terminal will ; interpret this by moving the cursor ; to the left by 1 char) out 11h mvi a, 32 ; \"clear\" the current character on screen ; by a space character (ASCII code 32) out 11h mvi a,8 ; and move the cursor back again out 11h jmp next_char ; jump to next char save_char: ; stores a character into memory at DE out 11h ; show the character in A register stax d ; store it at address DE inx d ; increment DE inr c ; increment number of read characters jmp next_char ; jump to next char getline_ret: ; end of input ; ENTER will be stored as CRLF mvi a,13 ; CR (Carriage Return) stax d ; store the char inx d ; increment DE mvi a, 10 ; LF (Line Feed) stax d ; store the char inx d ; increment DE mvi a, 0 ; char 0 (End-Of-Input) stax d ; store the char ret ; return . Get notified when a key is pressed . In this example, an interrupt is signalled when user presses a key on keyboard. ; Tests signalling interrupts on input mvi a, 1 ; 88-SIO: input interrupts enable out 0x10 ei ; enable CPU interrupts loop: jmp loop ; do this forever (or until...) ; interrupt handler org 0x38 ; assuming interrupt vector is set to 7 in 0x11 ; read char from 88-SIO (and ignore it) lxi h, key ; load address of 'key' label to HL call print ; print \"key pressed\" ret ; return from the interrupt key: db 'Key pressed!',10,13,0 ; Procedure for printing text to terminal. ; Input: pair HL must contain the address of the ASCIIZ string print: mov a, m ; load character from HL inx h ; increment HL cpi 0 ; is the character = 0? rz ; yes; quit out 11h ; otherwise; show it jmp print ; and repeat from the beginning . ",
    "url": "/documentation/user/altair8800/88-sio#programming",
    "relUrl": "/altair8800/88-sio#programming"
  },"18": {
    "doc": "Device \"88-sio\"",
    "title": "Device \"88-sio\"",
    "content": " ",
    "url": "/documentation/user/altair8800/88-sio",
    "relUrl": "/altair8800/88-sio"
  },"19": {
    "doc": "Abstract tape",
    "title": "Abstract tape",
    "content": "Abstract tapes, in general, are used in various abstract machines. Probably the best known are Turing machine, RAM machine, and RASP machine. The plugin of the abstract tape for emuStudio is called abstract-tape. There are several properties which an abstract tape might have: . | Bounded, one-side bounded or unbounded | Random access (allowing to move the head in both directions) or linear access (allowing to move head only in one direction) | Specific or any cell content type (e.g. cells are integers, or strings, or can be any value?) | Read-only, or read-write cells | Purpose of the tape (title) | . This plugin allows us to set up such properties, but those are set up by the virtual computer which uses it, not by the user. For more information, please see the programming section. Currently, there are just two virtual computers utilizing this plugin: . | RAM machine | RASP machine | . After emuStudio is run, RAM CPU (or RASP CPU) sets up properties for all used tapes. So the tape “purpose” and behavior is set in run time. ",
    "url": "/documentation/user/ram/abstract-tape#abstract-tape",
    "relUrl": "/ram/abstract-tape#abstract-tape"
  },"20": {
    "doc": "Abstract tape",
    "title": "Graphical user interface (GUI)",
    "content": "The graphical user interface of the abstract tape is very simple. To open it, select the tape in the peripheral devices list in the Emulator panel. Then, click on the “Show” button. The symbol, highlighted with the red color is the current head position, in this case. To manipulate with particular symbols, one must click on the symbol, which appears selected (blue background in this case), as in the following image: . | 1 | If the tape allows it, one can add a new symbol before the selected one in the tape. In the image, the tape does not allow it. | . | 2 | The tape content area. Usually, each row consists of the symbol “index” or position within the tape, followed by the symbol itself. | . | 3 | If the tape allows it, one can add a new symbol after the last one in the tape. In the image, the tape allows it. | . | 4 | Removes the selected symbol from the tape. | . | 5 | Edits the tape symbol. The symbol must be selected. | . | 6 | Clears the tape content | . ",
    "url": "/documentation/user/ram/abstract-tape#graphical-user-interface-gui",
    "relUrl": "/ram/abstract-tape#graphical-user-interface-gui"
  },"21": {
    "doc": "Abstract tape",
    "title": "Settings",
    "content": "The tape allows us to edit some settings from the graphical mode; to open the settings window click on the “Settings” button below the peripheral devices list in the Emulator panel. The window can be seen in the following image: . | 1 | Do not allow the tape to fall behind another window | . | 2 | Show the tape right after emuStudio start | . ",
    "url": "/documentation/user/ram/abstract-tape#settings",
    "relUrl": "/ram/abstract-tape#settings"
  },"22": {
    "doc": "Abstract tape",
    "title": "Configuration file",
    "content": "The following table shows all the possible settings of Abstract tape plugin: . | Name | Default value | Valid values | Description | . | showAtStartup | false | true, false | If the tape should be shown automatically after emuStudio is started | . | alwaysOnTop | false | true, false | Whether the tape GUI should not allow to fall behind other windows | . ",
    "url": "/documentation/user/ram/abstract-tape#configuration-file",
    "relUrl": "/ram/abstract-tape#configuration-file"
  },"23": {
    "doc": "Abstract tape",
    "title": "Automatic emulation",
    "content": "The abstract tape supports automatic emulation. It means, that every change to it is being written to a file. The file name is devised from the title of the tape, by the following algorithm: . | At first, all spaces in the title are replaced with an underscore (_) | Then, all invalid characters are replaced with an underscore | Every character is converted to lower-case | Finally, the .out extension is added at the end. | . Invalid characters are the following: *, ., #, %, &amp;, +, !, ~, /, ?, &lt;, &gt;, ,, |, {, } , [, ], \", ```, = . ",
    "url": "/documentation/user/ram/abstract-tape#automatic-emulation",
    "relUrl": "/ram/abstract-tape#automatic-emulation"
  },"24": {
    "doc": "Abstract tape",
    "title": "Using abstract tapes in your emulator",
    "content": "NOTE: This section is for developers of emulators. The Abstract tape plugin can be used in various computers. Besides standard operations which are provided by net.emustudio.emulib.plugins.device.DeviceContext interface, it provides custom context API. Usually, the tapes are used by CPU plugins, but it is of course possible to use it in any other plugin. You can obtain the context during the Plugin.initialize() method of the plugin root class. The context is named net.emustudio.plugins.device.abstracttape.api.AbstractTapeContext: . @PluginRoot(...) public class YourPlugin { ... public void initialize() throws PluginInitializationException { AbstractTapeContext tape = applicationApi.getContextPool().getDeviceContext(pluginID, AbstractTapeContext.class); ... } ... } . The tape context interface has the following content: . package net.emustudio.plugins.device.abstracttape.api; import net.emustudio.emulib.plugins.annotations.PluginContext; import net.emustudio.emulib.plugins.device.DeviceContext; /** * Public API of the abstract tape. * &lt;p&gt; * The tape head can move to the left, or to the right. If a tape is left-bounded, it cannot move to the left * beyond the first symbol. * &lt;p&gt; * Symbols are indexed from 0. * A CPU must set up the tape (set the title, etc.). */ @ThreadSafe @PluginContext public interface AbstractTapeContext extends DeviceContext&lt;TapeSymbol&gt; { /** * Clear content of the tape. */ void clear(); /** * Accept only specific tape symbol types. * &lt;p&gt; * If the tape encounters symbol of unsupported type, it will throw on reading. Unsupported inputs provided by user * will be disallowed. * * @param types accepted types */ void setAcceptTypes(TapeSymbol.Type... types); /** * Gets accepted tape symbol types. * * @return accepted tape symbol types */ Set&lt;TapeSymbol.Type&gt; getAcceptedTypes(); /** * Determine if the tape is left-bounded. * * @return true - left-bounded, false - unbounded. */ boolean isLeftBounded(); /** * Set this tape to left-bounded or unbounded. * * @param bounded true if the tape should be left-bounded, * false if unbounded. */ void setLeftBounded(boolean bounded); /** * Move the tape one symbol to the left. * &lt;p&gt; * If the tape is left-bounded and the old position is 0, tape won't move. Otherwise the tape * will expand to the left - add new empty symbol to position 0 and shift the rest of the content to the right. * * @return true if the tape has been moved; false otherwise (if it is left-bounded and the position is 0). */ boolean moveLeft(); /** * Move tape to the right. If the tape is too short, it is expanded to the right (added new empty symbol). */ void moveRight(); /** * Allow or disallow to edit the tape. * &lt;p&gt; * If the tape is editable, the user (in GUI) can add, modify or remove symbols from the tape. * Otherwise, it is driven only by the CPU. * * @param editable true if yes, false if not. */ void setEditable(boolean editable); /** * Get symbol at index. * * @param index 0-based index; max value = Math.max(0, getSize() - 1) * @return symbol at index */ Map.Entry&lt;Integer, TapeSymbol&gt; getSymbolAtIndex(int index); /** * Get symbol at the specified position. * * @param position position in the tape, starting from 0 * @return symbol at given position; or Optional.empty() if the position is out of bounds */ Optional&lt;TapeSymbol&gt; getSymbolAt(int position); /** * Set symbol at the specified position. * * @param position position in the tape, starting from 0 * @param symbol symbol value * @throws IllegalArgumentException if the symbol type is not among accepted ones, or position is &lt; 0 */ void setSymbolAt(int position, TapeSymbol symbol); /** * Remove symbol at given position * Head position is preserved. * * @param position symbol position in the tape * @throws IllegalArgumentException if position &lt; 0 */ void removeSymbolAt(int position); /** * Sets whether the symbol at which the head is pointing should be \"highlighted\" in GUI. * * @param highlight true if yes; false otherwise. */ void setHighlightHeadPosition(boolean highlight); /** * Seths whether the tape should be cleared at emulation reset. * * @param clear true if yes; false otherwise. */ void setClearAtReset(boolean clear); /** * Set title (purpose) of the tape. * * @param title title of the tape */ void setTitle(String title); /** * Determines if the symbol positions should be displayed in GUI. * * @return true if yes; false otherwise */ boolean getShowPositions(); /** * Set whether the symbol positions should be displayed in GUI. * * @param showPositions true if yes; false otherwise. */ void setShowPositions(boolean showPositions); /** * Get the tape head position. * * @return current position in the tape; starts from 0 */ int getHeadPosition(); /** * Get the size of the tape * * @return tape size */ int getSize(); /** * Determine if the tape is empty. * * @return true if the tape is empty; false otherwise. */ boolean isEmpty(); /** * {@inheritDoc} * * @throws IllegalArgumentException if the symbol type is not among accepted ones */ void writeData(TapeSymbol value); . ",
    "url": "/documentation/user/ram/abstract-tape#using-abstract-tapes-in-your-emulator",
    "relUrl": "/ram/abstract-tape#using-abstract-tapes-in-your-emulator"
  },"25": {
    "doc": "Abstract tape",
    "title": "Abstract tape",
    "content": " ",
    "url": "/documentation/user/ram/abstract-tape",
    "relUrl": "/ram/abstract-tape"
  },"26": {
    "doc": "Device \"adm3a-terminal\"",
    "title": "Terminal LSI ADM-3A",
    "content": "Emulation of famous terminal from Lear Siegler, Inc. - ADM-3A. It had a nickname ‘Dumb Terminal’. In the time (1974), due to its cheapness and speed capabilities required in that time, it became de facto standard in the industry. Often it was used in connection with MITS Altair 8800 computer, so the decision of which terminal to emulate was clear. Maintenance manual can be downloaded at this link, operator’s manual here. (Image borrowed from Wikipedia) . ",
    "url": "/documentation/user/altair8800/adm3a-terminal#terminal-lsi-adm-3a",
    "relUrl": "/altair8800/adm3a-terminal#terminal-lsi-adm-3a"
  },"27": {
    "doc": "Device \"adm3a-terminal\"",
    "title": "Display",
    "content": "Terminal could display 128 ASCII characters (upper-case and lower-case letters, punctuation and numbers). Original ADM-3 could display only 64 (only capital-letters and some other). For saving very expensive RAM the terminal offered size 12 rows x 80 columns, with optional extension to 24 rows x 80 columns. The size used in the emulator is hardcoded to 80 columns x 24 rows. Besides, the emulator uses “replica” of the original ADM-3A font with anti-aliasing support, double-buffering and display frequency 60Hz. GUI can be seen here: . | 1 | Clear screen | . | 2 | Roll one line down | . ",
    "url": "/documentation/user/altair8800/adm3a-terminal#display",
    "relUrl": "/altair8800/adm3a-terminal#display"
  },"28": {
    "doc": "Device \"adm3a-terminal\"",
    "title": "Keyboard",
    "content": "Terminal could generate 128 ASCII characters (upper-case, lower-case, punctuation and numbers). Besides, it could generate special control characters which affected current position of the cursor and were not sent to CPU. Emulated device allows to generate almost everything what you can get from your host keyboard. It is only the font which characters it can display. Original font contains only 255 characters, modern font contains all unicode characters. The terminal can capture control codes (holding CTRL plus some key), and special control codes (ESC + '=' + [X] + [Y]). The special code (ESC=XY) sets the new cursor position, where [X] is a key translated to X position and [Y] a key translated into Y position of a cursor. The following subsection lists all possible control and special control key combinations. Control codes . The following table shows control codes (CTRL plus some key combinations). The table can be found in original manuals. The emulator is following it. | Code | ASCII mnemonic | Function in ADM-3A | . | CTRL+@ | NUL |   | . | CTRL+A | SOH |   | . | CTRL+B | STX |   | . | CTRL+C | ETX |   | . | CTRL+D | EOT |   | . | CTRL+E | ENQ | Initiates ID message with automatic “Answer Back” option. | . | CTRL+F | ACK |   | . | CTRL+G | BEL | Sounds audible beep in ADM-3A (not in emulator yet :( ) | . | CTRL+H | BS | Backspace | . | CTRL+I | HT |   | . | CTRL+J | LF | Line feed | . | CTRL+K | VT | Upline | . | CTRL+L | FF | Forward space | . | CTRL+M | CR | Return | . | CTRL+N | SO | Unlock keyboard | . | CTRL+O | SI | Lock keyboard | . | CTRL+P | OLE |   | . | CTRL+Q | DCI |   | . | CTRL+R | DC2 |   | . | CTRL+S | DC3 |   | . | CTRL+T | DC4 |   | . | CTRL+U | NAK |   | . | CTRL+V | SYN |   | . | CTRL+W | ETB |   | . | CTRL+X | CAN |   | . | CTRL+Y | EM |   | . | CTRL+Z | SUB | Clear screen | . | CTRL+[ | ESC | Initiate load cursor | . | CTRL+x | FS |   | . | CTRL+] | GS |   | . | CTRL+^ | RS | Home cursor | . Absolute cursor position from the keyboard . Terminal allows to set the absolute cursor position, when in “Cursor control Mode” or using “load cursor” operation. Emulated terminal does not support the “Cursor control Mode”, but “load cursor” is supported. The “load cursor” operation can be activated by pressing ESC key followed by = key. Then the terminal expects another two key presses, one representing X, and the other one the Y position of the cursor. X and Y coordinates are translated from the key presses. The following table shows the key-to-coordinate translation table. | Key | Number | Key | Number | Key | Number | . | ' ' (space) | 0 | ; | 27 | V | 54 | . | ! | 1 | &lt; | 28 | W | 55 | . | \" | 2 | = | 29 | X | 56 | . | # | 3 | &gt; | 30 | Y | 57 | . | $ | 4 | ? | 31 | Z | 58 | . | % | 5 | @ | 32 | [ | 59 | . | &amp; | 6 | A | 33 | \\ | 60 | . | ' | 7 | B | 34 | ] | 61 | . | ( | 8 | C | 35 | ^ | 62 | . | ) | 9 | D | 36 | _ | 63 | . | * | 10 | E | 37 | ` (backtick) | 64 | . | + | 11 | F | 38 | a | 65 | . | , | 12 | G | 39 | b | 66 | . | - | 13 | H | 40 | c | 67 | . | . | 14 | I | 41 | d | 68 | . | / | 15 | J | 42 | e | 69 | . | 0 | 16 | K | 43 | f | 70 | . | 1 | 17 | L | 44 | g | 71 | . | 2 | 18 | M | 45 | h | 72 | . | 3 | 19 | N | 46 | i | 73 | . | 4 | 20 | O | 47 | j | 74 | . | 5 | 21 | P | 48 | k | 75 | . | 6 | 22 | Q | 49 | l | 76 | . | 7 | 23 | R | 50 | m | 77 | . | 8 | 24 | S | 51 | n | 78 | . | 9 | 25 | T | 52 | o | 79 | . | : | 26 | U | 53 |   |   | . ",
    "url": "/documentation/user/altair8800/adm3a-terminal#keyboard",
    "relUrl": "/altair8800/adm3a-terminal#keyboard"
  },"29": {
    "doc": "Device \"adm3a-terminal\"",
    "title": "Drawing message boxes",
    "content": "Using some ASCII characters from code page 437, it is possible to draw various kinds of forms, for example: . message: db 201, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 187, 10, 13 db 186, \"Hello world!\", 186, 10, 13 db 200, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 188 db 0 . shown as: . This is supported only by the “original” font, even though these symbols were not really present in original terminal. ",
    "url": "/documentation/user/altair8800/adm3a-terminal#drawing-message-boxes",
    "relUrl": "/altair8800/adm3a-terminal#drawing-message-boxes"
  },"30": {
    "doc": "Device \"adm3a-terminal\"",
    "title": "Terminal Settings",
    "content": "It is possible to configure the terminal either from GUI or manually modifying configuration settings. Modification of settings requires restarting emuStudio. The “settings” window is shown in the following image: . | 1 | File name used for reading input (when redirected - in “no GUI” mode) | . | 2 | File name used for writing output (when redirected - in “no GUI” mode) | . | 3 | In automatic mode, how long the terminal should wait until it reads next input character from the file (in milliseconds) | . | 4 | Set terminal font. Original font has reduced character range to 256 characters; modern one supports full unicode. | . | 5 | Whether every keystroke will also cause to display it. Programs don’t always “echo” the characters back to the screen. | . | 6 | Whether terminal GUI should be always-on-top of other windows | . | 7 | Save settings and dispose the dialog | . Terminal behaves differently when emuStudio is run in automatic with “no GUI” mode. At that moment, input is redirected to be read from a file (instead of keyboard), and also output is redirected to be written to a file. File names are configurable in the computer config file (and they are not allowed to point to the same file). Using redirection in GUI mode (whether in automatic mode or not) is not possible. ",
    "url": "/documentation/user/altair8800/adm3a-terminal#terminal-settings",
    "relUrl": "/altair8800/adm3a-terminal#terminal-settings"
  },"31": {
    "doc": "Device \"adm3a-terminal\"",
    "title": "Configuration file",
    "content": "The following table shows all the possible settings of ADM-3A plugin: . | Name | Default value | Valid values | Description | . | inputFileName | adm3A-terminal.in | Path to existing file | File for reading input (when redirected) | . | outputFileName | adm3A-terminal.out | Path to existing file | File for writing output (when redirected) | . | inputReadDelay | 0 | &gt;= 0 | How long the terminal should wait until it reads next input character from the file (in milliseconds) | . | halfDuplex | false | true / false | Whether every keystroke will also cause to display it | . | alwaysOnTop | false | true / false | Whether terminal GUI should be always-on-top of other windows | . | deviceIndex | 0 | &gt;= 0 | Index of connected device, if this terminal is connected to multiple devices in the schema (nonstandard, advanced use) | . | font | original | original, modern | Terminal font | . ",
    "url": "/documentation/user/altair8800/adm3a-terminal#configuration-file",
    "relUrl": "/altair8800/adm3a-terminal#configuration-file"
  },"32": {
    "doc": "Device \"adm3a-terminal\"",
    "title": "Device \"adm3a-terminal\"",
    "content": " ",
    "url": "/documentation/user/altair8800/adm3a-terminal",
    "relUrl": "/altair8800/adm3a-terminal"
  },"33": {
    "doc": "Assembler \"as-8080\"",
    "title": "Assembler “as-8080”",
    "content": "emuStudio version of assembler for Intel 8080 CPU is very similar to Intel assembler, but has some little differences. Features include: . | macros (unlimited nesting) | include files support | data definition | relative addressing using labels | literals and expressions in various radixes (bin, dec, hex, oct) | compiler output is in Intel HEX format | . The features are very similar to those in “as-z80” assembler. ",
    "url": "/documentation/user/altair8800/as-8080#assembler-as-8080",
    "relUrl": "/altair8800/as-8080#assembler-as-8080"
  },"34": {
    "doc": "Assembler \"as-8080\"",
    "title": "Running from command line",
    "content": "The assembler is provided as part of emuStudio, and usually it is run from GUI. But it can be run also from the command line, as follows: . | on Linux: &gt; bin/as-8080 [--output output_file.hex] [source_file.asm] . | on Windows: &gt; bin\\as-8080.bat [--output output_file.hex] [source_file.asm] . | . All command line options include: . Options: --output, -o file: name of the output file --version, -v : print version --help, -h : this help . ",
    "url": "/documentation/user/altair8800/as-8080#running-from-command-line",
    "relUrl": "/altair8800/as-8080#running-from-command-line"
  },"35": {
    "doc": "Assembler \"as-8080\"",
    "title": "Lexical symbols",
    "content": "The assembler does not differentiate between upper and lower case (it is case-insensitive). The token/symbol types are as follows: . | Type | Description | . | Keywords | instruction names; preprocessor directives (org, equ, set, macro, endm, include, if, endif); data definitions (db, dw, ds); CPU registers | . | Identifiers | ([a-zA-Z_\\?@])[a-zA-Z_\\?@0-9]* except keywords | . | Labels |   | . | Constants | strings or integers | . | Operators | +, -, *, /, =, mod, and, or, not, xor, shl, shr | . | Comments | semi-colon (;) with text after it until the end of the line | . Constants . Numeric constants can be only integers, encoded with one of several number radixes. The possible formats are written using regexes: . | binary numbers: [0-1]+[bB] | decimal numbers: [0-9]+[dD]? | octal numbers: [0-7]+[oOqQ] | hexadecimal numbers: [0-9][0-9a-fA-F]*[hH] or 0[xX][0-9a-fA-F]+ | . Characters or strings must be enclosed in single-quotes, e,g,: MVI E, '*' . Identifiers . Identifiers must fit to the following regex: ([a-zA-Z_\\?@])[a-zA-Z_\\?@0-9]*. It means, that it has to start with a letter a-z (or A-Z) or the at-sign (@). Then, it can be followed by letters, at-sign, or numbers. However, they must not equal to any keyword. Also, if an identifier is used for one kind of definition (label, variable, constant, or macro), it cannot be used for definition of another kind. For example, the following code is not valid . label: label set 1 . At first the identified label is used for definition of a label, and on the second row the same identifier is used for definition of a variable. This is not allowed and will produce an error. ",
    "url": "/documentation/user/altair8800/as-8080#lexical-symbols",
    "relUrl": "/altair8800/as-8080#lexical-symbols"
  },"36": {
    "doc": "Assembler \"as-8080\"",
    "title": "Instructions syntax",
    "content": "The program is basically a sequence of instructions. The instructions are separated by a new line. The instruction have optional and mandatory parts, e.g.: . LABEL: CODE OPERANDS ; COMMENT . | Syntax part | Required | Notes | . | LABEL | Optional | Identifier of the memory position, followed by a colon (:). | . |   | It can be used as forward or backward reference in instructions |   | . |   | which expect memory address (or 16 bit number). |   | . | CODE | Mandatory | Instruction name. | . | OPERANDS | It depends | If applicable, a comma-separated (,) operands of the instruction. | . | COMMENT | Optional | semi-colonm (;) followed by any text until the end of the line. | . Fields CODE and OPERANDS must be separated by at least one space. For example: . HERE: MVI C, 0 ; Put 0 into C register DB 3Ah ; Data constant of size 1 byte LOOP: JMP LOOP ; Infinite loop . Labels are optional. Instructions and pseudo-instructions and register names are reserved for assembler and cannot be used as labels. Also, there cannot be more definitions of the same label. Operands must be separated with comma (,). There exist several operand types, which represent so-called “address modes”. Allowed address modes depend on the instruction. The possibilities are: . | Implicit addressing: instructions do not have operands. They are implicit. | Register addressing: operands are registers. 8-bit general-purpose register names are: A, B, C, D, E, H , L. Stack pointer is defined as SP, and program status word (used by push / pop instructions) as PSW. When register pairs should be used in 16-bit instructions, the same register names are used. For example, DCX D which decrements pair DE. | Register indirect addressing: for the memory value specified by address in HL pair is used special register called M, for example: MOV A, M. | Immediate addressing: operand is the 8-bit constant. It can be also one character, enclosed in single-quotes. | Direct addressing: operand is either 8-bit or 16-bit constant, which is understood as the memory location (address). For example: SHLD 1234h. | Modified page zero: operand is 3-bit value (0-7). It represents a “index”, which is multiplied by constant 8, resulting in final memory address. Used in RST instruction. | . Immediate data or addresses can be defined in various ways: . | Integer constant | Integer constant as a result of evaluation of some expression (e.g. 2 SHL 4, or 2 + 2) | Current address - denoted by special variable $. For example, instruction JMP $+6 denotes a jump by 6-bytes further from the current address. | Character constants, enclosed in single-quotes (e.g. MVI A, '*') | Labels. For example: JMP THERE will jump to the label THERE. | Variables. For example: | . VALUE SET 'A' MVI A, VALUE . ",
    "url": "/documentation/user/altair8800/as-8080#instructions-syntax",
    "relUrl": "/altair8800/as-8080#instructions-syntax"
  },"37": {
    "doc": "Assembler \"as-8080\"",
    "title": "Expressions",
    "content": "An expression is a combination of the data constants and operators. Expressions are evaluated in compile-time. Given any two expressions, they must not be defined circularly. Expressions can be used anywhere a constant is expected. There exist several operators, such as: . | Expression | Notes | . | + | Addition. Example: DB 2 + 2; evaluates to DB 4 | . | - | Subtraction. Example: DW $ - 2; evaluates to the current compilation address minus 2. | . | * | Multiply. | . | / | Integer division. | . | = | Comparison for equality. Returns 1 if operands equal, 0 otherwise. Example: DB 2 = 2; evaluates to DB 1. | . | mod | Remainder after integer division. Example DB 4 mod 3; evaluates to DB 1. | . | and | Logical and. | . | or | Logical or. | . | xor | Logical xor. | . | not | Logical not. | . | shl | Shift left by 1 bit. Example: DB 1 SHL 3; evaluates to DB 8 | . | shr | Shift right by 1 bit. | . Operator priorities are as follows: . | Priority | Operator | Type | . | 1 | ( ) | Unary | . | 2 | *, /, mod, shl, shr | Binary | . | 3 | +, - | Unary and binary | . | 4 | = | Binary | . | 5 | not | Unary | . | 6 | and | Binary | . | 7 | or, xor | Binary | . All operators work with their arguments as if they were 16-bit. Their results are always 16-bit numbers. If there is expected an 8-bit number, the result is automatically “cut” using operation result AND 0FFh. This may be unwanted behavior and might lead to bugs, but it is often useful so the programmer must ensure the correctness. ",
    "url": "/documentation/user/altair8800/as-8080#expressions",
    "relUrl": "/altair8800/as-8080#expressions"
  },"38": {
    "doc": "Assembler \"as-8080\"",
    "title": "Defining data",
    "content": "Data can be defined using special pseudo-instructions. These accept constants. Negative integers are using two’s complement. The following table describes all possible data definition pseudo-instructions: . | Expression | Notes | . | DB [expression] | Define byte. The [expression] must be of size 1 byte. Using this pseudo-instruction, a string can be defined, enclosed in single quotes. For example: DB 'Hello, world!' is equal to DB 'H', DB 'e', etc. on separate lines. | . | DW [expression] | Define word. The [expression] must be max. of size 2 bytes. Data are stored using little endian. | . | DS [expression] | Define storage. The [expression] represents number of bytes which should be “reserved”. The reserved space will not be modified in memory. It is similar to “skipping” particular number of bytes. | . Examples . HERE: DB 0A3H ; A3 W0RD1: DB 5*2, 2FH-0AH ; 0A25 W0RD2: DB 5ABCH SHR 8 ; 5A STR: DB 'STRINGSpl' ; 535452494E472031 MINUS: DB -03H ; FD ADD1: dw COMP ; 1C3B (assume COMP is 3B1CH) ADD2: dw FILL ; B43E (assume FILL is 3EB4H) ADD3: dw 3C01H, 3CAEH ; 013CAE3C . ",
    "url": "/documentation/user/altair8800/as-8080#defining-data",
    "relUrl": "/altair8800/as-8080#defining-data"
  },"39": {
    "doc": "Assembler \"as-8080\"",
    "title": "Including other source files",
    "content": "It is both useful and good practice to write modular programs. According to the DRY principle, the repetitive parts of the program should be refactored out into functions or modules. Functionally similar groups of these functions or modules can be put into a library, reusable in other programs. The pseudo-instruction include exists for the purpose of including already written source code into the current program. The pseudo-instruction is defined as follows: . INCLUDE '[filename]' . where [filename] is a relative or absolute path to the file which will be included, enclosed in single-quotes. The file can include other files, but there must not be defined circular includes (the compiler will complain). The current address (denoted by $ variable) below the include pseudo-instruction will be updated by the binary size of the included file. The namespace of the current program and the included file is shared. It means that labels or variables with the same name in the current program and the included file are prohibited. Include file “sees” everything in the current program as it was its part. Example . Let a.asm contains: . mvi b, 80h . Let b.asm contains: . include 'a.asm' . Then compiling b.asm will result in: . 06 80 ; mvi b, 80h . ",
    "url": "/documentation/user/altair8800/as-8080#including-other-source-files",
    "relUrl": "/altair8800/as-8080#including-other-source-files"
  },"40": {
    "doc": "Assembler \"as-8080\"",
    "title": "Origin address",
    "content": "Syntax: ORG [expression] . Sets the value to the $ variable. It means that from now on, the following instructions will be placed at the address given by the [expression]. Effectively, it is the same as using DS pseudo-instruction, but instead of defining the number of skipped bytes, we define concrete memory location (address). The following two code snippets are equal: . | Address | Block 1 | Block 2 | Opcode | . | 2C00 | MOV A,C | MOV A,C | 79 | . | 2C01 | JMP NEXT | JMP NEXT | C3 10 2C | . | 2C04 | DS 12 | ORG $+12 |   | . | 2C10 | NEXT: XRA A | NEXT: XRA A | AF | . ",
    "url": "/documentation/user/altair8800/as-8080#origin-address",
    "relUrl": "/altair8800/as-8080#origin-address"
  },"41": {
    "doc": "Assembler \"as-8080\"",
    "title": "Equate",
    "content": "Syntax: [identifier] EQU [expression] . Define a constant. The [identifier] is a mandatory name of the constant. [expression] is the 16-bit expression. The pseudo-instruction will define a constant - assign a name to the given expression. The name of the constant then can be used anywhere where the constant is expected and the compiler will replace it with the expression. It is not possible to redefine a constant. ",
    "url": "/documentation/user/altair8800/as-8080#equate",
    "relUrl": "/altair8800/as-8080#equate"
  },"42": {
    "doc": "Assembler \"as-8080\"",
    "title": "Variables",
    "content": "Syntax: [identifier] SET [expression] . Define or re-define a variable. The [identifier] is a mandatory name of the constant. [expression] is the 16-bit expression. The pseudo-instruction will define a variable - assign a name to the given expression. Then, the name of the variable can be used anywhere where the constant is expected. It is possible to redefine a variable. This effectively means to reassign a new expression to the same name and forgetting the old one. The reassignment is aware of locality, i.e. before the operation, the old value will be used, and after the operation, the new value will be used. ",
    "url": "/documentation/user/altair8800/as-8080#variables",
    "relUrl": "/altair8800/as-8080#variables"
  },"43": {
    "doc": "Assembler \"as-8080\"",
    "title": "Conditional assembly",
    "content": "Syntax: . if [expression] i n s t r u c t i o n s endif . At first, the compiler evaluates the [expression]. If the result is 0, statements between if and endif are ignored. Labels defined inside the if block occupy the namespace even if the if-expression evaluates to 0. Hence, the following code yields an error (Label already defined): . if 0 label1: stax b endif label1: hlt . Evaluation of the expression in the if statement must not use forward references. For example, the following code is not valid (will produce an error): . if variable stax b endif variable set $ . In this case, variable is about to be set to current address, which would be 0 if the if statement evaluates to false. Otherwise, it evaluates to 1. Both options would be semantically correct, and the compiler cannot know what was the programmer’s intention. ",
    "url": "/documentation/user/altair8800/as-8080#conditional-assembly",
    "relUrl": "/altair8800/as-8080#conditional-assembly"
  },"44": {
    "doc": "Assembler \"as-8080\"",
    "title": "Defining and using macros",
    "content": "Syntax: . [identifier] macro [operands] i n s t r u c t i o n s endm . The [identifier] is a mandatory name of the macro. The [operands] part is a list of identifiers, separated by commas (,). Inside the macro, operands act as constants. If the macro does not use any operands, this part can be omitted. The namespace of the operand identifiers is macro-local, ie. the operand names will not be visible outside the macro. Also, the operand names can hide variables, labels, or constants defined in the outer scope. The macros can be understood as “templates” which will be expanded in the place where they are “called”. The call syntax is as follows: . [macro name] [arguments] . where [macro name] is the macro name as defined above. Then, [arguments] are comma-separated expressions, in the order as the original operands are defined. The number of arguments must be the same as the number of macro operands. The macro can be defined anywhere in the program, even in any included file. Also, it does not matter in which place is called - above or below the macro definition. Examples . SHV MACRO LOOP: RRC ; Right rotate with carry ANI 7FH ; Clear MSB of accumulator DCR D ; Decrement rotation counter - register D JNZ LOOP ; Jump to next rotation ENDM . The macro SHV can be used as follows: . LDA TEMP MVI D,3 ; 3 rotations SHV STA TEMP . Or another definition: . SHV MACRO AMT MVI D,AMT ; Number of rotations LOOP: RRC ANI 7FH DCR D JNZ LOOP ENDM . And usage: . LDA TEMP SHV 5 . Which has the same effect as the previous example. ",
    "url": "/documentation/user/altair8800/as-8080#defining-and-using-macros",
    "relUrl": "/altair8800/as-8080#defining-and-using-macros"
  },"45": {
    "doc": "Assembler \"as-8080\"",
    "title": "END psudo-instruction",
    "content": "On encountering END pseudo-instruction, the compiler will allow only comments below this pseudo-instruction. It’s a marker of “program end”. The following example won’t compile: . MVI A, 0 END HLT ; no code allowed, just comments! . ",
    "url": "/documentation/user/altair8800/as-8080#end-psudo-instruction",
    "relUrl": "/altair8800/as-8080#end-psudo-instruction"
  },"46": {
    "doc": "Assembler \"as-8080\"",
    "title": "Assembler \"as-8080\"",
    "content": " ",
    "url": "/documentation/user/altair8800/as-8080",
    "relUrl": "/altair8800/as-8080"
  },"47": {
    "doc": "Assembler \"as-ssem\"",
    "title": "Assembler “as-ssem”",
    "content": "Assembler “as-ssem” is a simple language that compiles SSEM instructions into binary output and SSEM memory. Source code has .ssem file extension, and binary form has a .bin file extension. The instructions table follows (modified from Wikipedia): . | Binary code | Mnemonic | Action | Operation | . | 000 | JMP S | S(L) -&gt; CI | Jump to the instruction at the address obtained from the specified memory address S(L) (absolute unconditional jump) | . | 100 | JRP / JPR / JMR S | CI + S(L) -&gt; CI | Jump to the instruction at the program counter (CI) plus the relative value obtained from the specified memory address S(L) (relative unconditional jump) | . | 010 | LDN S | -S(L) -&gt; A | Take the number from the specified memory address S(L), negate it, and load it into the accumulator | . | 110 | STO S | A -&gt; S(L) | Store the number in the accumulator to the specified memory address S(L) | . | 001 or 101 | SUB S | A - S(L) -&gt; A | Subtract the number at the specified memory address S(L) from the value in accumulator, and store the result in the accumulator | . | 011 | CMP / SKN | if A&lt;0 then CI+1-&gt;CI | Skip next instruction if the accumulator contains a negative value | . | 111 | STP / HLT | Stop |   | . The instructions are stored in a memory, which had 32 cells. Each cell was 32 bits long, and each instruction fit into exactly one cell. So each instruction has 32 bits. The bit representation was reversed, so the most and the least significant bits were put on opposite sides. For example, value 3, in common personal computers represented as 011, was in SSEM represented as 110. The instruction format is as follows: . | Bit: | 00 | 01 | 02 | 03 | 04 | … | 13 | 14 | 15 | … | 31 | . | Use: | L | L | L | L | L | 0 | I | I | I | 0 | 0 | . | Value: | 2^0 |   |   |   |   |   |   |   |   |   | 2^31 | . where bits LLLLL denote a “line”, which is basically the memory address - index of a memory cell. It can be understood as an instruction operand. Bits III specify the instruction opcode (3 bits are enough for 7 instructions). ",
    "url": "/documentation/user/ssem/as-ssem#assembler-as-ssem",
    "relUrl": "/ssem/as-ssem#assembler-as-ssem"
  },"48": {
    "doc": "Assembler \"as-ssem\"",
    "title": "Language syntax",
    "content": "New-lines . New-line character (LF, CR, or CRLF) are delimiters of instructions and the last character of the program. Successive empty new-line characters will be ignored. Instructions . Assembler supports all forms of instructions. All instructions must start with a line number. For example: . 01 LDN 20 . Literals / constants . Raw number constants can be defined in separate lines using special preprocessor keywords. The first one is NUM xxx, where xxx is a number in either decimal or hexadecimal form. The hexadecimal format must start with prefix 0x. For example: . 00 NUM 0x20 01 NUM 1207943145 . Another keyword is BNUM xxx, where xxx can be only a binary number. For example: . 01 BNUM 10011011111000101111110000111111 . It means that the number will be stored untouched to the memory in the format as it appears in the binary form. There exists also a third keyword, BINS xxx, with the exact meaning as BNUM. For all constants, the following rules hold. Only integral constants are supported, and the allowed range is from 0-31 (maximum is 2^5). Comments . One-line comments are supported in various forms. Generally, the comment is everything starting with some prefix until the end of the line. Comment prefixes are: . | Double-slash (//) | Semi-colon (;) | Double-dash (--) | . ",
    "url": "/documentation/user/ssem/as-ssem#language-syntax",
    "relUrl": "/ssem/as-ssem#language-syntax"
  },"49": {
    "doc": "Assembler \"as-ssem\"",
    "title": "Example",
    "content": "For example, simple 5+3 addition can be implemented as follows: . 0 LDN 7 // load negative X into the accumulator 1 SUB 8 // subtract Y from the value in the accumulator 2 STO 9 // store the sum at address 7 3 LDN 9 // A = -(-Sum) 4 STO 9 // store sum 5 HLT 7 NUM 3 // X 8 NUM 5 // Y 9 // here will be the result . The accumulator should now contain value 8, as well as memory cell at index 9. ",
    "url": "/documentation/user/ssem/as-ssem#example",
    "relUrl": "/ssem/as-ssem#example"
  },"50": {
    "doc": "Assembler \"as-ssem\"",
    "title": "Assembler \"as-ssem\"",
    "content": " ",
    "url": "/documentation/user/ssem/as-ssem",
    "relUrl": "/ssem/as-ssem"
  },"51": {
    "doc": "Assembler \"as-z80\"",
    "title": "Assembler “as-z80”",
    "content": "The assembler syntax is similar to as-8080 assembler. Z80 instructions described here. Assembler supports the following features: . | macros (unlimited nesting) | include other files support | conditional assembly | data definition | relative addressing using labels | literals and expressions in various radixes (bin, dec, hex, oct) | output is in Intel HEX format | . ",
    "url": "/documentation/user/altair8800/as-z80#assembler-as-z80",
    "relUrl": "/altair8800/as-z80#assembler-as-z80"
  },"52": {
    "doc": "Assembler \"as-z80\"",
    "title": "Running from the command line",
    "content": "The assembler is provided as part of emuStudio, and usually it is run from GUI. But it can be run also from the command line, as follows: . | on Linux: &gt; bin/as-z80 [--output output_file.hex] [source_file.asm] . | on Windows: &gt; bin\\as-z80.bat [--output output_file.hex] [source_file.asm] . | . All command line options include: . Options: --output, -o file: name of the output file --version, -v : print version --help, -h : this help . ",
    "url": "/documentation/user/altair8800/as-z80#running-from-the-command-line",
    "relUrl": "/altair8800/as-z80#running-from-the-command-line"
  },"53": {
    "doc": "Assembler \"as-z80\"",
    "title": "Lexical symbols",
    "content": "The assembler does not differentiate between upper and lower case (it is case-insensitive). The token/symbol types are as follows: . | Type | Description | . | Keywords | instruction names; preprocessor directives (org, equ, var, macro, endm, include, if, endif); data definitions (db, dw, ds); CPU registers | . | Identifiers | ([a-zA-Z_\\?@])[a-zA-Z_\\?@0-9]* except keywords | . | Labels |   | . | Constants | strings or integers | . | Operators | +, -, *, /, =, %, &amp;, \\|, !, ~, &lt;&lt;, &gt;&gt;, &gt;, &lt;, &gt;=, &lt;= | . | Comments | semi-colon (;) with text after it until the end of the line | . Constants . Numeric constants can be only integers, encoded with one of several number radixes. The possible formats are written using regexes: . | binary numbers: [0-1]+[bB] | decimal numbers: [0-9]+[dD]? | octal numbers: [0-7]+[oOqQ] | hexadecimal numbers: [0-9][0-9a-fA-F]*[hH] or 0[xX][0-9a-fA-F]+ | . Characters or strings must be enclosed in double-quotes, e,g,: LD E, \"*\" . Identifiers . Identifiers must fit to the following regex: ([a-zA-Z_\\?@])[a-zA-Z_\\?@0-9]*. It means, that it has to start with a letter a-z (or A-Z) or the at-sign (@). Then, it can be followed by letters, at-sign, or numbers. However, they must not equal to any keyword. Also, if an identifier is used for one kind of definition (label, variable, constant, or macro), it cannot be used for definition of another kind. For example, the following code is not valid . label: label set 1 . At first the identified label is used for definition of a label, and on the second row the same identifier is used for definition of a variable. This is not allowed and will produce an error. ",
    "url": "/documentation/user/altair8800/as-z80#lexical-symbols",
    "relUrl": "/altair8800/as-z80#lexical-symbols"
  },"54": {
    "doc": "Assembler \"as-z80\"",
    "title": "Instructions syntax",
    "content": "The program is basically a sequence of instructions. The instructions are separated by a new line. The instruction have optional and mandatory parts, e.g.: . LABEL: CODE OPERANDS ; COMMENT . | Part | Required | Notes | . | LABEL | Optional | Identifier of the memory position, followed by a colon (:). It can be used as forward or backward reference in instructions which expect memory address (or 16 bit number). | . | CODE | Mandatory | Instruction name. | . | OPERANDS | It depends | If applicable, a comma-separated (,) operands of the instruction. | . | COMMENT | Optional | semi-colon (;) followed by any text until the end of the line. | . Fields CODE and OPERANDS must be separated by at least one space. For example: . HERE: LD C, 0 ; Put 0 into C register DB 3Ah ; Data constant of size 1 byte LOOP: JP LOOP ; Infinite loop . Labels are optional. Instructions and pseudo-instructions and register names are reserved for assembler and cannot be used as labels. Also, there cannot be more definitions of the same label. Operands must be separated with comma (,). There exist several operand types, which represent so-called “address modes”. Allowed address modes depend on the instruction. The possibilities are: . | Implicit addressing: instructions do not have operands. They are implicit. | Register addressing: operands are registers. 8-bit general-purpose register names are: A, B, C, D, E, H , L. Register pairs have names: BC, DE, HL. The stack pointer is defined as SP, and program status word (used by push / pop instructions) as AF. Other 16-bit registers are defined as IX, IY. | Register indirect addressing: for example, loading a memory value at address in HL pair: LD A, (HL). | Immediate addressing: operand is the 8-bit constant. It can be also one character, enclosed in double-quotes. | Direct addressing: operand is either 8-bit or 16-bit constant, which is understood as the memory location (address). For example: LD (1234h), HL. | . Immediate data or addresses can be defined in various ways: . | Integer constant | Integer constant as a result of evaluation of some expression (e.g. 2 &lt;&lt; 4, or 2 + 2) | Current address - denoted by special variable $. For example, instruction JP $+6 denotes a jump by 6-bytes further from the current address. | Character constants, enclosed in double-quotes (e.g. LD A, \"*\") | Labels. For example: JP THERE will jump to the label THERE. | Variables. For example: | . VALUE VAR 'A' LD A, VALUE . ",
    "url": "/documentation/user/altair8800/as-z80#instructions-syntax",
    "relUrl": "/altair8800/as-z80#instructions-syntax"
  },"55": {
    "doc": "Assembler \"as-z80\"",
    "title": "Expressions",
    "content": "An expression is a combination of the data constants and operators. Expressions are evaluated in compile-time. Given any two expressions, they must not be defined circularly. Expressions can be used anywhere a constant is expected. There exist several operators, such as: . | Expression | Notes | . | + | Addition. Example: DB 2 + 2; evaluates to DB 4 | . | - | Subtraction. Example: DW $ - 2; evaluates to the current compilation address minus 2. | . | * | Multiply. | . | / | Integer division. | . | = | Comparison for equality. Returns 1 if operands equal, 0 otherwise. Example: DB 2 = 2; evaluates to DB 1. | . | % | Remainder after integer division. Example DB 4 mod 3; evaluates to DB 1. | . | &amp; | Logical and. | . | \\| | Logical or. | . | ~ | Logical xor. | . | ! | Logical not. | . | &lt;&lt; | Shift left by 1 bit. Example: DB 1 SHL 3; evaluates to DB 8 | . | &gt;&gt; | Shift right by 1 bit. | . | &gt; | Greater than. Example: DB 3 &gt; 2; evaluates to DB 1 | . | &lt; | Less than. | . | &gt;= | Greater or equal than. | . | &lt;= | Less or equal than. | . Operator priorities are as follows: . | Priority | Operator | Type | . | 1 | ( ) | Unary | . | 2 | *, /, %, &lt;&lt;, &gt;&gt;, &gt;, &lt;, &gt;=, &lt;= | Binary | . | 3 | +, - | Unary and binary | . | 4 | = | Binary | . | 5 | ! | Unary | . | 6 | &amp; | Binary | . | 7 | \\|, ~ | Binary | . All operators work with their arguments as if they were 16-bit. Their results are always 16-bit numbers. If there is expected an 8-bit number, the result is automatically “cut” using operation result AND 0FFh. This may be unwanted behavior and might lead to bugs, but it is often useful so the programmer must ensure the correctness. ",
    "url": "/documentation/user/altair8800/as-z80#expressions",
    "relUrl": "/altair8800/as-z80#expressions"
  },"56": {
    "doc": "Assembler \"as-z80\"",
    "title": "Defining data",
    "content": "Data can be defined using special pseudo-instructions. These accept constants. Negative integers are using two’s complement. The following table describes all possible data definition pseudo-instructions: . | Expression | Notes | . | DB [expression] | Define byte. The [expression] must be of size 1 byte. Using this pseudo-instruction, a string can be defined, enclosed in single quotes. For example: DB 'Hello, world!' is equal to DB 'H', DB 'e', etc. on separate lines. | . | DW [expression] | Define word. The [expression] must be max. of size 2 bytes. Data are stored using little endian. | . | DS [expression] | Define storage. The [expression] represents number of bytes which should be “reserved”. The reserved space will not be modified in memory. It is similar to “skipping” particular number of bytes. | . Examples . HERE: DB 0A3H ; A3 W0RD1: DB 5*2, 2FH-0AH ; 0A25 W0RD2: DB 5ABCH SHR 8 ; 5A STR: DB \"STRINGSpl\" ; 535452494E472031 MINUS: DB -03H ; FD ADD1: dw COMP ; 1C3B (assume COMP is 3B1CH) ADD2: dw FILL ; B43E (assume FILL is 3EB4H) ADD3: dw 3C01H, 3CAEH ; 013CAE3C . ",
    "url": "/documentation/user/altair8800/as-z80#defining-data",
    "relUrl": "/altair8800/as-z80#defining-data"
  },"57": {
    "doc": "Assembler \"as-z80\"",
    "title": "Including other source files",
    "content": "It is both useful and good practice to write modular programs. According to the DRY principle, the repetitive parts of the program should be refactored out into functions or modules. Functionally similar groups of these functions or modules can be put into a library, reusable in other programs. The pseudo-instruction include exists for the purpose of including already written source code into the current program. The pseudo-instruction is defined as follows: . INCLUDE \"[filename]\" . where [filename] is a relative or absolute path to the file which will be included, enclosed in double-quotes. The file can include other files, but there must not be defined circular includes (the compiler will complain). The current address (denoted by $ variable) below the include pseudo-instruction will be updated by the binary size of the included file. The namespace of the current program and the included file is shared. It means that labels or variables with the same name in the current program and the included file are prohibited. Include file “sees” everything in the current program as it was its part. Example . Let a.asm contains: . ld b, 80h . Let b.asm contains: . include \"a.asm\" . Then compiling b.asm will result in: . 06 80 ; ld b, 80h . ",
    "url": "/documentation/user/altair8800/as-z80#including-other-source-files",
    "relUrl": "/altair8800/as-z80#including-other-source-files"
  },"58": {
    "doc": "Assembler \"as-z80\"",
    "title": "Origin address",
    "content": "Syntax: ORG [expression] . Sets the value to the $ variable. It means that from now on, the following instructions will be placed at the address given by the [expression]. Effectively, it is the same as using DS pseudo-instruction, but instead of defining the number of skipped bytes, we define concrete memory location (address). The following two code snippets are equal: . | Address | Block 1 | Block 2 | Opcode | . | 2C00 | LD A,C | LD A,C | 79 | . | 2C01 | JP NEXT | JP NEXT | C3 10 2C | . | 2C04 | DS 12 | ORG $+12 |   | . | 2C10 | NEXT: XOR A | NEXT: XOR A | AF | . ",
    "url": "/documentation/user/altair8800/as-z80#origin-address",
    "relUrl": "/altair8800/as-z80#origin-address"
  },"59": {
    "doc": "Assembler \"as-z80\"",
    "title": "Equate",
    "content": "Syntax: [identifier] EQU [expression] . Define a constant. The [identifier] is a mandatory name of the constant. [expression] is the 16-bit expression. The pseudo-instruction will define a constant - assign a name to the given expression. The name of the constant then can be used anywhere where the constant is expected and the compiler will replace it with the expression. It is not possible to redefine a constant. ",
    "url": "/documentation/user/altair8800/as-z80#equate",
    "relUrl": "/altair8800/as-z80#equate"
  },"60": {
    "doc": "Assembler \"as-z80\"",
    "title": "Variables",
    "content": "Syntax: [identifier] VAR [expression] . Define or re-define a variable. The [identifier] is a mandatory name of the constant. [expression] is the 16-bit expression. The pseudo-instruction will define a variable - assign a name to the given expression. Then, the name of the variable can be used anywhere where the constant is expected. It is possible to redefine a variable, which effectively means to reassign a new expression to the same name and forgetting the old one. The reassignment is aware of locality, i.e. before it the old value will be used, after it the new value will be used. ",
    "url": "/documentation/user/altair8800/as-z80#variables",
    "relUrl": "/altair8800/as-z80#variables"
  },"61": {
    "doc": "Assembler \"as-z80\"",
    "title": "Conditional assembly",
    "content": "Syntax: . if [expression] i n s t r u c t i o n s endif . At first, the compiler evaluates the [expression]. If the result is 0, statements between if and endif are ignored. Labels defined inside the if block occupy the namespace even if the if-expression evaluates to 0. Hence, the following code yields an error (Label already defined): . if 0 label1: ld (bc), a endif label1: hlt . Evaluation of the expression in the if statement must not use forward references. For example, the following code is not valid (will produce an error): . if variable ld (bc), a endif variable set $ . In this case, variable is about to be set to current address, which would be 0 if the if statement evaluates to false. Otherwise, it evaluates to 1. Both options would be semantically correct, and the compiler cannot know what was the programmer’s intention. ",
    "url": "/documentation/user/altair8800/as-z80#conditional-assembly",
    "relUrl": "/altair8800/as-z80#conditional-assembly"
  },"62": {
    "doc": "Assembler \"as-z80\"",
    "title": "Defining and using macros",
    "content": "Syntax: . [identifier] macro [operands] i n s t r u c t i o n s endm . The [identifier] is a mandatory name of the macro. The [operands] part is a list of identifiers, separated by commas (,). Inside the macro, operands act as constants. If the macro does not use any operands, this part can be omitted. The namespace of the operand identifiers is macro-local, i.e. the operand names will not be visible outside the macro. Also, the operand names can hide variables, labels, or constants defined in the outer scope. The macros can be understood as “templates” which will be expanded in the place where they are “called”. The call syntax is as follows: . [macro name] [arguments] . where [macro name] is the macro name as defined above. Then, [arguments] are comma-separated expressions, in the order as the original operands are defined. The number of arguments must be the same as the number of macro operands. The macro can be defined anywhere in the program, even in any included file. Also, it does not matter in which place is called - above or below the macro definition. Examples . SHV MACRO LOOP: RRCA ; Right rotate with carry AND 7FH ; Clear MSB of accumulator DEC D ; Decrement rotation counter - register D JP NZ, LOOP ; Jump to next rotation ENDM . The macro SHV can be used as follows: . LD A, (TEMP) LD D,3 ; 3 rotations SHV LD (TEMP), A . Or another definition: . SHV MACRO AMT LD D,AMT ; Number of rotations LOOP: RRCA AND 7FH DEC D JP NZ, LOOP ENDM . And usage: . LD A, (TEMP) SHV 5 LD (TEMP), A . Which has the same effect as the previous example. ",
    "url": "/documentation/user/altair8800/as-z80#defining-and-using-macros",
    "relUrl": "/altair8800/as-z80#defining-and-using-macros"
  },"63": {
    "doc": "Assembler \"as-z80\"",
    "title": "END psudo-instruction",
    "content": "On encountering END pseudo-instruction, the compiler will allow only comments below this pseudo-instruction. It’s a marker of “program end”. The following example won’t compile: . LD A, 0 END HALT ; no code allowed, just comments! . ",
    "url": "/documentation/user/altair8800/as-z80#end-psudo-instruction",
    "relUrl": "/altair8800/as-z80#end-psudo-instruction"
  },"64": {
    "doc": "Assembler \"as-z80\"",
    "title": "Assembler \"as-z80\"",
    "content": " ",
    "url": "/documentation/user/altair8800/as-z80",
    "relUrl": "/altair8800/as-z80"
  },"65": {
    "doc": "Automation",
    "title": "Automation",
    "content": "MITS Altair8800 computer is capable of running automatic emulation. Automation can operate in the interactive or non-interactive mode. In case of the non-interactive mode (--no-gui flag set in the command line), the input and output of the terminal ADM-3A will be redirected to files, instead of terminal GUI. The input/output file names are configurable, please refer to ADM-3A terminal documentation. ",
    "url": "/documentation/user/altair8800/automation#automation",
    "relUrl": "/altair8800/automation#automation"
  },"66": {
    "doc": "Automation",
    "title": "Example",
    "content": "In this example we will run a non-interactive automatic emulation. Input for the terminal will be stored in a default file name adm3A-terminal.in. The content of the file must be prepared in the advance, e.g.: . Hello, world! . NOTE: Do not forget to keep the last EOL character! . The following command will emulate the computer and run “reverse text” program on it: ./emuStudio -cf config/MITSAltair8800.toml --input-file examples/as-8080/reverse.asm auto --no-gui . | computer configuration “MITS Altair8800” (file config/MITSAltair8800.toml) will be loaded | input file for compiler is one of the examples | (--auto) automatic emulation will be executed | (--no-gui) non-interactive mode will be set | . After the program finishes, emuStudio is closed. The program output will be in the file adm3A-terminal.out: . Reversed text ... Enter text: Hello, world! !dlrow ,olleH . Console will contain additional information about the emulation progress: . [INFO] [88-SIO, device=LSI ADM-3A terminal] Device was attached [INFO] Starting emulation automation... [INFO] Emulating computer: MITS Altair8800 [INFO] Compiler: Intel 8080 Assembler, version 0.41 [INFO] CPU: Intel 8080 CPU, version 0.41 [INFO] Memory: Byte-cell based operating memory, version 0.41 [INFO] Memory size: 65536 [INFO] Device: MITS 88-DCDD, version 0.41 [INFO] Device: MITS 88-SIO, version 0.41 [INFO] Device: LSI ADM-3A terminal, version 0.41 [INFO] Compiling input file: examples/as-8080/reverse.asm [INFO] Compiler started working. [INFO] [INFO ] Intel 8080 Assembler, version 0.41 [INFO] [INFO ] Compile was successful. Output: /home/vbmacher/tmp/emuStudio-release/examples/as-8080/reverse.hex Program starts at 0x03E8 [INFO] [INFO ] Compiled file was loaded into memory. [INFO] Compilation finished. [INFO] Resetting CPU... [INFO] Running emulation... [INFO] Normal stop [INFO] Instruction location = 041Ch [INFO] Emulation completed . ",
    "url": "/documentation/user/altair8800/automation#example",
    "relUrl": "/altair8800/automation#example"
  },"67": {
    "doc": "Automation",
    "title": "Automation",
    "content": " ",
    "url": "/documentation/user/altair8800/automation",
    "relUrl": "/altair8800/automation"
  },"68": {
    "doc": "Automation",
    "title": "Automation",
    "content": "Automation, or automatic emulation, is a feature in which the user can run the emulation without manual steps. It is useful for example in school enabling automatic processing of assignments, or when working on custom projects, and we are curious just about the emulator or the emulation output. Automatic emulation can be interactive, or non-interactive. In the case of interactive emulation, during the process all device GUIs are shown automatically, allowing the user to interact with the emulated computer. The user however has no access to the source code, debugger, or memory content. Non-interactive mode of the automatic emulation is even more “quiet” - it does not show any GUIs. The output of the emulation is usually redirected to one or more files. The specific behavior is plugin-based. Automatic emulation requires source code to be present. The source code is called the “input”. It will be compiled before the emulation is executed. More specific information about automation can be found in any section devoted to an emulated computer. ",
    "url": "/documentation/user/application/automation#automation",
    "relUrl": "/application/automation#automation"
  },"69": {
    "doc": "Automation",
    "title": "Example",
    "content": "The example of running automatic emulation is as follows: ./emuStudio -cf config/MITSAltair8800.toml --input-file examples/as-8080/reverse.asm auto --no-gui --waitmax 5000 . The -cf (or --computer-file) argument loads specific computer configuration instead of asking the user to open a computer. Argument --input-file provides the source code to be compiled and loaded into memory before the emulation is executed. It compiles the file only in case automated emulation is executed (see below). Command auto executes automatic emulation. If no other argument is provided, emuStudio will start as usual by asking to open a virtual computer. If computer is provided, it is opened. If input-file is provided, it is loaded and compiled into memory. Then, if the automatic emulation is interactive, will open all device GUIs and executes CPU. The --no-gui argument sets the non-interactive mode. In this case, emuStudio won’t show any GUI windows and the communication with I/O is done via files (see involved plugins documentation). Argument --waitmax 5000 tells emuStudio that the emulation should not last for more than 5 seconds. If it didn’t finish up to this deadline, it is forcibly stopped and marked as failed. ",
    "url": "/documentation/user/application/automation#example",
    "relUrl": "/application/automation#example"
  },"70": {
    "doc": "Automation",
    "title": "Automation",
    "content": " ",
    "url": "/documentation/user/application/automation",
    "relUrl": "/application/automation"
  },"71": {
    "doc": "Automation",
    "title": "Automation",
    "content": "BrainDuck computer is capable of running automatic emulation. Automation can operate in the interactive or non-interactive mode. ",
    "url": "/documentation/user/brainduck/automation#automation",
    "relUrl": "/brainduck/automation#automation"
  },"72": {
    "doc": "Automation",
    "title": "Non-interactive mode",
    "content": "If a --no-gui flag is set, the input and output will be redirected to files, instead of terminal GUI. Default input file is called vt100-terminal.in and must be placed in the directory from which emuStudio was executed. If the file does not exist, emuStudio will not run. Default output file is called vt100-terminal.out and it will be created automatically or appended when it exists in the location from which emuStudio was executed. The input/output file names are configurable, please refer to VT100 terminal documentation. ",
    "url": "/documentation/user/brainduck/automation#non-interactive-mode",
    "relUrl": "/brainduck/automation#non-interactive-mode"
  },"73": {
    "doc": "Automation",
    "title": "Be careful of EOLs",
    "content": "Take care of end-of-line characters. Most of brainfuck programs count with Unix-like EOLs, i.e. characters with ASCII code 10. plugin vt100-terminal interprets ENTER key in the interactive mode as Unix-like EOL. In the non-interactive mode, EOL may be of any-like type. ",
    "url": "/documentation/user/brainduck/automation#be-careful-of-eols",
    "relUrl": "/brainduck/automation#be-careful-of-eols"
  },"74": {
    "doc": "Automation",
    "title": "Example",
    "content": "Command line for starting non-interactive automatic emulation: ./emuStudio -cn \"BrainDuck\" -i examples/brainc-brainduck/mandelbrot.b auto --no-gui . | computer configuration named “BrainDuck”, file config/BrainDuck.toml, will be loaded | input file for compiler is one of the examples | (auto) automatic emulation will be executed | . This command will show terminal GUI and after the program finishes, emuStudio is closed. The console will contain additional information about the emulation progress: . [INFO] Starting emulation automation... [INFO] Compiler: BrainDuck Compiler, version 0.41 [INFO] CPU: BrainDuck CPU, version 0.41 [INFO] Memory: Byte-cell based operating memory, version 0.41 [INFO] Memory size: 65536 [INFO] Device: VT100 Terminal, version 0.41 [INFO] Compiling input file: examples/brainc-brainduck/mandelbrot.b [INFO] Compiler started working. [INFO] [Info ] BrainDuck Compiler, version 0.41 [INFO] [Info ] Compile was successful. Output: /home/vbmacher/emuStudio/examples/brainc-brainduck/mandelbrot.hex [INFO] [Info ] Compiled file was loaded into operating memory. [INFO] Compilation finished. [INFO] Program start address: 0000h [INFO] Resetting CPU... [INFO] Running emulation... [INFO] Normal stop [INFO] Instruction location = 2CBCh [INFO] Emulation completed . ",
    "url": "/documentation/user/brainduck/automation#example",
    "relUrl": "/brainduck/automation#example"
  },"75": {
    "doc": "Automation",
    "title": "Automation",
    "content": " ",
    "url": "/documentation/user/brainduck/automation",
    "relUrl": "/brainduck/automation"
  },"76": {
    "doc": "Automation",
    "title": "Automation",
    "content": "RAM computer will recognize if automatic emulation is executed. In the case of non-interactive mode (--no-gui), each abstract tape is redirected to a file. The format of the files is described in abstract tape documentation. ",
    "url": "/documentation/user/ram/automation#automation",
    "relUrl": "/ram/automation#automation"
  },"77": {
    "doc": "Automation",
    "title": "Example",
    "content": "Command line for starting non-interactive automatic emulation: ./emuStudio -cf config/RandomAccessMachineRAM.toml --input-file examples/ramc-ram/factorial.ram auto --no-gui . | computer config/RandomAccessMachineRAM.toml will be loaded | input file for compiler is one of the standard examples | (auto) automatic emulation will be executed | (--no-gui) non-interactive mode will be set | . After the run, the following output on the stdout can be expected: . [INFO] Starting logging symbols changes to a file: storage.out [INFO] Starting logging symbols changes to a file: input_tape.out [INFO] Starting logging symbols changes to a file: output_tape.out [INFO] Starting emulation automation... [INFO] Emulating computer: Random Access Machine (RAM) [INFO] Compiler: RAM Machine Assembler, version 0.41 [INFO] CPU: Random Access Machine (RAM), version 0.41 [INFO] Memory: RAM Program Tape, version 0.41-SNAPSHOT [INFO] Memory size: 0 [INFO] Device: Storage, version 0.41 [INFO] Device: Input tape, version 0.41 [INFO] Device: Output tape, version 0.41 [INFO] Compiling input file: examples/ramc-ram/factorial.ram [INFO] Compiler started working. [INFO] [INFO ] RAM Machine Assembler, version 0.41 [INFO] [INFO ] Compile was successful. Output: /home/vbmacher/tmp/emuStudio-release/examples/ramc-ram/factorial.bram [INFO] [INFO ] Compiled file was loaded into program memory. [INFO] Compilation finished. [INFO] Resetting CPU... [INFO] Running emulation... [INFO] Normal stop [INFO] Instruction location = 0011h [INFO] Emulation completed . Then, in the current working directory, there will be created three new files: . | input_tape.out: contains all input tape symbols | storage.out: contains log of register tape changes during emulation | output_tape.out: contains all output tape symbols | . Content of each file is a human-readable text file, but also parseable by computer. Every row has format: . position symbol . where position is zero-based index of a symbol on particular tape, and symbol is the symbol on that position. Abstract tapes of RAM machine are left-bounded, therefore all positions start at 0. ",
    "url": "/documentation/user/ram/automation#example",
    "relUrl": "/ram/automation#example"
  },"78": {
    "doc": "Automation",
    "title": "Automation",
    "content": " ",
    "url": "/documentation/user/ram/automation",
    "relUrl": "/ram/automation"
  },"79": {
    "doc": "Automation",
    "title": "Automation",
    "content": "RASP computer will recognize if automatic emulation is executed. In the case of non-interactive mode (--nogui), each abstract tape is redirected to a file. The format of the files is described in abstract tape documentation. ",
    "url": "/documentation/user/rasp/automation#automation",
    "relUrl": "/rasp/automation#automation"
  },"80": {
    "doc": "Automation",
    "title": "Example",
    "content": "Command line for starting non-interactive automatic emulation: ./emuStudio -cf config/RandomAccessStoredProgramRASP.toml --input-file examples/raspc-rasp/factorial.rasp auto --no-gui . | configuration config/RandomAccessStoredProgramRASP.toml will be loaded | input file for compiler is one of the standard examples | (auto) automatic emulation will be executed | (--no-gui) non-interactive mode will be set | . After the run, the following output on the stdout can be expected: . [INFO] Starting logging symbols changes to a file: input_tape.out [INFO] Starting logging symbols changes to a file: output_tape.out [INFO] Starting emulation automation... [INFO] Emulating computer: Random-Access Stored Program (RASP) [INFO] Compiler: RASP Machine Assembler, version 0.41 [INFO] CPU: Random Access Stored Program (RASP), version 0.41 [INFO] Memory: RASP Memory, version 0.41 [INFO] Memory size: 0 [INFO] Device: Input tape, version 0.41 [INFO] Device: Output tape, version 0.41 [INFO] Compiling input file: examples/raspc-rasp/factorial.rasp [INFO] Compiler started working. [INFO] [INFO ] RASP Machine Assembler, version 0.41 [INFO] [INFO ] Compile was successful. Output: /home/vbmacher/tmp/emuStudio-release/examples/raspc-rasp/factorial.brasp Program starts at 0x0014 [INFO] [INFO ] Compiled file was loaded into program memory. [INFO] Compilation finished. [INFO] Resetting CPU... [INFO] Running emulation... [INFO] Normal stop [INFO] Instruction location = 0037h [INFO] Emulation completed . Then, in the current working directory, there will be created three new files: . | input_tape.out: contains all input tape symbols | output_tape.out: contains all output tape symbols | . Content of each file is a human-readable text file, but also parseable by computer. Every row has format: . position symbol . where position is zero-based index of a symbol on particular tape, and symbol is the symbol on that position. Abstract tapes of RASP machine are left-bounded, therefore all positions start at 0. ",
    "url": "/documentation/user/rasp/automation#example",
    "relUrl": "/rasp/automation#example"
  },"81": {
    "doc": "Automation",
    "title": "Automation",
    "content": " ",
    "url": "/documentation/user/rasp/automation",
    "relUrl": "/rasp/automation"
  },"82": {
    "doc": "Automation",
    "title": "Automation",
    "content": "SSEM computer will recognize if automatic emulation is executed. In the case of non-interactive mode (--no-gui), the memory final “snapshot” along with additional information is written to a file named ssem.out. The file is overwritten after each emulation “stop”. ",
    "url": "/documentation/user/ssem/automation#automation",
    "relUrl": "/ssem/automation#automation"
  },"83": {
    "doc": "Automation",
    "title": "Example",
    "content": "The emulator automation can be run as follows: ./emuStudio -cf config/SSEMBaby.toml --input-file examples/as-ssem/noodle-timer.ssem auto --no-gui . | computer configuration config/SSEMBaby.toml will be loaded | input file for compiler is one of the standard examples | (auto) automatic emulation will be executed | (--no-gui) non-interactive mode will be set | . The console will contain information about emulation progress: . [INFO] Starting emulation automation... [INFO] Emulating computer: SSEM (Baby) [INFO] Compiler: SSEM Assembler, version 0.41 [INFO] CPU: SSEM CPU, version 0.41 [INFO] Memory: SSEM memory (Williams–Kilburn Tube), version 0.41 [INFO] Memory size: 128 [INFO] Device: SSEM CRT display, version 0.41 [INFO] Compiling input file: examples/as-ssem/noodle-timer.ssem [INFO] Compiler started working. [INFO] [INFO ] SSEM Assembler, version 0.41 [INFO] [INFO ] Compile was successful. Output: /home/vbmacher/tmp/emuStudio-release/examples/as-ssem/noodle-timer.bssem Program starts at 0x0000 [INFO] Compilation finished. [INFO] Resetting CPU... [INFO] Running emulation... [INFO] Normal stop [INFO] Instruction location = 005Ch [INFO] Emulation completed . the emulation will run without user interaction, and file ssem.out will be created with the following content: . ACC=0x3bfffe2 CI=0x58 L L L L L 5 6 7 8 9 0 1 2 I I I 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 00 01 * * * * * * * * * * * * * * * * * * * * * * 02 * * * * * * * * * * 03 * * * * * * * * * 04 * * * * * * * * * * 05 * * * * * * * * * * 06 * * * * * * * * * * * * * 07 * * * * * * * * * * 08 * * * * * * * 09 * * * * * * * * * * * * * * * * * * 10 * * * * * * * 11 * * * * * * * * * * * 12 * * * * * * * * * * * * * 13 * * * * * * * * * * * * * * * 14 * * * * * * * * * * 15 * * * * * * 16 * * * * * * * * * * * * * * 17 * * * * * * * * * * * * * * * * * * * * * 18 * * * * * * * * * * * * * 19 * * * * * * * 20 * * * * * * * * * * * * * 21 * * * * * * * * * * * * 22 * * * * * * * * * * * 23 * * * * * * 24 * * * * * * 25 * * * * * * * * * * * * * * * * 26 * * 27 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 28 * * * * * 29 * * * * * * * 30 * * * * * * * * * * * * * * * * * * * * * * 31 * * . ",
    "url": "/documentation/user/ssem/automation#example",
    "relUrl": "/ssem/automation#example"
  },"84": {
    "doc": "Automation",
    "title": "Automation",
    "content": " ",
    "url": "/documentation/user/ssem/automation",
    "relUrl": "/ssem/automation"
  },"85": {
    "doc": "Compiler \"brainc-brainduck\"",
    "title": "Compiler “brainc-brainduck”",
    "content": "BrainDuck compiler is used as a part of BrainDuck computer, which acts as a translator of brainfuck “human-readable” language into binary form, used by BrainDuck CPU. Those instructions and their binary codes have no relation with brainfuck itself, therefore the computer is not called brainfuck computer, because it is not brainfuck. But it does not mean you cannot write and run brainfuck programs in it :) . At first, each compiler, including BrainDuck compiler, provides a lexical analyzer for help with tokenizing the source code, used in syntax highlighting. Secondly, the compiler compiles the source code into other (usually binary) form which is then understood by CPU. Compilation takes part by user request (clicking on ‘compile’ icon in the main window). After compilation is successful, the compiler usually loads the translated program into operating memory and saves the translation into a file. So it is with BrainDuck compiler. Files have .hex extension (format is called Intel HEX). ",
    "url": "/documentation/user/brainduck/compiler#compiler-brainc-brainduck",
    "relUrl": "/brainduck/compiler#compiler-brainc-brainduck"
  },"86": {
    "doc": "Compiler \"brainc-brainduck\"",
    "title": "Language Syntax",
    "content": "The language of BrainDuck compiler is almost identical to the original brainfuck. However, brainfuck interpreter is not specified well-enough, so there are open questions on how to treat with some special situations, which are described below. Generally, the language knows eight instructions. They are best described when they are compared with C language equivalent. Brainfuck uses only a single data pointer called P, pointing to bounded memory. The boundary is specified in brainduck-mem plugin. NOTE: BrainDuck architecture conforms to the true von-Neumann model, instead of classic Harvard-style interpreters. It means that program memory and data memory are not separated. The data pointer is therefore not initialized to 0 as programmers might expect and potentially there can be written brainfuck programs with self-modifications. | Brainfuck instruction | C language equivalent | . | &gt; | P++ | . | &lt; | P-- | . | + | ++*P | . | - | --*P | . | , | *P = getchar() | . | . | putchar(*P); | . | [ | while (*P) { | . | ] | } | . The compiler is supplied with many example programs written in brainfuck. ",
    "url": "/documentation/user/brainduck/compiler#language-syntax",
    "relUrl": "/brainduck/compiler#language-syntax"
  },"87": {
    "doc": "Compiler \"brainc-brainduck\"",
    "title": "Additional details",
    "content": "Specification of brainfuck language or interpreter implementation is not complete. There are left some details which might be solved differently in different implementations. In this version of BrainDuck implementation in emuStudio, the details are hardcoded, as described below. Comments . The compiler considers a comment being everything that is not a brainfuck instruction. From the first occurrence of the unknown character, everything to the end of the line is treated as a comment. Exceptions are whitespaces, tabulators, and newlines. This practically means that it is impossible to write brainfuck program with syntax errors. In the following example, everything starting with # is treated as a comment, up to the end of the line. ++++[-] # Useless program in brainfuck. [-] clears the content of the memory cell. Cell size . A memory cell has 8-bits (cells are bytes). Memory size . Memory size is defined in byte-mem plugin. In this version of emuStudio, it is 65536 bytes. End-of-line code . EOL is defined in vt100-terminal plugin. In the current version of emuStudio, it is a Newline character with ASCII code 10. End-of-file behavior . EOF is defined in brainduck-cpu and vt100-terminal plugins. In the current version of emuStudio, the current cell (where P is pointing at) is changed to value 0. This is not how original brainfuck behaves, which does not change the cell on EOF. ",
    "url": "/documentation/user/brainduck/compiler#additional-details",
    "relUrl": "/brainduck/compiler#additional-details"
  },"88": {
    "doc": "Compiler \"brainc-brainduck\"",
    "title": "Compiler \"brainc-brainduck\"",
    "content": " ",
    "url": "/documentation/user/brainduck/compiler",
    "relUrl": "/brainduck/compiler"
  },"89": {
    "doc": "CPU \"brainduck-cpu\"",
    "title": "CPU “brainduck-cpu”",
    "content": "BrainDuck CPU is used as a part of BrainDuck computer, which acts as the interpreter of BrainDuck instructions. Those instructions correspond with brainfuck language. The program which is going to be executed is read from the operating memory, so the CPU must be connected with memory (byte-mem) to work properly. Also, optionally (but commonly) it should be connected with I/O device (vt100-terminal), so input/output can be received/send from/to the device. Only one device can be used. The CPU provides a basic user interface in the form of the status panel, which is visible in the emulator panel in the main window. Breakpoints are supported, so as “jump” to a specific location (which might be dangerous to use). ",
    "url": "/documentation/user/brainduck/cpu#cpu-brainduck-cpu",
    "relUrl": "/brainduck/cpu#cpu-brainduck-cpu"
  },"90": {
    "doc": "CPU \"brainduck-cpu\"",
    "title": "Status panel",
    "content": "In the following image, you can see the status panel of brainduck-cpu. It is split into three parts. Within the ‘Internal status’ part, there is shown content of registers IP and P. Register IP does not have a counterpart in brainfuck. IP stands for “instruction pointer”. The content is pointing at the next instruction being executed. Register P is commonly known from brainfuck. It is a pointer to data. There is the measured execution time, which is reset when the user starts the program and stopped when either the program stops or the user stops it. Loop level shows the depth level of brainfuck loop the program is in. For example, if instruction pointer points into the middle of the program [[-]], to the - instruction, the loop level is 2. ",
    "url": "/documentation/user/brainduck/cpu#status-panel",
    "relUrl": "/brainduck/cpu#status-panel"
  },"91": {
    "doc": "CPU \"brainduck-cpu\"",
    "title": "Running brainfuck programs",
    "content": "It is very important to reset the CPU after each source code compilation. The reason is that after compilation register P is not changed. It therefore might point somewhere into compiled code in the memory. If the program was executed, changes in data would corrupt the program itself. Resetting CPU would move the P register after the first occurrence of a memory cell with value 0. The value 0 in BrainDuck CPU represents halt instruction, which corresponds to EOF in brainfuck. ",
    "url": "/documentation/user/brainduck/cpu#running-brainfuck-programs",
    "relUrl": "/brainduck/cpu#running-brainfuck-programs"
  },"92": {
    "doc": "CPU \"brainduck-cpu\"",
    "title": "CPU \"brainduck-cpu\"",
    "content": " ",
    "url": "/documentation/user/brainduck/cpu",
    "relUrl": "/brainduck/cpu"
  },"93": {
    "doc": "Memory \"byte-mem\"",
    "title": "Operating memory “byte-mem”",
    "content": "This plugin emulates an operating memory with various features. It can be used for any virtual computer which can benefit from the following basic properties: . | A memory cell has a size of 1 byte (8 bits) | Memory cells are linearly ordered (sequential) | Each memory cell is accessible by a unique address, representing the index of the memory cell if the memory is imagined as an array of cells | . Besides, the memory supports these additional features: . | Setting up ROM (read-only memory) ranges | Changing memory size; by default it is 64kB | Support of bank switching | . There are also some “interactive” features: . | Manual loading/saving memory images in either binary or Intel HEX format | Ability to automatically load a memory image at startup | Intuitive control using keystrokes, and nice visual presentation of the data | . This operating memory is (for now) used only in an 8-bit emulator of MITS Altair8800. However, it is possible to develop an emulator that can benefit from it. ",
    "url": "/documentation/user/altair8800/byte-mem#operating-memory-byte-mem",
    "relUrl": "/altair8800/byte-mem#operating-memory-byte-mem"
  },"94": {
    "doc": "Memory \"byte-mem\"",
    "title": "GUI overview",
    "content": "To open the memory GUI (graphical user interface), click at the right-most icon in the debug toolbar, on the Emulator panel. The window is shown, as in the following image: . | 1 | Open a memory image. Current memory content which does not overlap with the loaded data will be kept. | . | 2 | Dump (save) whole memory content into a file. | . | 3 | Go to address. The address can be either in decimal, hexadecimal (prefix 0x) or octal (prefix 0) format. | . | 4 | Find a sequence. A dialog shows up where user can find either a plain text or sequence of bytes in the memory. | . | 5 | Toggle ASCII mode (ASCII mode means to render characters instead of character codes) | . | 6 | Erases all memory content. | . | 7 | Shows memory settings | . | 8 | By double-clicking on a memory cell it is possible to edit it and change its value. The value can be either in decimal, hexadecimal (prefix 0x) or octal (prefix 0) format. | . | 9 | Page of the memory view. The whole memory cannot be shown in single window, because it can be quite large, so it is split into pages. This split is just visual. | . | 10 | If the memory has set up memory banks, it is possible to change the view to different bank. Switching in here has no effect on the emulator and on the active bank. | . | 11 | Displays the data of the selected cell in various formats. | . Generally, it is possible to move around the cells using keystrokes (arrows). If the user presses some other letter/number key, a small text field appears allowing to edit the current value. When editing is finished, the user can press ENTER key to confirm it, or ESC key to discard the editing. ",
    "url": "/documentation/user/altair8800/byte-mem#gui-overview",
    "relUrl": "/altair8800/byte-mem#gui-overview"
  },"95": {
    "doc": "Memory \"byte-mem\"",
    "title": "Memory settings",
    "content": "Settings window can be opened by clicking on “settings” icon in the main GUI window: . | 1 | Settings for memory bank-switching | . | 2 | Settings for ROM areas | . | 3 | If checked, settings for ROM areas will be saved to the configuration file | . | 4 | List of memory images which will be loaded at startup | . | 5 | The button will save and apply the settings | . ROM areas . Some computers or modern “controllers” organize memory into logical areas, some of which could be physically mapped to a read-only memory loaded with a firmware, or a game (e.g. in a “cartridge”). These memories are wired to specific addresses, so the programmer can access them as if they were part of operating memory. The byte-mem plugin emulates this behavior. It allows to define ROM areas that represent read-only memory. There can be set up multiple ROM areas, and they can overlap. Effectively it means that memory cells in the ROM area cannot be changed from software running on the emulator. All writes to the memory will be ignored. Manually, as a user, it is possible to change the values, but only by loading a new memory image. Editing a value will not work. If a ROM range is defined, it is possible to “remove” only a part of it, effectively splitting the range and correcting their boundaries. For example, if there is defined a ROM range from 0x0A - 0x64, then it is possible to remove a range e.g. 0x32 - 0x46, which is the part of defined ROM area. Then, the original ROM area is split into two parts - first will be a range from 0x0A - 0x31, and the second from 0x47 - 0x64. Memory bank-switching . This technique was invented as a workaround for a problem when the address space of a processor was smaller than memory size. To overcome this issue, memory was logically split into many regions of size equal to the processor address space. These regions are called “banks”. Physically, banks could refer to the same memory, but they could be also different storages (e.g. external cartridges), and the bank-switching involved switching the active memory. Selecting a bank from a programming perspective was usually done by writing some code to some I/O port using some I/O instruction of a CPU (controlled by a specialized chip). But it can be implemented in various ways, e.g. some memory addresses can be used for selecting a bank. Also, it was very common that some part of the address space still kept some common memory part which was never switched out. This part is called a “common” part. In emuStudio, common part starts with the Common address (as it can be seen in the Settings dialog image above) and ends till the rest of the CPU address space (or memory end). To summarize, let’s consider an example. If a CPU is 8-bit, it means it has address space of size 2^8 - i.e. it can access memory from address 0 to (2^8 - 1). If the memory was larger, CPU just doesn’t allow to access higher memory cells. So memory bank-switching is coming for the rescue. If the memory has 2 MB, we require 2^log2(2MB) = 2^21 addresses. So, if we won’t have any common address space, we require ceil(21 / 8) = 3 banks: . | bank 0: maps from 0 - (2^8 - 1) | bank 1: maps from 2^8 - (2^16 - 1) | bank 2: maps from 2^16 - (2^21 - 1) | . ",
    "url": "/documentation/user/altair8800/byte-mem#memory-settings",
    "relUrl": "/altair8800/byte-mem#memory-settings"
  },"96": {
    "doc": "Memory \"byte-mem\"",
    "title": "Configuration file",
    "content": "The following table shows all the possible settings of byte-mem plugin: . | Name | Default value | Valid values | Description | . | banksCount | 0 | &gt;= 0 | Number of memory banks | . | commonBoundary | 0 | &gt;= 0 and &lt; mem size | Address from which the banks are shared | . | memorySize | 65536 | &gt; 0 | Memory size in bytes | . | ROMfrom(i) | N/A | &gt;= 0 and &lt; mem size | Start of the i-th ROM area | . | ROMto(i) | N/A | &gt;= ROMfrom(i) and &lt; mem size | End of the i-th ROM area | . | imageName(i) | N/A | file path | The i-th memory image file name. If it ends with .hex suffix, it will be loaded as Intel HEX format, otherwise as binary | . | imageAddress(i) | N/A | &gt;= 0 and &lt; mem size | The i-th memory image load address | . ",
    "url": "/documentation/user/altair8800/byte-mem#configuration-file",
    "relUrl": "/altair8800/byte-mem#configuration-file"
  },"97": {
    "doc": "Memory \"byte-mem\"",
    "title": "Using memory in custom computers",
    "content": "This section is for developers of emulators. If you do not plan to create custom virtual computers, you can safely skip this section. To get started with developing plugins for emuStudio, please read developer documentation. As it was mentioned in the earlier sections, the byte-mem plugin can be used in other computers, too. Besides standard operations which are provided by net.emustudio.emulib.plugins.memory.MemoryContext interface, it provides custom context API, enabling to use more features - e.g. bank-switching. You can obtain the context in Plugin.initialize() method. The context is named net.emustudio.plugins.memory.bytemem.api.ByteMemoryContext: ... public void initialize(SettingsManager settings){ ByteMemoryContext mem=contextPoolImpl.getMemoryContext(pluginID,ByteMemoryContext.class); ... } . The memory context has the following content: . package net.emustudio.plugins.memory.bytemem.api; import net.emustudio.emulib.plugins.annotations.PluginContext; import net.emustudio.emulib.plugins.memory.MemoryContext; import java.util.List; /** * \"Byte\" memory context. * &lt;p&gt; * Supports bank switching, ROM ranges, and loading HEX/BIN files. */ @SuppressWarnings(\"unused\") @PluginContext(id = \"Byte memory\") public interface ByteMemoryContext extends MemoryContext&lt;Byte&gt; { /** * Determine whether specified memory position is read-only. * * @param address memory position * @return true if the memory position is read only, false otherwise */ boolean isReadOnly(int address); /** * Get list of ranges of read-only addresses. * * @return list of ROM memory addresses */ List&lt;? extends AddressRange&gt; getReadOnly(); /** * Set specified memory range as ROM (Read Only Memory). * * @param range address range */ void setReadOnly(AddressRange range); /** * Set specified memory range as RAM (Random Access Memory). * * @param range address range */ void setReadWrite(AddressRange range); /** * Get number of available memory banks. * * @return count of memory banks */ int getBanksCount(); /** * Get index of the selected memory bank. * * @return index of active (selected) memory bank */ int getSelectedBank(); /** * Select (set as active) a memory bank. * * @param bankIndex index (number) of a bank which should be selected */ void selectBank(int bankIndex); /** * Return an address in the memory which represents a boundary from which * the memory banks have the same content. Before this address all banks * can have different content. * * @return common boundary address */ int getCommonBoundary(); /** * Returns raw memory represented by Java array. * &lt;p&gt; * Memory notifications must be handled manually if this array changes. * * @return raw memory */ Byte[][] getRawMemory(); /** * This interface represents a range of addresses in the memory. */ interface AddressRange { int getStartAddress(); int getStopAddress(); } } . ",
    "url": "/documentation/user/altair8800/byte-mem#using-memory-in-custom-computers",
    "relUrl": "/altair8800/byte-mem#using-memory-in-custom-computers"
  },"98": {
    "doc": "Memory \"byte-mem\"",
    "title": "Memory \"byte-mem\"",
    "content": " ",
    "url": "/documentation/user/altair8800/byte-mem",
    "relUrl": "/altair8800/byte-mem"
  },"99": {
    "doc": "Configuration file",
    "title": "Configuration file",
    "content": "emuStudio uses a configuration file called emuStudio.toml. It can be found in the root directory of emuStudio installation. The file is loaded just once on startup. It can be overwritten by emuStudio while running. The following table describes possible configuration options. | Configuration key | Possible values | Default value | Description | . | useSchemaGrid | true / false | true | Whether to show and use grid when editing computer configuration | . | schemaGridGap | positive integer | 20 | Gap between grid points in pixels | . | lookAndFeel | quoted string | “com.sun.java.swing.plaf.gtk.GTKLookAndFeel” | Java Look&amp;Feel used by emuStudio | . ",
    "url": "/documentation/user/application/configuration-file#configuration-file",
    "relUrl": "/application/configuration-file#configuration-file"
  },"100": {
    "doc": "Configuration file",
    "title": "Configuration file",
    "content": " ",
    "url": "/documentation/user/application/configuration-file",
    "relUrl": "/application/configuration-file"
  },"101": {
    "doc": "Example code",
    "title": "Example code",
    "content": "emuStudio provides a few brainf*ck code examples. If seeking for more, the following links might help: . | https://github.com/fabianishere/brainfuck/tree/master/examples | http://www.hevanet.com/cristofd/brainfuck/ | http://www.xappsoftware.com/wordpress/2011/03/19/brainfuck-sample-code/ | . ",
    "url": "/documentation/user/brainduck/examples#example-code",
    "relUrl": "/brainduck/examples#example-code"
  },"102": {
    "doc": "Example code",
    "title": "Example code",
    "content": " ",
    "url": "/documentation/user/brainduck/examples",
    "relUrl": "/brainduck/examples"
  },"103": {
    "doc": "MITS Altair8800",
    "title": "MITS Altair8800",
    "content": "Computer MITS Altair 8800 was named after a planet in one of the first episodes of Star Trek series. Having Intel 8080 CPU inside, with 256 bytes of memory, no display and keyboard is this computer, when comparing to the present era, absolutely ridiculous. His author, Ed Roberts, called the invention “personal computer”, which is now very common term. As Wikipedia states: . The Altair is widely recognized as the spark that ignited the microcomputer revolution. Wikipedia, Altair 8800 . Altair 8800 is one of the oldest commercially available computers overall. Ed Roberts (founder and CEO of MITS corporation) was selling these machines by classic mail directly from the factory. Various enthusiasts understood the power of Altair and started to develop software and hardware for the computer. Those people saw freedom in Altair - some kind of release from batch tasks ran on mainframe systems, maintained by elite. The phenomenon of a computer which could be put on the kitchen table allowed to make enormous money by two smart university students. In 1975, Paul Allen and Bill Gates wrote a trimmed version of BASIC programming language, called Altair BASIC, which pushed them directly to foundation of Microsoft corporation. Basic configuration of MITS Altair 8800 was: . | Item | Notes | . | Processor | Intel 8080 or 8080a | . | Speed | 2 MHz | . | RAM | from 256 bytes to 64 kB | . | ROM | optional; usually EPROM Intel 1702 with 256 bytes (They were used for various bootloaders) | . | Storage | optional; paper tapes, cassette tapes or 5.25” or 8” floppy disks (MITS 88-DCDD) | . | Extensions | at first 16 slots, later 18 slots | . | Bus | famous S-100 | . | Video | none | . | I/O | optional; parallel or serial board (MITS 88-SIO) | . | Original software | Altair DOS, CP/M, Altair BASIC | . ",
    "url": "/documentation/user/altair8800/#mits-altair8800",
    "relUrl": "/altair8800/#mits-altair8800"
  },"104": {
    "doc": "MITS Altair8800",
    "title": "Altair8800 for emuStudio",
    "content": "In emuStudio, there exist two variants of the computer, varying in CPU. Either Intel 8080 CPU, or Zilog Z80 CPU is used. Some behavior was inspired by simh emulator. Abstract schema for emuStudio (Intel 8080): . Abstract schema for emuStudio (Zilog Z80): . Each plugin is described in further sections. ",
    "url": "/documentation/user/altair8800/#altair8800-for-emustudio",
    "relUrl": "/altair8800/#altair8800-for-emustudio"
  },"105": {
    "doc": "MITS Altair8800",
    "title": "MITS Altair8800",
    "content": " ",
    "url": "/documentation/user/altair8800/",
    "relUrl": "/altair8800/"
  },"106": {
    "doc": "emuStudio Application",
    "title": "emuStudio Application",
    "content": "emuStudio is a desktop application which allows emulation of various computers. Besides emulation, it contains source code editor, which can be used to write and then compile programs then to be instantly emulated. Virtual computers, as the emulators are called, are represented by plugins of various type (compiler, memory, CPU and device), combined in a computer configuration. The computer configuration can be opened during startup. The application has also command-line interface, which allows executing automatic “load-compile-emulate” workflow, possibly without graphical interface. This workflow is called “automatic emulation” and has its specifics, discussed per virtual computer. A logger is used by emuStudio which helps debugging of the application and plugins. ",
    "url": "/documentation/user/application/#emustudio-application",
    "relUrl": "/application/#emustudio-application"
  },"107": {
    "doc": "emuStudio Application",
    "title": "Installation and run",
    "content": "At first, please download emuStudio distribution. It is either a TAR or ZIP file in the form emuStudio-[VERSION].zip. For Linux/Mac environments, a TAR variant will be more suitable since it preserves file attributes and execution permissions. Unpack the file where you want to have emuStudio installed. Before running, Java 11 or later must be installed. Then, emuStudio can be run by executing the following script: . | On Linux / Mac &gt; ./emuStudio . | On Windows: &gt; emuStudio.bat . | . NOTE: Currently supported are Linux and Windows. Mac is NOT supported, but it might work to some extent. ",
    "url": "/documentation/user/application/#installation-and-run",
    "relUrl": "/application/#installation-and-run"
  },"108": {
    "doc": "emuStudio Application",
    "title": "Command-line arguments",
    "content": "emuStudio accepts several command line arguments. Their description is accessible with --help argument: . $ ./emuStudio --help Usage: emuStudio [-hV] [-cl] [-i=FILE] [-cn=NAME | -cf=FILE | -ci=INDEX] [COMMAND] Universal emulation platform and framework -cl, --computers-list list all existing virtual computers -h, --help Show this help message and exit. -i, --input-file=FILE input file name (source code) -V, --version Print version information and exit. Virtual computer -cf, --computer-file=FILE virtual computer configuration file -ci, --computer-index=INDEX virtual computer index (see -cl for options) -cn, --computer-name=NAME virtual computer name (see -cl for options) Commands: automation, auto run emulation automation . Automation command has its own usage: . $ ./emuStudio auto --help Usage: emuStudio automation [-hV] [--[no-]gui] [-s=ADDRESS] [-w=MILLIS] run emulation automation --[no-]gui show/don't show GUI during automation -h, --help Show this help message and exit. -s, --start-address=ADDRESS program start address -V, --version Print version information and exit. -w, --waitmax=MILLIS limit emulation time to max MILLIS (force kill afterwards) . ",
    "url": "/documentation/user/application/#command-line-arguments",
    "relUrl": "/application/#command-line-arguments"
  },"109": {
    "doc": "emuStudio Application",
    "title": "emuStudio Application",
    "content": " ",
    "url": "/documentation/user/application/",
    "relUrl": "/application/"
  },"110": {
    "doc": "BrainDuck",
    "title": "BrainDuck",
    "content": "BrainDuck is an abstract computer for emuStudio, which mimics brainfuck programming language. Originally, brainfuck was developed by Urban Miller and it is well-known fact that the language has a minimalistic compiler, and it’s eight instructions don’t prevent it to be Turing complete. Also, there exist many extensions of the language and there are organized programming contests in brainfuck worldwide. But all of that can be read at Wikipedia or at other sources. BrainDuck architecture is just a name for virtual computer in emuStudio, and consists of these plugins: . | brainc-brainduck: Compiler of brainfuck language (original, without extensions) | brainduck-cpu: Brainfuck emulator acting like CPU with two registers | byte-mem: Virtual operating memory which holds both compiled brainfuck program and data | vt100-terminal: Virtual terminal for displaying the output and requesting for input. | . BrainDuck is implemented as [von Neumann] computer. It means that the program and data are shared in the same memory. This is not a common approach to implementing brainfuck interpreters, and it might be changed in the future. As implementing a brainfuck interpreter, one must deal with several portability issues, which include: . | Memory cell size (byte) | Memory size (number of memory cells) (by default 65536 when using byte-mem) | End-of-line code (0x0A is simulating both CRLF, 0x0D is just CR) | End-of-file behavior (in automatic no-GUI emulation when input is at EOF 0 is returned; in GUI-capable emulation the input is read from the host keyboard) | . ",
    "url": "/documentation/user/brainduck/#brainduck",
    "relUrl": "/brainduck/#brainduck"
  },"111": {
    "doc": "BrainDuck",
    "title": "BrainDuck for emuStudio",
    "content": "In order to use BrainDuck, there must be drawn the abstract schema, saved in the configuration file. Abstract schemas are drawn in the schema editor in emuStudio (please see emuStudio application documentation for more details). The following image shows the schema of BrainDuck computer: . Arrows are in a direction of dependency. So for example brainc-brainduck depends on byte-mem, because compiled programs are directly loaded into memory. Between brainduck-cpu and vt100-terminal exists bidirectional dependency, because input gained from a terminal is passed to the CPU, and output is pushed from CPU to the terminal. plugin brainduck-cpu also depends on byte-mem, because memory is a place where program and data are stored. ",
    "url": "/documentation/user/brainduck/#brainduck-for-emustudio",
    "relUrl": "/brainduck/#brainduck-for-emustudio"
  },"112": {
    "doc": "BrainDuck",
    "title": "BrainDuck",
    "content": " ",
    "url": "/documentation/user/brainduck/",
    "relUrl": "/brainduck/"
  },"113": {
    "doc": "RAM",
    "title": "Random Access Machine (RAM)",
    "content": "Random Access Machine (RAM) is the abstract machine, invented to study algorithmic complexity of programs written on register-based computers. It is equivalent to the Turing machine and has a close relationship with a so-called Harvard computer architecture, which has separated storage for program and data. The model implies that it is not possible to modify instructions. RAM machine consists of several parts: input tape (read-only), output tape (write-only), program memory, data memory or registers (read/write) and a control unit (“engine”), as can be seen in the following image: . Input tape acts as a water-tap; the input data can be read from it, causing the input head to move to the next unread symbol. The head can never return to a previously read symbol. Output tape, on the other hand, acts as a sink. The output data can be written to it, causing the output head to move to the next “empty” symbol. The head can also never return to the previously written symbol. Data memory - registers tape - represents the random-access memory. It consists of so-called registers, abstract cells with arbitrary size. These registers are ordered - each one has assigned the index - its position within the tape called the address. The tape head can move arbitrarily up and down - but it has its minimum position. It is the first register, R0, called the accumulator. Below there is an unlimited number of higher-positioned registers. The role of the accumulator is kind of special - it often acts as an implicit operand for many instructions, or implicit place for storing the result of such instructions. Program memory is a bounded ordered sequence of registers; each of them is identified by its index within the tape, called address. Data memory is also ordered sequence of registers, but like the I/O tapes - bounded just from one side. Since RAM machine is somewhat abstract, it frees the user from thinking about some issues and just assumes that: . | The size of the problem is always small enough to fit in the RAM memory, | Data used within the computation are always small enough to fit in one register. | . The RAM virtual machine in emuStudio consists of the following plugins: . | ramc-ram: Compiler of the RAM language, very simple “assembler”-like language | ram-cpu: RAM simulator engine | ram-mem: Program memory | abstract-tape: Device which represents the “tape” used in RAM, other than program memory. The abstract schema must define three instances of this device, representing register, input, and output tapes. | . ",
    "url": "/documentation/user/ram/#random-access-machine-ram",
    "relUrl": "/ram/#random-access-machine-ram"
  },"114": {
    "doc": "RAM",
    "title": "RAM in emuStudio",
    "content": "To use RAM, there must exist the abstract schema of the “computer”, saved in the configuration file. Abstract schemas are drawn in the schema editor in emuStudio (please see emuStudio main module documentation for more details). The following image shows the schema of RAM machine simulator: . The “-&gt;” arrows are in direction of dependency. So for example ramc-ram depends on ram-mem, because compiled programs are directly loaded into memory. The roles of the abstract tapes are assigned by the RAM “CPU” on runtime. ",
    "url": "/documentation/user/ram/#ram-in-emustudio",
    "relUrl": "/ram/#ram-in-emustudio"
  },"115": {
    "doc": "RAM",
    "title": "RAM",
    "content": " ",
    "url": "/documentation/user/ram/",
    "relUrl": "/ram/"
  },"116": {
    "doc": "RASP",
    "title": "Random-Access Stored Program (RASP)",
    "content": "Random Access Stored Program machine (RASP) is an abstract von-Neumann computer. It means it does not represent a physical device, but rather it is intended to work as a model to study von-Neumann architecture, without the need to care about specific manufacturer’s hardware details. Firstly, it is useful to present Random Access Stored Program (RASP) machine’s architecture – it is schematically depicted in the following figure. As we can see, the control unit, i.e. processor, reads data from the input tape and writes results of executed operations onto the output tape. The tapes serve as a form of I/O devices. The two heads – reading (R) and writing (W), are pointers to the current reading/writing position. As already stated, the RASP machine represents a von Neumann computer. This implies that the operating memory exists as a single unit in which both program and data can reside. The segment containing the program is organized in the way that two adjacent cells contain instruction/operand alternately. The memory can be read as well as written to by the control unit. ",
    "url": "/documentation/user/rasp/#random-access-stored-program-rasp",
    "relUrl": "/rasp/#random-access-stored-program-rasp"
  },"117": {
    "doc": "RASP",
    "title": "RASP for emuStudio",
    "content": "Each virtual computer in emuStudio is defined by the so-called “abstract schema”. It defines all the parts of its architecture (what it consists of) and inner communication (how architecture components are interconnected). The following figure presents the RASP abstract schema: . ",
    "url": "/documentation/user/rasp/#rasp-for-emustudio",
    "relUrl": "/rasp/#rasp-for-emustudio"
  },"118": {
    "doc": "RASP",
    "title": "RASP",
    "content": " ",
    "url": "/documentation/user/rasp/",
    "relUrl": "/rasp/"
  },"119": {
    "doc": "SSEM",
    "title": "Small Scale Experimental Machine (SSEM)",
    "content": "Small Scale Experimental Machine, also known as SSEM, was the world’s very first stored-program computer, nicknamed “Baby”. It was a predecessor of Manchester Mark 1 which led to Ferranti Mark 1, the world’s first commercially available general-purpose computer. The following image shows the SSEM CRT display: . It is very simple computer, which can run only 7 instructions. ",
    "url": "/documentation/user/ssem/#small-scale-experimental-machine-ssem",
    "relUrl": "/ssem/#small-scale-experimental-machine-ssem"
  },"120": {
    "doc": "SSEM",
    "title": "SSEM for emuStudio",
    "content": "In emuStudio, SSEM computer is composed of a compiler, memory, CRT display and CPU. Abstract schema follows: . ",
    "url": "/documentation/user/ssem/#ssem-for-emustudio",
    "relUrl": "/ssem/#ssem-for-emustudio"
  },"121": {
    "doc": "SSEM",
    "title": "SSEM",
    "content": " ",
    "url": "/documentation/user/ssem/",
    "relUrl": "/ssem/"
  },"122": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": "emuStudio is a toy-computer emulation platform and framework, targeting mainly academic sphere. A platform, because it supports full emulation “life-cycle”. From writing and compiling programs for emulated machine, to running and debugging. A framework, because it provides API and documentation which encourages implementing your custom toy-computer, either real or abstract. There are already many emulators out there doing great job in preserving history (e.g. MAME, or simh). While emuStudio is also trying to be accurate in technical details and historical behavior of emulated computers, but the main focus is allowing comfortable programming and experimenting with emulated devices - in the style of “write program - load it into computer - emulate”. That is why you can expect quite detailed documentation of rather usage and programming of the devices than used emulation techniques. That brings along nice GUI, source code editor and virtual computer designer. ",
    "url": "/documentation/user/introduction/#introduction",
    "relUrl": "/introduction/#introduction"
  },"123": {
    "doc": "Introduction",
    "title": "References",
    "content": "The following lists a few references on emuStudio online. | Year | Reference | . | 2022 | emuStudio on Reddit | . | 2022 | Twirling bar animation | . | 2022 | emuStudio on 8bitnews | . | 2022 | emuStudio on Gametech wiki | . ",
    "url": "/documentation/user/introduction/#references",
    "relUrl": "/introduction/#references"
  },"124": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": " ",
    "url": "/documentation/user/introduction/",
    "relUrl": "/introduction/"
  },"125": {
    "doc": "Logging",
    "title": "Logging",
    "content": "No software is bug-free in these days, and not a person is perfect. Sometimes it might happen that emuStudio is not working as expected, either it does not start (with a weird message on screen), or it fails while running. For that purpose, everything important is being logged. If you encounter some problem and either want to fix it or report it, the logs, except steps to reproduce are the most important thing. By default, logging is written to the standard output (console). In case of a problem, it is a good practice to enable file logging. To enable file logging, open logback.xml file located in the root directory of emuStudio. Find a section named &lt;root ..&gt;, and change appender-ref from STDOUT to FILE as follows: . &lt;root level=\"debug\"&gt; &lt;appender-ref ref=\"FILE\"/&gt; &lt;/root&gt; . The log file is named logs/emuStudio.log. Every new run of emuStudio will append log messages into that file until emuStudio is terminated. By default, a rolling policy is enabled, which deletes logs older than 2 days and keeps the log in maximum size of 1 MB. It is of course configurable. For more information about how to configure loggers, please look at the logback site. ",
    "url": "/documentation/user/application/logging#logging",
    "relUrl": "/application/logging#logging"
  },"126": {
    "doc": "Logging",
    "title": "Automation logger",
    "content": "An important part of the analysis of the result of the automatic emulation is the log saying what happened. By default, each run of automatic emulation creates (overwrites) a log located in logs/automation.log file. The log file is in plaintext format and contains messages which appeared in the log during the emulation. The log file format can be customized, see the previous section for more details. ",
    "url": "/documentation/user/application/logging#automation-logger",
    "relUrl": "/application/logging#automation-logger"
  },"127": {
    "doc": "Logging",
    "title": "Logging",
    "content": " ",
    "url": "/documentation/user/application/logging",
    "relUrl": "/application/logging"
  },"128": {
    "doc": "Main window",
    "title": "Main window",
    "content": "The main window is the core part of the emuStudio application. Users usually spend there most of the time while working with emuStudio. The content of the window is split into two panels or tabs, placeholders for two actions users can do in emuStudio. The first tab is “Source code editor”, second is “Emulator”, used during computer emulation. ",
    "url": "/documentation/user/application/main-window#main-window",
    "relUrl": "/application/main-window#main-window"
  },"129": {
    "doc": "Main window",
    "title": "Source code editor",
    "content": ". In the source code editor, users can write programs for the emulated computer. However, the most important tool which allows translation of the source code into a binary program readable by emulated CPU is a compiler. Therefore, users must use the right compiler. The input language of a compiler is not limited, it can be either a kind of assembler or even C or Pascal language. It depends on the compiler implementation, there can be many. The only restriction is that compiler must have an output that is compatible with CPU which is currently being emulated. This cannot be checked automatically, users must take care of this. The source code editor supports the following features: . | fixed font: Fira Code regular (cannot be changed at the moment) | line numbering &amp; syntax highlighting | undo/redo capability | search/replace text | cut/copy/paste text | CTRL+{mouse wheel} changes font size | . The compilation must be run manually. The compiler output window shows all messages which compiler produces. The content is dependent on the used compiler, but most likely it will contain compilation success or error messages. Compiled source code can produce an output binary file (for example a HEX file), and it’s automatically loaded into the operating memory. If the emulation is running, the user must stop it first manually. If another program is loaded in memory, it is not removed before loading the currently compiled program, but the memory is overwritten at only those locations relevant to the compiled program. All the other content is left unchanged. ",
    "url": "/documentation/user/application/main-window#source-code-editor",
    "relUrl": "/application/main-window#source-code-editor"
  },"130": {
    "doc": "Main window",
    "title": "Emulator tab",
    "content": "Emulator tab is shown in the following image. It is currently open with MITS Altair8800 computer with Intel 8080 CPU, and several devices: . The tab contains three main parts. The first one is very useful - listing of operating memory disassembled into instructions. This part is called a debugger window, or “debugger”. The other part, below the debugger window, is a list of all computer devices used (“peripheral devices”). With a double click, the user can open the GUI window of that particular device, if it supports it. The right part shows the status of the CPU used in this computer. Each CPU has its own implementation of how the status window look and what it displays. Debugger window . Debugging is a process in which a programmer tries to analyze a program, usually with the intent to find bugs. The adverb “to debug” has a deep history. Very early computers were having so-called vacuum tubes, which were core elements acting as electrically controlled switches. From time to time a computer stopped working, and the most usual reason was that a bug (a real one) came in a vacuum tube. Maintainers of the computer had to go there and manually remove the bug. It happened that often so that the process of removing bugs got a name - “to de-bug”.] Debugger in emuStudio contains a debugger toolbar and list of few disassembled instructions from memory. In combination with the CPU status panel, it’s the most powerful tool for seeing (and checking) all internal behavior of the emulated computer. Debugger toolbar . Debugger toolbar contains buttons (icons) for controlling the emulation and accessing memory content. Most of these buttons are self-explanatory. If you hover over those icons, a help text is displayed on how to use the icon. | 1 | Reset emulation. | . | 2 | Set the next instruction position to 0. CPU will perform the next instruction from there. | . | 3 | Set the next instruction position to the (current - 1). This action can completely change the displaying of instructions since the new instruction position does not have to be correct in terms of executing the current program. | . | 4 | Stop emulation (which was either running or paused). | . | 5 | Pause emulation (which was running). | . | 6 | Run emulation (which was paused). | . | 7 | Run emulation with a timer (which was paused). Instructions are executed after elapsing specified time interval. A dialog will appear to enter the time interval. | . | 8 | Step emulation (which was paused). CPU will execute only one - the very next - instruction. | . | 9 | Jump to location. The user will manually specify a location (address in memory) for the next instruction to execute. | . | 10 | Set/unset breakpoint. The user can set or unset a breakpoint on a specific memory location. When the CPU reaches the breakpoint, it will pause there, waiting for the next user action. | . | 11 | Show operating memory. If the memory plugin does not have a GUI, the icon is disabled. | . List of instructions . The largest part of the debugger window a list of few disassembled instructions, so-called instructions window. About 15 instructions are shown, but it depends on the CPU. They are arranged in a table. The first column is usually interactive, allowing the user to set breakpoints. The red strip is pointing to the very next instruction being executed. The size of disassembled memory (resulting in the number of disassembled instructions) is not configurable. Also, the user cannot change instructions in this place. Sometimes the instructions shown in the debugger do not have to be disassembled correctly. There are two reasons for that: . | first, instructions can have various binary sizes (e.g. one byte, two bytes, etc.) | second, memory can contain programs on various locations, and emuStudio doesn’t know where. Well, if it’s just a program compiled from the source code editor, it knows. | . The implication is that if emuStudio starts to disassemble instructions at the wrong location, the instructions will be disassembled incorrectly, or they can appear as invalid. However, emuStudio is trying hard to find the nearest program start location at which it’s safe to start disassembling. Usually, it’s just a few instructions back, so it is a fast process. Controlling of displaying the instructions . By default, instructions window points to the next instruction with a few instructions before and after the current one. This set of instructions is called an “instructions window”. The instruction window has it’s starting and ending offset in memory. It is possible to move the window to forwards or backward, in a per-page fashion. A toolbar below the instructions list contains controls to control the instruction window pages. | 1 | Go to the first page. The very first row corresponds to instruction position 0. | . | 2 | Go backward. The user will specify the number of pages for going back. | . | 3 | Go to the previous page. | . | 4 | Go to the page where the current instruction position is. | . | 5 | Go to the next page. | . | 6 | Go forwards. The user will specify the number of pages for going forward. | . ",
    "url": "/documentation/user/application/main-window#emulator-tab",
    "relUrl": "/application/main-window#emulator-tab"
  },"131": {
    "doc": "Main window",
    "title": "Main window",
    "content": " ",
    "url": "/documentation/user/application/main-window",
    "relUrl": "/application/main-window"
  },"132": {
    "doc": "Opening a computer",
    "title": "Opening a computer",
    "content": "The first action that emuStudio does is loading a computer to be emulated. Virtual computers are described in abstract schemas, which are stored in configuration files. Computers can be loaded either from the command line or manually in GUI (by default). The “open dialog” is the first thing which appears to a user. The left part contains a control panel and a list of all available virtual computers. When a user clicks at a computer, it’s abstract schema is displayed on the right. Double-clicking or clicking on the Open button loads selected computer. ",
    "url": "/documentation/user/application/opening-computer#opening-a-computer",
    "relUrl": "/application/opening-computer#opening-a-computer"
  },"133": {
    "doc": "Opening a computer",
    "title": "Managing virtual computers",
    "content": ". | 1 | Adds new computer. The abstract schema editor will be opened. | . | 2 | Deletes selected computer. Be aware of what you are doing - the action cannot be undone. | . | 3 | Edits selected computer. The abstract schema editor will be opened. | . | 4 | Renames computer. | . | 5 | Saves the displayed abstract schema into image file. | . ",
    "url": "/documentation/user/application/opening-computer#managing-virtual-computers",
    "relUrl": "/application/opening-computer#managing-virtual-computers"
  },"134": {
    "doc": "Opening a computer",
    "title": "Opening a computer",
    "content": " ",
    "url": "/documentation/user/application/opening-computer",
    "relUrl": "/application/opening-computer"
  },"135": {
    "doc": "CPU \"ram-cpu\"",
    "title": "CPU “ram-cpu”",
    "content": "This plugin is the core of the emulation/simulation. Even if we’re supposed to talk about the RAM simulator, because emulation is connected more with imitation of real hardware than the abstract machine, there is a plugin that calls itself a RAM CPU. It is really not accurate, but CPU nowadays means something as the main or core engine of the computation which the machine does. So the name got stuck rather with this convention. The plugin strictly requires a ram-mem, and three instances of abstract-tape plugins, representing the tapes. After boot, the CPU assigns the specific meaning to each tape. ",
    "url": "/documentation/user/ram/ram-cpu#cpu-ram-cpu",
    "relUrl": "/ram/ram-cpu#cpu-ram-cpu"
  },"136": {
    "doc": "CPU \"ram-cpu\"",
    "title": "Status panel",
    "content": "In the following image, you can see the status panel of ram-cpu. It is split into three parts. Within the ‘Internal status’ part, there is shown the content of registers R0 (accumulator) and IP. Register IP is the position of the program memory head. It stands for “instruction pointer”. It is pointing at the next instruction being executed. The input/output part shows the next unread symbol (“next input”), and the last symbol written to the output tape (“last output”). This is just for convenience; it is possible to see the same values in particular tape devices. The last part, “Run state”, shows in which state the whole emulation is, and it is common to all emulators in emuStudio. The state “breakpoint” means that the emulation is paused. ",
    "url": "/documentation/user/ram/ram-cpu#status-panel",
    "relUrl": "/ram/ram-cpu#status-panel"
  },"137": {
    "doc": "CPU \"ram-cpu\"",
    "title": "CPU \"ram-cpu\"",
    "content": " ",
    "url": "/documentation/user/ram/ram-cpu",
    "relUrl": "/ram/ram-cpu"
  },"138": {
    "doc": "Memory \"ram-mem\"",
    "title": "Program memory (“ram-mem”)",
    "content": "RAM memory is a part of RAM simulator and acts as the “program memory” (it holds just the program, no data). RAM CPU reads instructions from this memory, data are read from abstract tapes. Instructions are written into this memory only through compiling the source code or loading an already compiled binary image. The memory plugin contains a simple graphical window, which can be seen in the following image: . | 1 | Open already compiled program into memory. The previous program will be dismissed. RAM binary files has extension .bram. | . | 2 | Dump memory content into a file (either human-readable or .bram). | . | 3 | Clears memory. | . ",
    "url": "/documentation/user/ram/ram-mem#program-memory-ram-mem",
    "relUrl": "/ram/ram-mem#program-memory-ram-mem"
  },"139": {
    "doc": "Memory \"ram-mem\"",
    "title": "Memory \"ram-mem\"",
    "content": " ",
    "url": "/documentation/user/ram/ram-mem",
    "relUrl": "/ram/ram-mem"
  },"140": {
    "doc": "Compiler \"ramc-ram\"",
    "title": "Compiler “ramc-ram”",
    "content": "RAM has a very simple assembler-like language, consisting of direct and indirect reading/writing from/to registers or input/output tape. Also, there are three control-flow instructions. Source code files end with .ram extension; compiler output uses extension .bram. ",
    "url": "/documentation/user/ram/ramc-ram#compiler-ramc-ram",
    "relUrl": "/ram/ramc-ram#compiler-ramc-ram"
  },"141": {
    "doc": "Compiler \"ramc-ram\"",
    "title": "Language syntax",
    "content": "A program written for RAM consists of two sections, which can be intermixed and repeated in any order, but the preferred order is as follows: . INPUT section INSTRUCTIONS section . Input section . The INPUT section contains definitions the content of input tape - one or more lines in the form: . &lt;input&gt; ITEMS . where ITEMS is a space-separated list of inputs. Each input is one word - it might be any number or string. Strings must be in quotes - single (') or double (\"). For example, the input section might be: . &lt;input&gt; 1 2 3 'hello' 'world!' . In this case, there are five inputs: numbers 1,2,3, then word “hello” and the last one is “world!”. Note floating-point numeric values are not supported. Instructions section . There exist many variations of RAM instructions, unfortunately, the syntax is not very unified. The reason might be that RAM is not a real machine. Each instruction must be on a separate line, in the following form: . [LABEL:] INSTRUCTION [; optional comment] . Each instruction position can be optionally labeled with some identifier (LABEL field), followed by a colon (:) character. The labels can be then referred to in other instructions. Comments can be one-line or multi-line. One-line comments begin with a semicolon (;), hash sign (#), double-dash (--) or double-slash (//). A one-line comment continues to the end of the line. Multi-line comments start with /* characters and end with */ characters. In-between there can be multiple lines of text, all treated as comment. An instructions consists of the operation code, optionally followed by an operand separated with at least one space ( ), but not with a newline. Operation code is expressed as an abbreviation of corresponding operation (e.g. SUB for SUBtraction). An operand can be one of three types: constant (=i), direct operand (i), where i specifies the register index on tape and indirect operand (*i), where the address of operand specified is stored in register Ri. The following table describes all possible instructions, usable in the RAM simulator: . | Instruction | Constant (=i) | Direct (i) | Indirect (*i) | . | READ |   | Ri ← next input |   | . | WRITE | output ← i | output ← Ri | output ← M[Ri] | . | LOAD | R0 ← i | R0 ← Ri | R0 ← M[Ri] | . | STORE |   | Ri ← R0 | M[Ri] ← R0 | . | ADD | R0 ← R0 + i | R0 ← R0 + Ri | R0 ← R0 + M[Ri] | . | SUB | R0 ← R0 - i | R0 ← R0 - Ri | R0 ← R0 - M[Ri] | . | MUL | R0 ← R0 * i | R0 ← R0 * Ri | R0 ← R0 * M[Ri] | . | DIV | R0 ← R0 / i | R0 ← R0 / Ri | R0 ← R0 / M[Ri] | . | JMP |   | IP ← i |   | . | JZ |   | if R0 == 0 then IP ← i |   | . | JGTZ |   | if R0 &gt; 0 then IP ← i |   | . | HALT |   | halts the simulation |   | . The table describes also the behavior of each instruction. The compiler does not care about the behavior, but about the syntax of the instructions, which is also incorporated in the table. Code example . For example, this is a valid program: . ; Copy R(X) to R(Y) ; ; input tape: ; destination register: X ; source register: Y ; ; output: ; R(X) = R(Y) ; R(Y) = R(Y) &lt;input&gt; 3 4 'hello' 'world' ; load X,Y read 1 read 2 ; load r.X, r.Y read *1 read *2 ; copy load *2 store *1 halt . ",
    "url": "/documentation/user/ram/ramc-ram#language-syntax",
    "relUrl": "/ram/ramc-ram#language-syntax"
  },"142": {
    "doc": "Compiler \"ramc-ram\"",
    "title": "Compiler \"ramc-ram\"",
    "content": " ",
    "url": "/documentation/user/ram/ramc-ram",
    "relUrl": "/ram/ramc-ram"
  },"143": {
    "doc": "CPU \"rasp-cpu\"",
    "title": "CPU “rasp-cpu”",
    "content": "This plugin is the core of the emulation/simulation. Even if we’re supposed to talk about the RASP simulator, because emulation is connected more with imitation of real hardware than the abstract machine, there is a plugin that calls itself a RASP CPU. It is really not accurate, but CPU nowadays means something as the main or core engine of the computation which the machine does. So the name got stuck rather with this convention. The plugin strictly requires a rasp-mem, and two instances of abstract-tape plugins, representing the input and output tapes. After boot, the CPU assigns the specific meaning to each tape. ",
    "url": "/documentation/user/rasp/rasp-cpu#cpu-rasp-cpu",
    "relUrl": "/rasp/rasp-cpu#cpu-rasp-cpu"
  },"144": {
    "doc": "CPU \"rasp-cpu\"",
    "title": "Status panel",
    "content": "In the following image, you can see the status panel of rasp-cpu. It is split into three parts. Within the ‘Internal status’ part, there is shown the content of registers R0 (accumulator) and IP. Register IP is the position of the program memory head. It stands for “instruction pointer”. It is pointing at the next instruction being executed. The input/output part shows the next unread symbol (“next input”), and the last symbol written to the output tape (“last output”). This is just for convenience; it is possible to see the same values in particular tape devices. The last part, “Run state”, shows in which state the whole emulation is, and it is common to all emulators in emuStudio. The state “breakpoint” means that the emulation is paused. ",
    "url": "/documentation/user/rasp/rasp-cpu#status-panel",
    "relUrl": "/rasp/rasp-cpu#status-panel"
  },"145": {
    "doc": "CPU \"rasp-cpu\"",
    "title": "CPU \"rasp-cpu\"",
    "content": " ",
    "url": "/documentation/user/rasp/rasp-cpu",
    "relUrl": "/rasp/rasp-cpu"
  },"146": {
    "doc": "Memory \"rasp-mem\"",
    "title": "Memory “rasp-mem”",
    "content": "RASP memory plug-in is the main store (operating memory) used in RASP virtual computer. RASP is an example of von-Neumann architecture, which implies that both program and data reside in the same memory. After compilation of a RASP source code, the compiled program is loaded into RASP memory. During the process of the emulation, the CPU plug-in reads instructions and their operands from the memory and writes results back to the same memory (except reading inputs and writing outputs). ",
    "url": "/documentation/user/rasp/rasp-mem#memory-rasp-mem",
    "relUrl": "/rasp/rasp-mem#memory-rasp-mem"
  },"147": {
    "doc": "Memory \"rasp-mem\"",
    "title": "Graphical user interface (GUI)",
    "content": "RASP memory has a simple window, which can be accessed from the debug panel in emuStudio: . | 1 | Open already compiled program into memory. The previous program will be dismissed. RASP binary files has extension .brasp. | . | 2 | Dump memory content into a file (either human-readable or .brasp). | . | 3 | Clears memory. | . The table with memory content is editable. By double-clicking on a row you can simply edit the value. You confirm your changes by the ENTER key: . NOTE: By editing an opcode cell (a cell that contains an instruction opcode), the instruction is changed. It is also possible to set invalid opcode values, which then results in “address fallout” error during emulation. For example, if a cell contains the ADD = instruction (operation code 7), which is then changed to 9 (SUB =), the instruction on that location will be now changed and emuStudio will interpret it as such. ",
    "url": "/documentation/user/rasp/rasp-mem#graphical-user-interface-gui",
    "relUrl": "/rasp/rasp-mem#graphical-user-interface-gui"
  },"148": {
    "doc": "Memory \"rasp-mem\"",
    "title": "Memory \"rasp-mem\"",
    "content": " ",
    "url": "/documentation/user/rasp/rasp-mem",
    "relUrl": "/rasp/rasp-mem"
  },"149": {
    "doc": "Compiler \"raspc-rasp\"",
    "title": "Compiler “raspc-rasp”",
    "content": "RASP compiler has a very simple assembler-like language, consisting of direct reading/writing from/to registers or input/output tape. Also, there are three control-flow instructions. Syntax is very similar to RAM machine, just RASP doesn’t support indirect addressing. Source code files end with .rasp extension; compiler output uses extension .brasp. ",
    "url": "/documentation/user/rasp/raspc-rasp#compiler-raspc-rasp",
    "relUrl": "/rasp/raspc-rasp#compiler-raspc-rasp"
  },"150": {
    "doc": "Compiler \"raspc-rasp\"",
    "title": "Language syntax",
    "content": "A program written for RASP is composed of three sections, which can be intermixed and repeated in any order, but the preferred order is as follows: . INPUT section ORG section INSTRUCTIONS section . Input section . The INPUT section contains definitions the content of input tape - one or more lines in the form: . &lt;input&gt; ITEMS . where ITEMS is a space-separated list of inputs. Each input is one word - it might be any number or string. Strings must be in quotes - single (') or double (\"). For example, the input section might be: . &lt;input&gt; 1 2 3 'hello' 'world!' . In this case, there are five inputs: numbers 1,2,3, then word “hello” and the last one is “world!”. Note floating-point numeric values are not supported. ORG section . The ORG pseudo-instruction sets the address of the following instruction to a specified value. For example: . org 5 ; sets next address to 5 read 0 . By default, if ORG is not specified in the beginning of the program, it is added implicitly as ORG 20. It is because registers in RASP are stored in memory (R0 at address 0, etc.), so this implicit ORG pre-allocates 20 registers. Instructions section . There exist many variations of RASP instructions, unfortunately, the syntax is not very unified. The reason might be that RASP is not a real machine. Each instruction must be on a separate line, in the following form: . [LABEL:] INSTRUCTION [; optional comment] . Each instruction position can be optionally labeled with some identifier (LABEL field), followed by a colon (:) character. The labels can be then referred to in other instructions. Comments can be one-line or multi-line. One-line comments begin with a semicolon (;), hash sign (#), double-dash (--) or double-slash (//). A one-line comment continues to the end of the line. Multi-line comments start with /* characters and end with */ characters. In-between there can be multiple lines of text, all treated as comment. An instructions consists of the operation code, optionally followed by an operand separated with at least one space ( ), but not with a newline. Operation code is expressed as an abbreviation of corresponding operation (e.g. SUB for SUBtraction). An operand can be one of three types: constant (=i), direct operand (i), where i specifies the register index on tape and label, pointing to the address in memory. The following table describes all possible instructions, usable in the RASP simulator: . | Instruction | Constant (=i) | Direct (i) | Label | . | READ |   | Ri ← next input |   | . | WRITE | output ← i | output ← Ri |   | . | LOAD | R0 ← i | R0 ← Ri |   | . | STORE |   | Ri ← R0 |   | . | ADD | R0 ← R0 + i | R0 ← R0 + Ri |   | . | SUB | R0 ← R0 - i | R0 ← R0 - Ri |   | . | MUL | R0 ← R0 * i | R0 ← R0 * Ri |   | . | DIV | R0 ← R0 / i | R0 ← R0 / Ri |   | . | JMP |   |   | IP ← label | . | JZ |   |   | if R0 == 0 then IP ← label | . | JGTZ |   |   | if R0 &gt; 0 then IP ← label | . | HALT |   | halts the simulation |   | . Code example . For example, this is a valid program: . ; N! (factorial) ; Program reads an integer number from the input tape, calculates its factorial and prints the result ; onto the output tape. org 5 ; reserve 5 registers ;saves the constant 1 into R2 and R3 registers load =1 store 2 store 3 ;reads a number from the input tape read 1 ;if the number is greater than 0, jump to \"ok\", otherwise, jump to \"finish\" load 1 jgtz ok jmp finish ;the loop to calculate the factorial value ok: load 3 sub 1 jz finish load 3 add =1 store 3 mul 2 store 2 jmp ok ;print the result finish: write 2 halt . ",
    "url": "/documentation/user/rasp/raspc-rasp#language-syntax",
    "relUrl": "/rasp/raspc-rasp#language-syntax"
  },"151": {
    "doc": "Compiler \"raspc-rasp\"",
    "title": "Compiler \"raspc-rasp\"",
    "content": " ",
    "url": "/documentation/user/rasp/raspc-rasp",
    "relUrl": "/rasp/raspc-rasp"
  },"152": {
    "doc": "Computer schema",
    "title": "Computer schema",
    "content": "Computer schema represents a real configuration of the emulated computer. They are “drawn” in a computer schema editor. Users pick plugins that appear as “boxes” or elements on the screen. Then using connection lines those elements can be connected together to express a relation (that they can “see” each other). Description of the control panel follows. | 1 | Save the virtual computer. | . | 2 | Select a compiler. | . | 3 | Select a CPU. | . | 4 | Select a memory. | . | 5 | Select a device. | . | 6 | Use a connection line. The line is bidirectional by default. | . | 7 | Set or unset the connection line to be bidirectional. If the line is not bidirectional, the source direction is the first clicked element and the target direction is the second clicked element. | . | 8 | Remove an element from the schema. | . | 9 | This drop-down list is used for selecting a specific plugin (element) in the computer schema. See icons 2, 3, 4, and 5. The names are actually plugin JAR file names. | . | 10 | Use / do not use a grid in the editor. Elements are “snapped” to the grid if it is used, and it’s easier to draw the schema which looks good. The slider on the right then controls the density of the grid. The density is saved in the configuration file of the edited computer. | . Virtual computers in emuStudio are following the von-Neumann model of computers. It means that each computer must have a CPU and memory. Optionally one or more devices, and optionally a compiler. ",
    "url": "/documentation/user/application/computer-schema#computer-schema",
    "relUrl": "/application/computer-schema#computer-schema"
  },"153": {
    "doc": "Computer schema",
    "title": "Connection lines",
    "content": "The connection line represents a virtual “connection” between computer components. For the computer schema, it’s not important how the connection is realized. It’s safe to say that the connection is similar as if we say that a component “sees” the other component, in the direction of the arrow: . In the previous image, a CPU “sees” the memory, but not vice-versa. It means, CPU can read/write from/to memory, but memory is not seeing it, it can just answer to CPU requests. This connection makes sense in real-world computers. Drawing connection lines is very easy. The connection line always connects exactly two elements in the schema. At first, the user must click on an already existing element in the schema. It’s just a click, not a drag. Then a grey temporary line is being drawn having its end at the mouse position and moving with the mouse move. If the element is not really close, the user can make a “path” by clicking somewhere in the schema. At those locations, fixed-points are created. When a user clicks at the second element, the temporary line disappears, and a real connection line is created. The user can find the fixed-points later and move them by dragging. They can be removed by clicking at them with the right mouse button. ",
    "url": "/documentation/user/application/computer-schema#connection-lines",
    "relUrl": "/application/computer-schema#connection-lines"
  },"154": {
    "doc": "Computer schema",
    "title": "Computer schema",
    "content": " ",
    "url": "/documentation/user/application/computer-schema",
    "relUrl": "/application/computer-schema"
  },"155": {
    "doc": "Device \"simh-pseudo\"",
    "title": "Pseudo-device “simh-pseudo”",
    "content": "This device is originally implemented as permanently connected to 88-SIO device in simh emulator. It listens to custom, non-standard commands from operating system thus simplifies communication between emulator (host) and running guest system. This device is required if you want to run CP/M operating system images made for simh emulator. ",
    "url": "/documentation/user/altair8800/simh-pseudo#pseudo-device-simh-pseudo",
    "relUrl": "/altair8800/simh-pseudo#pseudo-device-simh-pseudo"
  },"156": {
    "doc": "Device \"simh-pseudo\"",
    "title": "Programming",
    "content": "SIMH-pseudo device can be pretty useful also for users of emuStudio. Z80 or 8080 programs communicate with it via port 0xFE. Some commands sent to the port require parameters, in which case there must be sent multiple bytes. If a command returns anything, the returned value can be read using IN instruction. List of commands . In case of multibyte parameters or return value, if it’s a numeric value it’s always in a form of little endian. | Command | Parameters | Return value | Description | . | 0 | N/A | N/A | print the current time on stdout, in milliseconds | . | 1 | N/A | N/A | start a new timer on the top of the timer stack | . | 2 | N/A | N/A | stop timer on top of timer stack and print time difference on stdout, in milliseconds | . | 3 | N/A | N/A | reset the PTR device (NOT IMPLEMENTED) | . | 4 | N/A | N/A | attach the PTR device (NOT IMPLEMENTED) | . | 5 | N/A | N/A | detach the PTR device (NOT IMPLEMENTED) | . | 6 | N/A | 8 bytes (\"SIMH004\\0\") | get the current version of the SIMH pseudo device | . | 7 | N/A | 6 bytes | get the current time in ZSDOS format, all BCD values: byte 0: year modulo 100, byte 1: month, byte 2: day, byte 3: hour, byte 4: minute, byte 5: second | . | 8 | 2 bytes (address of a 6-byte block in memory representing ZSDOS time in format YY MM DD HH MM SS) | N/A | set the current time in ZSDOS format: reads the time from given address | . | 9 | N/A | 5 bytes | get the current time in CP/M 3 format, all BCD values: bytes 0-1: days since 1 Jan 1978 (low byte), byte 2: hour, byte 3: minute, byte 4: second | . | 10 | 2 bytes (address of a 5-byte block in memory representing CP/M 3 time in format: 0-1: days since 31 Dec 77, 2: HH, 3: MM, 4: SS) | N/A | set the current time in CP/M 3 format: reads the time from given address | . | 11 | N/A | 1 byte | get the selected bank | . | 12 | 1 byte | N/A | set the selected bank | . | 13 | N/A | 2 bytes | get the base address of the common memory segment | . | 14 | N/A | N/A | reset the SIMH-pseudo device (clears “undefined” state) | . | 15 | N/A | N/A | show time difference to timer on top of stack | . | 16 | N/A | 1 byte | attach PTP device to the file with name at beginning of CP/M command line (NOT IMPLEMENTED) | . | 17 | N/A | N/A | detach PTP device (NOT IMPLEMENTED) | . | 18 | N/A | 1 byte | determines whether machine has banked memory (returns number of memory banks) | . | 19 | N/A | N/A | set the CPU to a Z80 (NOT IMPLEMENTED) | . | 20 | N/A | N/A | set the CPU to an 8080 (NOT IMPLEMENTED) | . | 21 | N/A | N/A | start timer interrupts | . | 22 | N/A | N/A | stop timer interrupts | . | 23 | 2 bytes | N/A | set the timer interval in which interrupts occur | . | 24 | 2 bytes | N/A | set the address to call by timer interrupts | . | 25 | N/A | N/A | reset the millisecond stop watch | . | 26 | N/A | 2 bytes | read the millisecond stop watch | . | 27 | N/A | N/A | let emulation sleep for 1000 milliseconds | . | 28 | N/A | 1 byte | obtain the file path separator of the OS under which emuStudio runs | . | 29 | N/A | file names separated by 0, ends with double 0 | perform wildcard expansion and obtain list of file names | . | 30 | URL (N bytes terminated with 0) | max 1024 byte pairs (URL content) in form availability, data (when availability is 1 the data byte is valid) until availability is 0 | read the contents of a URL | . | 31 | N/A | 2 bytes | get the clock frequency of the CPU | . | 32 | 2 bytes | N/A | set the clock frequency of the CPU. To make effect, CPU must be paused/run again. | . | 33 | 2 bytes (byte 0: (unused) interrupt vector, byte 1: interrupt data byte, an RST instruction) | N/A | generate interrupt | . How to call a command . Calling a command always starts with an OUT instruction: . ld a, &lt;cmd&gt; ; replace \"&lt;cmd&gt;\" with command number out (0xFE), a . Then, if a command requires a parameter, it must be supplied with additional OUT instruction(s), depending on how many bytes are expected, as follows: . ld a, &lt;param0&gt; ; replace \"&lt;param0&gt;\" with parameter byte 0 out (0xFE), a ld a, &lt;param1&gt; ; replace \"&lt;param1&gt;\" with parameter byte 1 out (0xFE), a ... ; etc. After last parameter is recognized by SIMH-pseudo device, the command is executed. Then, if the command returns a result, it must be read with IN instructions, depending on how many bytes are to be returned, as follows: . in a, (0xFE) ; register A contains first byte of result ... ; save the byte somewhere in a, (0xFE) ; register A contains second byte of result . Note: The program must send/receive all bytes. Otherwise, the device will stay in a state when it “expects” the rest of parameter bytes, or result bytes to be read. It is however possible to “reset” the device by sending a reset command to the device (command 14). ",
    "url": "/documentation/user/altair8800/simh-pseudo#programming",
    "relUrl": "/altair8800/simh-pseudo#programming"
  },"157": {
    "doc": "Device \"simh-pseudo\"",
    "title": "Device \"simh-pseudo\"",
    "content": " ",
    "url": "/documentation/user/altair8800/simh-pseudo",
    "relUrl": "/altair8800/simh-pseudo"
  },"158": {
    "doc": "Original software",
    "title": "Original software for Altair8800",
    "content": "Since Altair8800 virtual computer emulates a real machine, it’s possible to use real software written for the computer. Several operating systems and programs can be run on Altair. There are many disk and memory images of those systems available online, but only some were tested and proved to work. Some available online sites are: . | Peter Schorn: operating systems, other operating systems, original software, programming languages, office applications, games and tools, | SIMH CP/M and DOS, updated kit with 4K Basic, 8K Basic, Prolog, and CP/M 3 | Altair clone | DeRamp | . In order to manipulate with CP/M disk images, there are several options: . | please look at 88-dcdd page Experimental CP/M support | you can try cpmtools. | SIMH emulator supports run-time reading and writing files using utilities HDIR.COM (lists files on host computer), R.COM (reads file from host into CP/M disk image) and W.COM (writes a file in CP/M disk image to host) | . Tested and fully-functional images in emuStudio are: . | Operating system CP/M v2.2 and 3 | Altair DOS v1.0 | BASIC programming language in various versions | . Some software manuals can be found e.g. here. The following subsections describe in short how to boot some of those systems, along with screenshots how it looks. ",
    "url": "/documentation/user/altair8800/software#original-software-for-altair8800",
    "relUrl": "/altair8800/software#original-software-for-altair8800"
  },"159": {
    "doc": "Original software",
    "title": "Boot ROM",
    "content": "Booting operating systems on Altair requires special ROM image to be loaded in operating memory. The purpose of a boot ROM is to load some blocks of data from a disk device (e.g. 88-DCDD) and then execute it. The code block is often called a ‘bootloader’. A bootloader is device-specific, and often also disk format-specific. So e.g. for loading Altair 8” diskette with “simh” formatting there should be used different bootloader than other diskette types and/or formatting. The following table lists available bootloaders in emuStudio: . | Bootloader | Disk type | Diskette format | Description | . | examples/altair8800/boot/dbl.bin | 88-dcdd | Altair8800 8”, simh formatted | Original 88-dcdd bootloader ROM, compatible with 8080 and Z80 | . | examples/altair8800/boot/mdbl.bin | 88-dcdd | Altair8800 8”, simh formatted | Modified 88-dcdd bootloader ROM for computers supporting memory-banking using simh device | . The bootloaders are provided with source code which can be modified to user needs. Boot ROM must be loaded into memory at address 0xFF00 (hexadecimal). It is safe to jump to this address manually when operating system image file is mounted. NOTE: All subsequent sections assume that the bootloader has been loaded in the operating memory. ",
    "url": "/documentation/user/altair8800/software#boot-rom",
    "relUrl": "/altair8800/software#boot-rom"
  },"160": {
    "doc": "Original software",
    "title": "CP/M 2.2",
    "content": "During Altair8800 computer era, many operating systems, applications and programming languages have been developed. On of the most known operating systems is CP/M. It was written by Gary Kildall from Digital Research, Inc. At first it was mono-tasking and single-user operating system which didn’t need more than 64kB of memory. Subsequent versions added multi-user variants, and they were ported to 16-bit processors. The combination of CP/M and computers with S-100 bus (8-bit computers sharing some similarities with Altair 8800) was big “industry standard”, widely spread in 70’s up to 80’s years of twentieth century. The operating system took the burden of programming abilities from user, and this was one of the reasons why the demand for hardware and software was rapidly increased. Tested image has name altcpm.dsk. It can be downloaded at this link. To run CP/M, please follow these steps: . | Mount altcpm.dsk to drive A: in MITS 88-DCDD. | In emuStudio jump to location 0xFF00 | Optionally, you can set CPU frequency to 2000 kHz, which was Intel 8080 original frequency. | Before starting emulation, show ADM-3A terminal | Run the emulation | . When the steps are completed, CP/M should start (an informational message appears) and command line prompt will be displayed: . Command dir is working, ls is better dir. More information about CP/M commands can be found at this link. ",
    "url": "/documentation/user/altair8800/software#cpm-22",
    "relUrl": "/altair8800/software#cpm-22"
  },"161": {
    "doc": "Original software",
    "title": "CP/M 3",
    "content": "Steps for running CP/M 3 operating systems are not that different from CP/M 2. The disk image file is called cpm3.dsk and can be downloaded at this link. CP/M 3 came with two versions: banked and non-banked. The image is the banked version of CP/M. Also, simh authors provided custom BIOS and custom bootloader (mdbl.bin). Manual of CP/M 3 can be found at this link. For more information about simh version of Altair8800 and CP/M 3, click here. There are some requirements for the computer architecture, a bit different for CP/M 2.2. CPU . It is recommended to use Z80 version of the computer. CPU Intel 8080 will work for the operating system itself, but most provided applications require Z80. Operating memory . Also, the operating memory needs to be set for memory banks. The following parameters were borrowed from simh and were tested: . | 8 memory banks | common address C000h | . Boot ROM . There exist specific version of bootloader (modified probably by simh authors) to load CP/M into banked memory. It is available in examples/altair8800/boot/mdbl.bin in your emuStudio installation. Before other steps, please load this image into operating memory at address 0xFF00 (hexadecimal). Steps for booting CP/M 3 . Specific steps how to boot CP/M 3 in emuStudio follow: . | Mount cpm3.dsk to drive A: in MITS 88-DCDD. | In emuStudio jump to location 0xFF00 | Optionally, you can set CPU frequency to 2500 kHz, which was Zilog Z80 original frequency. | Before starting emulation, show ADM-3A terminal | Run the emulation | . The following image shows the look right after the boot: . ",
    "url": "/documentation/user/altair8800/software#cpm-3",
    "relUrl": "/altair8800/software#cpm-3"
  },"162": {
    "doc": "Original software",
    "title": "Altair DOS v1.0",
    "content": "Steps for booting Altair DOS v1.0 follow: . | Mount altdos.dsk to drive A: in MITS 88-DCDD. | In emuStudio jump to location 0xFF00 | Optionally, you can set CPU frequency to 2000 kHz, which was Intel 8080 original frequency. | Before starting emulation, show ADM-3A terminal | Run the emulation | . The system will start asking some questions. According to the Altair manual, answers for emuStudio are: . | MEMORY SIZE? -&gt; 64 or ENTER (if memory ROM is at 0xFFFF) | INTERRUPTS -&gt; N or just ENTER | HIGHEST DISK NUMBER? -&gt; 0 (if only 1 disk is mounted) | HOW MANY DISK FILES? -&gt; 3 | HOW MANY RANDOM FILES? -&gt; 2 | . Basic commands you can use are e.g. MNT 0 - to mount the drive, and then DIR 0 to list the files. If you want AltairDOS being able to automatically detect how much memory is installed on system, it is possible. The system does it by very nasty trick - testing if it can write to particular address (ofcourse, maximum is 16-bits - i.e. 64K of memory). If the result is the same as it was before reading, it means that it reached the “end of memory”. But when it fails to detect the ROM, it fails to determine the size, too, and the output will be INSUFFICIENT MEMORY. The following image shows how it looks like: . ",
    "url": "/documentation/user/altair8800/software#altair-dos-v10",
    "relUrl": "/altair8800/software#altair-dos-v10"
  },"163": {
    "doc": "Original software",
    "title": "BASIC",
    "content": "In this section will be presented how to boot MITS BASIC version 4.1. There is possible to boot also other versions, but the principle is always the same. As it is written in simh manual: MITS BASIC 4.1 was the commonly used software for serious users of the Altair computer. It is a powerful (but slow) BASIC with some extended commands to allow it to access and manage the disk. There was no operating system it ran under. After boot, you must mount the disk with MOUNT 0. Then, command FILES will show all files on the disk. To run a file, run command RUN \"file\". Manual can be found at this link. Steps for booting BASIC follow: . | Mount mbasic.dsk to drive A: in MITS 88-DCDD. | In emuStudio jump to location 0xFF00 | Optionally, you can set CPU frequency to 2000 kHz, which was Intel 8080 original frequency. | Before starting emulation, show ADM-3A terminal | Run the emulation | . The following image shows the look right after the boot: . ",
    "url": "/documentation/user/altair8800/software#basic",
    "relUrl": "/altair8800/software#basic"
  },"164": {
    "doc": "Original software",
    "title": "Original software",
    "content": " ",
    "url": "/documentation/user/altair8800/software",
    "relUrl": "/altair8800/software"
  },"165": {
    "doc": "Software for SSEM",
    "title": "Software for SSEM",
    "content": "The following links point to some software for SSEM (either original or created later) which can be run on emuStudio (possibly with slight modifications): . | https://www.computerconservationsociety.org/software/ssem/base.htm | http://www.historicsimulations.com/ssem.html | https://github.com/jcla1/gobaby/tree/master/examples | . The following animation shows running example nightmare.ssem: . ",
    "url": "/documentation/user/ssem/software#software-for-ssem",
    "relUrl": "/ssem/software#software-for-ssem"
  },"166": {
    "doc": "Software for SSEM",
    "title": "Software for SSEM",
    "content": " ",
    "url": "/documentation/user/ssem/software",
    "relUrl": "/ssem/software"
  },"167": {
    "doc": "CPU \"ssem-cpu\"",
    "title": "SSEM CPU emulator",
    "content": "SSEM is one of the first implementations of the von-Neumann design of a computer. It contained a control unit, arithmetic-logic unit, and I/O subsystem (CRT display). The speed of CPU is around 700 instructions per second. The architecture of our SSEM CPU emulator will look as follows (below is Display and Memory just to show how it is connected in overall): . ",
    "url": "/documentation/user/ssem/ssem-cpu#ssem-cpu-emulator",
    "relUrl": "/ssem/ssem-cpu#ssem-cpu-emulator"
  },"168": {
    "doc": "CPU \"ssem-cpu\"",
    "title": "Status panel",
    "content": "The status panel is the interaction point between the CPU and the user. With it, the user can be allowed to modify or view the internal status of the CPU emulator. This is very handy when learning or checking how it works, what the registers’ values are (and compare them with those shown on a display), etc. The status panel shows the following: . | CPU run state | Internal state: registers or possibly portion of memory | Speed | . SSEM CPU status panel looks as follows: . ",
    "url": "/documentation/user/ssem/ssem-cpu#status-panel",
    "relUrl": "/ssem/ssem-cpu#status-panel"
  },"169": {
    "doc": "CPU \"ssem-cpu\"",
    "title": "CPU \"ssem-cpu\"",
    "content": " ",
    "url": "/documentation/user/ssem/ssem-cpu",
    "relUrl": "/ssem/ssem-cpu"
  },"170": {
    "doc": "Display \"ssem-display\"",
    "title": "SSEM Display",
    "content": "SSEM computer used CRT “display”, which displayed the SSEM memory content. emuStudio plugin does not mimic the real display interface with switches and everything, but it is just a display of the memory content. Here can be seen how the original display looked like. ",
    "url": "/documentation/user/ssem/ssem-display#ssem-display",
    "relUrl": "/ssem/ssem-display#ssem-display"
  },"171": {
    "doc": "Display \"ssem-display\"",
    "title": "Graphical User Interface (GUI)",
    "content": "GUI of the display looks as follows: . It doesn’t do any user interaction except displaying. ",
    "url": "/documentation/user/ssem/ssem-display#graphical-user-interface-gui",
    "relUrl": "/ssem/ssem-display#graphical-user-interface-gui"
  },"172": {
    "doc": "Display \"ssem-display\"",
    "title": "Display \"ssem-display\"",
    "content": " ",
    "url": "/documentation/user/ssem/ssem-display",
    "relUrl": "/ssem/ssem-display"
  },"173": {
    "doc": "Memory \"ssem-mem\"",
    "title": "Memory “ssem-mem”",
    "content": "SSEM used the world’s first random-access memory called Williams or Williams-Kilburn tube. The used principle was the same as in standard Cathode-Ray-Tubes (CRTs). Original EDSAC computer (which introduced the von Neumann architecture) did not have random-access memory. SSEM memory had 32 memory cells (called words), each had a size of 32 bits. The memory could contain instructions and data. So, one SSEM instruction perfectly fits in the single memory word. SSEM had 32 so-called “lines”, which represented cells in memory. Each line, or a cell, was 4 bytes long. ",
    "url": "/documentation/user/ssem/ssem-mem#memory-ssem-mem",
    "relUrl": "/ssem/ssem-mem#memory-ssem-mem"
  },"174": {
    "doc": "Memory \"ssem-mem\"",
    "title": "Graphical user interface (GUI)",
    "content": "Since emuStudio is interactive application, GUIs are a natural thing. The memory GUI looks as follows: . As you can see in the picture, a row represents single SSEM memory cell - 32 scattered bits and the last few columns show both the number the bits represent and a raw ASCII value of the 4-byte sequence of data. Editing the cells is also possible, by pointing to a bit, and pressing either 1 or 0 - possibly a DELETE key, committing the change immediately. This works for the value itself, and the data column as well. Movement around cells is possible with arrow keys. ",
    "url": "/documentation/user/ssem/ssem-mem#graphical-user-interface-gui",
    "relUrl": "/ssem/ssem-mem#graphical-user-interface-gui"
  },"175": {
    "doc": "Memory \"ssem-mem\"",
    "title": "Memory \"ssem-mem\"",
    "content": " ",
    "url": "/documentation/user/ssem/ssem-mem",
    "relUrl": "/ssem/ssem-mem"
  },"176": {
    "doc": "Terminal \"vt100-terminal\"",
    "title": "Terminal vt100-terminal",
    "content": "VT100 terminal is probably one of the most popular terminal ever, created by DEC in 1978. It has many functions, activated by ASCII control sequences which became de facto a standard. Even today those control sequences are emulated by many modern terminals (as we like to call “command line prompts”). (Autor: Jason Scott – Flickr: IMG_9976, CC BY 2.0, available here) . VT100-terminal plugin for emuStudio is currently very slim emulator recognizing only some control codes and does not emulate all VT100 features. Supported features are: . | some VT100 control codes emulation | resizable display at runtime | keyboard input; binary codes can be entered with special dialog | . ",
    "url": "/documentation/user/brainduck/terminal#terminal-vt100-terminal",
    "relUrl": "/brainduck/terminal#terminal-vt100-terminal"
  },"177": {
    "doc": "Terminal \"vt100-terminal\"",
    "title": "Graphical User Interface (GUI)",
    "content": "In the following screenshot, VT100-terminal window is shown: . It’s easy and simple. BrainDuck CPU as it interprets . (dot) instructions, it sends the output to this terminal, which displays it on the screen. Input cannot be entered anytime. In brainfuck, the input is requested through , instruction. Only when CPU encounters , (comma) instruction, the user is asked to enter input. This situation is marked with a green icon in the bottom-left corner: . Next to the icon, there is a blue “ASC” button. This button can be used for entering binary values as input. A special little dialog will appear asking the user to enter space-separated numbers, representing ASCII codes of the input. ",
    "url": "/documentation/user/brainduck/terminal#graphical-user-interface-gui",
    "relUrl": "/brainduck/terminal#graphical-user-interface-gui"
  },"178": {
    "doc": "Terminal \"vt100-terminal\"",
    "title": "VT100-terminal Settings",
    "content": "The following screenshot shows settings dialog of the terminal: . | 1 | Set number of terminal columns. The “Set default” button sets columns to the default value. | . | 2 | Set number of terminal rows. The “Set default” button sets rows to the default value. | . | 3 | Set input file name, which will be used in “No GUI” mode instead of keyboard. | . | 4 | Set output file name, which will be used in “No GUI” mode instead of display. | . | 5 | Set input read delay (in milliseconds) when reading input file in “No GUI” mode. Can be used for slowing down emulation. | . | 6 | Saves the settings, and closes the dialog. | . ",
    "url": "/documentation/user/brainduck/terminal#vt100-terminal-settings",
    "relUrl": "/brainduck/terminal#vt100-terminal-settings"
  },"179": {
    "doc": "Terminal \"vt100-terminal\"",
    "title": "Configuration file",
    "content": "The following table shows all the possible settings of VT100-terminal plugin: . | Name | Default value | Valid values | Description | . | inputFileName | vt100-terminal.in | Path to existing file | File for reading input (when redirected) | . | outputFileName | vt100-terminal.out | Path to existing file | File for writing output (when redirected) | . | inputReadDelay | 0 | &gt;= 0 | How long the terminal should wait until it reads next input character from the file (in milliseconds) | . | columns | 80 | &gt; 0 | Number of terminal columns | . | rows | 24 | &gt; 0 | Number of terminal rows | . ",
    "url": "/documentation/user/brainduck/terminal#configuration-file",
    "relUrl": "/brainduck/terminal#configuration-file"
  },"180": {
    "doc": "Terminal \"vt100-terminal\"",
    "title": "Terminal \"vt100-terminal\"",
    "content": " ",
    "url": "/documentation/user/brainduck/terminal",
    "relUrl": "/brainduck/terminal"
  },"181": {
    "doc": "CPU \"z80-cpu\"",
    "title": "Zilog Z80 CPU emulator",
    "content": "It was possible to upgrade your Altair 8800 computer with a “better” 8-bit processor Zilog Z80. The processor was probably the most used 8-bit processor in the ’80s. It was backward compatible with 8080 and brought many enhancements. It was originally targeted for embedded systems, but it became popular very soon. Z80 was used for all kinds of computers - including desktop computers, arcade games, etc. Today the CPU is still used in some MP3 players, see e.g. S1 MP3 Player. Main features of the emulator include: . | Interpretation as an emulation technique, | Correct real timing of instructions, | Ability to set clock frequency manually at run-time, | Emulation of all instructions including interrupts, | Disassembler implementation, | Ability to “dump” instruction history to console at run-time, | Support of breakpoints, | The ability of communication with up to 256 I/O devices, | Status window shows all registers, flags, and run-time frequency. | . ",
    "url": "/documentation/user/altair8800/z80-cpu#zilog-z80-cpu-emulator",
    "relUrl": "/altair8800/z80-cpu#zilog-z80-cpu-emulator"
  },"182": {
    "doc": "CPU \"z80-cpu\"",
    "title": "Configuration file",
    "content": "The following table shows all the possible settings of Zilog Z80 CPU plugin: . | Name | Default value | Valid values | Description | . | printCode | false | true / false | Whether the emulator should print executed instructions, and its internal state to console (dump) | . | printCodeUseCache | false | true / false | If printCode is set to true, then a cache will be used which remembers already visited blocks of code so the instruction dump will not be bloated with infinite loops | . | frequency_khz | 4000 | &gt; 0 | CPU frequency set on emuStudio startup (it can be changed in runtime, but won’t be saved in settings) | . ",
    "url": "/documentation/user/altair8800/z80-cpu#configuration-file",
    "relUrl": "/altair8800/z80-cpu#configuration-file"
  },"183": {
    "doc": "CPU \"z80-cpu\"",
    "title": "Dumping executed instructions",
    "content": "The CPU offers a unique feature, which is the ability to dump executed instructions as a sequence to the console. When enabled, then each executed instruction - together with the content of flags and register values after the execution is printed. This feature might be extremely useful in two cases: . | Reverse engineering of some unknown software | It allows us to build tools for automatic checking of register values during the emulation when performing automatic emulation. | . To enable this feature, please see the section “Configuration file”. For example, let’s take an example which computes a reverse text: . ; Print reversed text org 1000 dec sp ; stack initialization (0FFFFh) ld hl,text1 call putstr ; print text1 ld de,input ; address for string input call getline ; read from keyboard ld bc,input ld d,0 ; chars counter char_loop: ld a, (bc) inc bc ; bc = bc+1 cp 10 ; end of input? jp z, char_end cp 13 jp z, char_end inc d ; d =d+1 jp char_loop char_end: dec bc ; bc = bc-1 dec bc call newline char2_loop: ld a, (bc) call putchar dec bc dec d jp z, char2_end jp char2_loop char2_end: halt include \"include\\getchar.inc\" include \"include\\getline.inc\" include \"include\\putstr.inc\" include \"include\\putchar.inc\" include \"include\\newline.inc\" text1: db \"Reversed text ...\",10,13,\"Enter text: \",0 text2: db 10,13,\"Reversed: \",0 input: ds 30 . When the program is being run, and the dump instructions feature is turned on, on console you can see the following output: . 0000 | PC=03e8 | dec SP | 3B || regs=00 00 00 00 00 00 00 00 IX=0000 IY=0000 IFF=0 I=00 R=01 | flags= | SP=ffff | PC=03e9 0001 | PC=03e9 | ld HL, 485 | 21 85 04 || regs=00 00 00 00 04 85 00 00 IX=0000 IY=0000 IFF=0 I=00 R=02 | flags= | SP=ffff | PC=03ec 0002 | PC=03ec | call 46D | CD 6D 04 || regs=00 00 00 00 04 85 00 00 IX=0000 IY=0000 IFF=0 I=00 R=03 | flags= | SP=fffd | PC=046d 0002 | PC=046d | ld A, (HL) | 7E || regs=00 00 00 00 04 85 00 52 IX=0000 IY=0000 IFF=0 I=00 R=04 | flags= | SP=fffd | PC=046e 0003 | PC=046e | inc HL | 23 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=05 | flags= | SP=fffd | PC=046f 0003 | PC=046f | cp 0 | FE 00 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=06 | flags= N | SP=fffd | PC=0471 0007 | PC=0471 | ret Z | C8 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=07 | flags= N | SP=fffd | PC=0472 0008 | PC=0472 | out (11),A | D3 11 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=08 | flags= N | SP=fffd | PC=0474 0008 | PC=0474 | jp 46D | C3 6D 04 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=09 | flags= N | SP=fffd | PC=046d 0009 | PC=046d | ld A, (HL) | 7E || regs=00 00 00 00 04 86 00 65 IX=0000 IY=0000 IFF=0 I=00 R=0a | flags= N | SP=fffd | PC=046e 0025 | Block from 0474 to 03EF; count=184 0025 | PC=03ef | ld DE, 4B2 | 11 B2 04 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=42 | flags= Z N | SP=ffff | PC=03f2 0025 | PC=03f2 | call 428 | CD 28 04 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=43 | flags= Z N | SP=fffd | PC=0428 0025 | PC=0428 | ld C, 0 | 0E 00 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=44 | flags= Z N | SP=fffd | PC=042a 0026 | PC=042a | in A, 10 | DB 10 || regs=00 00 04 b2 04 a5 00 02 IX=0000 IY=0000 IFF=0 I=00 R=45 | flags= Z N | SP=fffd | PC=042c 0026 | PC=042c | and 1 | E6 01 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=46 | flags= ZHP | SP=fffd | PC=042e 0026 | PC=042e | jp Z, 42A | CA 2A 04 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=47 | flags= ZHP | SP=fffd | PC=042a 0027 | PC=042a | in A, 10 | DB 10 || regs=00 00 04 b2 04 a5 00 02 IX=0000 IY=0000 IFF=0 I=00 R=48 | flags= ZHP | SP=fffd | PC=042c 6323 | Block from 042E to 0431; count=1048716 6323 | PC=0431 | in A, 11 | DB 11 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=54 | flags= H | SP=fffd | PC=0433 6323 | PC=0433 | cp D | FE 0D || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=55 | flags= N | SP=fffd | PC=0435 6324 | PC=0435 | jp Z, 461 | CA 61 04 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=56 | flags= N | SP=fffd | PC=0438 6324 | PC=0438 | cp A | FE 0A || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=57 | flags= N | SP=fffd | PC=043a 6324 | PC=043a | jp Z, 461 | CA 61 04 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=58 | flags= N | SP=fffd | PC=043d 6324 | PC=043d | cp 8 | FE 08 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=59 | flags= N | SP=fffd | PC=043f 6324 | PC=043f | jp NZ, 459 | C2 59 04 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5a | flags= N | SP=fffd | PC=0459 6324 | PC=0459 | out (11),A | D3 11 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5b | flags= N | SP=fffd | PC=045b 6324 | PC=045b | ld (DE), A | 12 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5c | flags= N | SP=fffd | PC=045c 6324 | PC=045c | inc DE | 13 || regs=00 00 04 b3 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5d | flags= N | SP=fffd | PC=045d 6325 | PC=045d | inc C | 0C || regs=00 01 04 b3 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5e | flags= | SP=fffd | PC=045e 6325 | PC=045e | jp 42A | C3 2A 04 || regs=00 01 04 b3 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5f | flags= | SP=fffd | PC=042a 6325 | PC=042a | in A, 10 | DB 10 || regs=00 01 04 b3 04 a5 00 02 IX=0000 IY=0000 IFF=0 I=00 R=60 | flags= | SP=fffd | PC=042c 8683 | Block from 045E to 0461; count=440826 8683 | PC=0461 | ld A, A | 3E 0A || regs=00 04 04 b6 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=5a | flags= ZH N | SP=fffd | PC=0463 8683 | PC=0463 | ld (DE), A | 12 || regs=00 04 04 b6 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=5b | flags= ZH N | SP=fffd | PC=0464 8683 | PC=0464 | inc DE | 13 || regs=00 04 04 b7 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=5c | flags= ZH N | SP=fffd | PC=0465 8683 | PC=0465 | ld A, D | 3E 0D || regs=00 04 04 b7 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=5d | flags= ZH N | SP=fffd | PC=0467 8683 | PC=0467 | ld (DE), A | 12 || regs=00 04 04 b7 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=5e | flags= ZH N | SP=fffd | PC=0468 8684 | PC=0468 | inc DE | 13 || regs=00 04 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=5f | flags= ZH N | SP=fffd | PC=0469 8684 | PC=0469 | ld A, 0 | 3E 00 || regs=00 04 04 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=60 | flags= ZH N | SP=fffd | PC=046b 8684 | PC=046b | ld (DE), A | 12 || regs=00 04 04 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=61 | flags= ZH N | SP=fffd | PC=046c 8684 | PC=046c | ret | C9 || regs=00 04 04 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=62 | flags= ZH N | SP=ffff | PC=03f5 8684 | PC=03f5 | ld BC, 4B2 | 01 B2 04 || regs=04 b2 04 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=63 | flags= ZH N | SP=ffff | PC=03f8 8684 | PC=03f8 | ld D, 0 | 16 00 || regs=04 b2 00 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=64 | flags= ZH N | SP=ffff | PC=03fa 8684 | PC=03fa | ld A, (BC) | 0A || regs=04 b2 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=65 | flags= ZH N | SP=ffff | PC=03fb 8684 | PC=03fb | inc BC | 03 || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=66 | flags= ZH N | SP=ffff | PC=03fc 8684 | PC=03fc | cp A | FE 0A || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=67 | flags= N | SP=ffff | PC=03fe 8684 | PC=03fe | jp Z, 40A | CA 0A 04 || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=68 | flags= N | SP=ffff | PC=0401 8684 | PC=0401 | cp D | FE 0D || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=69 | flags= N | SP=ffff | PC=0403 8685 | PC=0403 | jp Z, 40A | CA 0A 04 || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=6a | flags= N | SP=ffff | PC=0406 8685 | PC=0406 | inc D | 14 || regs=04 b3 01 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=6b | flags= | SP=ffff | PC=0407 8685 | PC=0407 | jp 3FA | C3 FA 03 || regs=04 b3 01 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=6c | flags= | SP=ffff | PC=03fa 8685 | PC=03fa | ld A, (BC) | 0A || regs=04 b3 01 b8 04 a5 00 68 IX=0000 IY=0000 IFF=0 I=00 R=6d | flags= | SP=ffff | PC=03fb 8685 | Block from 0407 to 040A; count=28 8685 | PC=040a | dec BC | 0B || regs=04 b6 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=09 | flags= ZH N | SP=ffff | PC=040b 8685 | PC=040b | dec BC | 0B || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0a | flags= ZH N | SP=ffff | PC=040c 8685 | PC=040c | call 47A | CD 7A 04 || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0b | flags= ZH N | SP=fffd | PC=047a 8685 | PC=047a | ld A, A | 3E 0A || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0c | flags= ZH N | SP=fffd | PC=047c 8686 | PC=047c | call 477 | CD 77 04 || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0d | flags= ZH N | SP=fffb | PC=0477 8686 | PC=0477 | out (11),A | D3 11 || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0e | flags= ZH N | SP=fffb | PC=0479 8686 | PC=0479 | ret | C9 || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0f | flags= ZH N | SP=fffd | PC=047f 8686 | PC=047f | ld A, D | 3E 0D || regs=04 b5 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=10 | flags= ZH N | SP=fffd | PC=0481 8686 | PC=0481 | call 477 | CD 77 04 || regs=04 b5 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=11 | flags= ZH N | SP=fffb | PC=0477 8686 | PC=0477 | out (11),A | D3 11 || regs=04 b5 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=12 | flags= ZH N | SP=fffb | PC=0479 8686 | Block from 0481 to 0484; count=2 8686 | PC=0484 | ret | C9 || regs=04 b5 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=14 | flags= ZH N | SP=ffff | PC=040f 8686 | PC=040f | ld A, (BC) | 0A || regs=04 b5 04 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=15 | flags= ZH N | SP=ffff | PC=0410 8686 | PC=0410 | call 477 | CD 77 04 || regs=04 b5 04 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=16 | flags= ZH N | SP=fffd | PC=0477 8686 | PC=0477 | out (11),A | D3 11 || regs=04 b5 04 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=17 | flags= ZH N | SP=fffd | PC=0479 8686 | Block from 0410 to 0413; count=2 8686 | PC=0413 | dec BC | 0B || regs=04 b4 04 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=19 | flags= ZH N | SP=ffff | PC=0414 8687 | PC=0414 | dec D | 15 || regs=04 b4 03 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=1a | flags= H N | SP=ffff | PC=0415 8687 | PC=0415 | jp Z, 41B | CA 1B 04 || regs=04 b4 03 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=1b | flags= H N | SP=ffff | PC=0418 8687 | PC=0418 | jp 40F | C3 0F 04 || regs=04 b4 03 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=1c | flags= H N | SP=ffff | PC=040f 8687 | PC=040f | ld A, (BC) | 0A || regs=04 b4 03 b8 04 a5 00 6f IX=0000 IY=0000 IFF=0 I=00 R=1d | flags= H N | SP=ffff | PC=0410 8687 | Block from 0418 to 041B; count=23 8687 | PC=041b | halt | 76 || regs=04 b1 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=34 | flags= ZH N | SP=ffff | PC=041c . The dump format consists of lines, each line represents one instruction execution. The line is separated by | chars, splitting it into so-called sections. Sections before the sequence || represent the state before instruction execution, and sections after it represent the state after instruction execution. Particular sections are described in the following table. | Column | Description | . | 1 | Timestamp from program start (seconds) | . | 2 | Program counter before instruction execution | . | 3 | Disassembled instruction | . | 4 | Instruction opcodes | . |   | Now follows the state after instruction execution | . | 5 | Register values (B, C, D, E, H, L, reserved (always 0), A) | . | 6 | Flags | . | 7 | Stack pointer register (SP) | . | 8 | Program counter after instruction execution | . ",
    "url": "/documentation/user/altair8800/z80-cpu#dumping-executed-instructions",
    "relUrl": "/altair8800/z80-cpu#dumping-executed-instructions"
  },"184": {
    "doc": "CPU \"z80-cpu\"",
    "title": "Testing the CPU",
    "content": "There are many Z80 testing frameworks online which can be used to test Z80 CPU emulator in emuStudio. This section will list some tests and present how to use them. Patrik Rak’s Z80 Test . As the author writes: . This set of programs is intended to help the emulator authors reach the desired level of the CPU emulation authenticity. The tests can be downloaded at this link. This test suite was designed for ZX Spectrum emulator authors. That’s why it expects ZX Spectrum memory map, and I/O devices. Since emuStudio does not currently emulate ZX Spectrum, it is necessary to do some modifications to the original test suite to make it work. Apply the following patch on top of commit 9f84881428c4257f9f429ab1ac00d1bae0623231: . diff --git a/src/Makefile b/src/Makefile index f9dac98..019e3de 100644 --- a/src/Makefile +++ b/src/Makefile @@ -7,7 +7,7 @@ PKG := $(NAME)-$(VERSION) PROGS := z80full z80flags z80doc z80docflags z80ccf z80memptr z80ccfscr SRCS := main idea crctab tests testmacros print -all: $(addsuffix .tap,$(PROGS)) +all: $(addsuffix .tap,$(PROGS)) $(addsuffix .out,$(PROGS)) .DELETE_ON_ERROR: %.out diff --git a/src/idea.asm b/src/idea.asm index ada853d..c2263a3 100644 --- a/src/idea.asm +++ b/src/idea.asm @@ -44,7 +44,9 @@ test: ld (.spptr+1),sp call .copy ld a,0x07 ; Make sure we get 0 - out (0xfe),a ; on MIC bit when doing IN. + nop + nop + ;out (0xfe),a ; on MIC bit when doing IN. ld a,0xa9 ; Set I,R,AF' to known values. ld i,a diff --git a/src/main.asm b/src/main.asm index e593e35..ca9b752 100644 --- a/src/main.asm +++ b/src/main.asm @@ -69,7 +69,8 @@ main: di ; disable interrupts exx pop iy ei - ret + halt + ;ret .test push bc ; preserve number of failures @@ -100,7 +101,10 @@ main: di ; disable interrupts ret ; return success .incheck xor a ; expected IN value means do the test - in a,(0xfe) + nop + nop + ; in a,(0xfe) + ld a, 0xbf cp 0xbf ; %10111111 - just MIC bit is zero jr z,.pass diff --git a/src/print.asm b/src/print.asm index bd26ac2..3c4809f 100644 --- a/src/print.asm +++ b/src/print.asm @@ -6,8 +6,10 @@ printinit: ld a,2 - jp 0x1601 ; CHAN-OPEN - + nop + nop + ;jp 0x1601 ; CHAN-OPEN + ret print: ex (sp),hl call printhl @@ -70,8 +72,9 @@ printchr: push iy push bc exx ei + out (0x11),a ; out (0xff),a - rst 0x10 + ; rst 0x10 di exx pop bc diff --git a/src/tests.asm b/src/tests.asm index 5ccc77f..b292d3b 100644 --- a/src/tests.asm +++ b/src/tests.asm @@ -40,13 +40,13 @@ testtable: dw .scf dw .ccf - dw .scf_nec - dw .ccf_nec - dw .scf_st - dw .ccf_st - dw .scfccf - dw .ccfscf - +;x dw .scf_nec +;x dw .ccf_nec +;x dw .scf_st +;x dw .ccf_st +;x dw .scfccf +;x dw .ccfscf + dw .daa dw .cpl dw .neg @@ -148,24 +148,24 @@ testtable: dw .cpd dw .cpir dw .cpdr - - dw .in_a_n - dw .in_r_c - dw .in_c - dw .ini - dw .ind - dw .inir - dw .indr - dw .inir_nop - dw .indr_nop - - dw .out_n_a - dw .out_c_r - dw .out_c_0 - dw .outi - dw .outd - dw .otir - dw .otdr + +;x dw .in_a_n +;x dw .in_r_c +;x dw .in_c +;x dw .ini +;x dw .ind +;x dw .inir +;x dw .indr +;x dw .inir_nop +;x dw .indr_nop + +;x dw .out_n_a +;x dw .out_c_r +;x dw .out_c_0 +;x dw .outi +;x dw .outd +;x dw .otir +;x dw .otdr dw .jp_nn dw .jp_cc_nn . Tests commented out with ;x don’t work yet. How to compile test suite . | Install sjasm 0.42c | Install mktap-8 or newest mktap-16 (© Jan Bobrowski) | Install make | In terminal, run make | . Running tests in emuStudio . Create new virtual computer, call it “ZX Spectrum”: . It is basically the same computer as Altair8800 with Z80, but instead of ADM-3A terminal it uses draft of ZX-spectrum display. This device is not even documented, because it’s not really ZX spectrum. It exists just to be able to run existing Z80 test suites. When the computer is opened, load compiled test suite in memory, e.g. file src/z80full.out at address 0x8000. Then, open the ZX-display and run emulation. Selecting only some tests . Open file src/tests.asm and comment out tests below testtable: label you don’t want to execute, e.g.: . testtable: if selftests dw .crc dw .counter dw .shifter endif dw .selftest dw .scf dw .ccf ;x dw .scf_nec ;x dw .ccf_nec ;x dw .scf_st ;x dw .ccf_st ;x dw .scfccf ;x dw .ccfscf . Tests .scf_ne, .ccf_ne, .scf_st, .ccf_st, .scfccf, .ccfscf won’t be executed in this case. ZXSpectrumNextTests . ZXSpectrumNextTests is another ZX Spectrum test suite, written by Kevin Watinks and Ped Helcmanovsky. It is actually a set of various test suites testing various aspects of ZX spectrum. I wasn’t able to work out the tests, and work is still in progress. So far in progress is a file for testing block instructions. The test suite can be downloaded from this repository. Since it’s counting with ZX Spectrum architecture, tests must be modified for emuStudio. Apply the following patch on top of commit 295c0e2005d5bd255ec2c26f06409a3afca77776: . diff --git a/Tests/ZX48_ZX128/Z80BlockInstructionFlags/z80_block_flags_test.asm b/Tests/ZX48_ZX128/Z80BlockInstructionFlags/z80_block_flags_test.asm index 4af203f..03cc51a 100644 --- a/Tests/ZX48_ZX128/Z80BlockInstructionFlags/z80_block_flags_test.asm +++ b/Tests/ZX48_ZX128/Z80BlockInstructionFlags/z80_block_flags_test.asm @@ -39,9 +39,9 @@ OPT --syntax=abf DEVICE zxspectrum48, $7FFF -ROM_ATTR_P: EQU $5C8D -ROM_CLS: EQU $0DAF -ROM_PRINT: EQU $203C +;ROM_ATTR_P: EQU $5C8D +;ROM_CLS: EQU $0DAF +;ROM_PRINT: EQU $203C LAST_ATTR: EQU $5AFF LOG_AREA: EQU $8900 TEST_AREA: EQU $E000 @@ -144,7 +144,7 @@ fill_test_area: ; print string terminated by $FF (and having all chars -1) from DE address print_FFstr.loop: - rst $10 + out (0x11), a print_FFstr: ld a,(de) inc de @@ -152,11 +152,27 @@ print_FFstr: jr nz,.loop ret +ROM_PRINT.loop: + out (0x11), a +ROM_PRINT: + ld a,(de) + inc de + dec bc + jr nz,.loop + ret + +clear_screen: + + ; main test code setting it up and doing all tests + printing results test_start: - ld a,7&lt;&lt;3 - ld (ROM_ATTR_P),a ; ATTR-P = PAPER 7 : INK 0 : BRIGHT 0 : FLASH 0 - call ROM_CLS + ld sp, STACK_TOP + ;ld a,7&lt;&lt;3 + ;ld (ROM_ATTR_P),a ; ATTR-P = PAPER 7 : INK 0 : BRIGHT 0 : FLASH 0 + ;call ROM_CLS + ld a, 0x1C + out (0x11), a + ld de,head_txt ; text at top of screen call print_FFstr ld ix,i_meta ; meta data about next instruction to test @@ -191,6 +207,25 @@ test_start: ld (hl),a ldir im 2 + + ; set CPU frequency 20 kHZ + ; ld a, 32 ; setCPUClockFrequency + ; out (0xFE), a + ; ld a, 20 + ; out (0xFE), a + ; ld a, 0 + ; out (0xFE), a + + ; start timer interrupts (simh device) + ld a, 23 ; setTimerDeltaCmd + out (0xFE), a + ld a, 1 + out (0xFE), a + ld a, 0x00 + out (0xFE), a + ld a, 21 ; startTimerInterruptsCmd + out (0xFE), a + ei ; calibrate initial BC delay before launching block instruction (delay depends on ZX type and prologue code) @@ -210,11 +245,15 @@ test_start: ld a,$FF ; write $FF to last attribute of VRAM ld (LAST_ATTR),a ; to have also +2A/+3 models read $FF on port $FF (all test code is in fast memory) halt - in a,($FE) + ; in a,($FE) + ; ld a, 0x80 + ld a, 0 ld (ulaB7),a ; should be %1xxx'xxxx if ULA keyboard reads like Issue2+ model - in a,($1F) + ; in a,($1F) + ld a, 0x80 ld (kempB7),a ; should be %00xx'xxxx if Kempston interface is connected - in a,($FF) + ; in a,($FF) + ld a, 0 ld (float),a ; expected value $FF from floating bus next_instruction: @@ -245,7 +284,7 @@ next_test: ; compare saved F flag with expected value and print result ld a,' ' - rst $10 + out (0x11), a .chkF+1 call 0 ; checkF function ; L = expected F value ld a,l call printHexByte @@ -276,7 +315,7 @@ next_test: ; print ENTER after all four addresses were done .skip_test: ld a,13 - rst $10 + out (0x11), a ; advance test to next block instruction ld hl,(.call) ; advance test-call to next test-block (look for RET in current block) @@ -296,10 +335,12 @@ next_test: ld a,$3F ld i,a im 1 - ei + + di ld a,7 - out (254),a - ret + ; out (254),a + ;ret + halt too_fast_machine: ld de,calibrate_fail_txt @@ -314,7 +355,7 @@ init_and_delay: push hl ld a,h and 7 - out (254),a ; change BORDER based on \".af\" value + ; out (254),a ; change BORDER based on \".af\" value .hl+1: ld hl,TEST_AREA or a ; +4T nop (CF is already 0) sbc hl,bc @@ -341,7 +382,7 @@ printHexDigit: ; Convert nibble to ASCII cp 10 sbc a,$69 daa - rst $10 + out (0x11), a ret ulaB7: DB $00 @@ -349,7 +390,7 @@ kempB7: DB $FF float: DB $00 head_txt: - DB $15,1 ; `OVER 1` for \"!=\" mixing + ; DB $15,1 ; `OVER 1` for \"!=\" mixing DB \"v5.0 2022-01-11 Ped7g\",13 DB \"based on David Banks' research\",13 DB \"F of IM2 interrupted block inst\",13 @@ -359,19 +400,23 @@ after_i_txt: DB \" F:\",$FF expected_value_txt: - DB '=',$13,0,$11,4,$FF ; =, BRIGHT 0, PAPER 4 +; DB '=',$13,0,$11,4,$FF ; =, BRIGHT 0, PAPER 4 + DB '=',$FF ; =, BRIGHT 0, PAPER 4 unexpected_value_txt: - DB '=',8,'!',$13,1,$11,2,$FF ; !=, BRIGHT 1, PAPER 2 +; DB '=',8,'!',$13,1,$11,2,$FF ; !=, BRIGHT 1, PAPER 2 + DB '=',8,'!',$FF ; !=, BRIGHT 1, PAPER 2 restore_color: - DB $13,0,$11,7,$10,0,$FF ; BRIGHT 0 : PAPER 7 : INK 0 +; DB $13,0,$11,7,$10,0,$FF ; BRIGHT 0 : PAPER 7 : INK 0 + DB $FF ; BRIGHT 0 : PAPER 7 : INK 0 skip_txt: DB \" unexpected IN 1F,FE,FF\",$FF calibrate_fail_txt: - DB $10,2,\"failed delay calibration\\ris frame &gt; 73500T?\",13,$FF +; DB $10,2,\"failed delay calibration\\ris frame &gt; 73500T?\",13,$FF + DB \"failed delay calibration\\ris frame &gt; 73500T?\",13,$FF ; default settings of init_and_delay for testing block instructions (used by LDIR/LDDR/CPIR/CPDR test) inst_default_init: @@ -546,10 +591,10 @@ inxr_otxr_b_loop_test: ld ix,i_meta_b .next_instruction: ; reset colors, print name of instruction, move four chars left (to overwrite it with progress indicators) - ld a,$10 - rst $10 - ld a,4 - rst $10 ; INK 4 (green) for start of the test + ;ld a,$10 + ;rst $10 + ;ld a,4 + ;rst $10 ; INK 4 (green) for start of the test ldi hl,(ix) ; fake-ok ; HL = address string with instruction name, IX+=2 ld de,hl ; fake-ok ; DE = HL (for print) ld bc,4 @@ -561,7 +606,7 @@ inxr_otxr_b_loop_test: ld b,4 .loop_left: ld a,8 - rst $10 + out (0x11), a djnz .loop_left ; call init and set up the test-call itself to desired instruction ldi hl,(ix) ; fake-ok ; HL = address of init function for next instruction test, IX+=2 @@ -609,15 +654,15 @@ inxr_otxr_b_loop_test: cp c jr z,.okF ; change INK to red for rest of tests with this instruction (but keep running + logging) - ld a,$10 - rst $10 - ld a,2 - rst $10 ; INK 2 (red) for rest of the test + ;ld a,$10 + ;rst $10 + ;ld a,2 + ;rst $10 ; INK 2 (red) for rest of the test .okF: ; display progress char .p_hl+1:ld hl,progress_chars ld a,(hl) inc l - rst $10 + out (0x11), a ld a,low progress_chars.e cp l ld a,8 ; 8 = \"left\" to compose the char together next time @@ -626,7 +671,7 @@ inxr_otxr_b_loop_test: ld l,low progress_chars .progress_not_last: ld (.p_hl),hl - rst $10 + out (0x11), a ; increment initial B by +3 65x times ld a,(init_and_delay.bc+1) @@ -642,11 +687,12 @@ inxr_otxr_b_loop_test: ld de,restore_color call print_FFstr ; restore colors back to white paper, black ink ld a,13 - rst $10 + out (0x11), a ret b_loop_txt: - DB \"HF vs B, binary log at $8900\",13,$13,1,$11,0,$FF ; also BRIGHT 1, PAPER 0 for progress+results + ;DB \"HF vs B, binary log at $8900\",13,$13,1,$11,0,$FF ; also BRIGHT 1, PAPER 0 for progress+results + DB \"HF vs B, binary log at $8900\",13,$FF ; also BRIGHT 1, PAPER 0 for progress+results i_meta: ; name of instruction + expected flag when interrupted by IM2 during block operation (BC!=0) ; LDIR: N=0, P/V=1, H=0, C=Z=S=unchanged (0), YF=PC.13, XF=PC.11 @@ -765,6 +811,10 @@ in_instr_regs: SAVED_REGS im2isr: ASSERT low im2isr == high im2isr push af,,hl,,de,,bc + + ; ld a, 'I' + ; out (0x11), a + ld hl,0 add hl,sp ld de,im_saved_regs @@ -781,82 +831,85 @@ STACK_TOP: EQU $8800 code_end: + SAVEBIN \"z80bltst.bin\", $8000, code_end - $8000 ; save 0x7FFF begin from 0x8000 of RAM to file + ;; produce SNA file with test code - SAVESNA \"z80bltst.sna\", code_start +; SAVESNA \"z80bltst.sna\", code_start -CODE EQU $AF -USR EQU $C0 -LOAD EQU $EF -CLEAR EQU $FD -RANDOMIZE EQU $F9 -REM EQU $EA +;CODE EQU $AF +;USR EQU $C0 +;LOAD EQU $EF +;CLEAR EQU $FD +;RANDOMIZE EQU $F9 +;REM EQU $EA ;; produce TAP file with the test code - DEFINE tape_file \"z80bltst.tap\" - DEFINE prog_name \"z80bltst\" +; DEFINE tape_file \"z80bltst.tap\" +; DEFINE prog_name \"z80bltst\" ;; 10 CLEAR 32767:LOAD \"z80bltst\"CODE ;; 20 RANDOMIZE USR 32768 - ORG $5C00 -tap_bas: - DB 0,10 ;; Line number 10 - DW .l10ln ;; Line length -.l10: DB CLEAR,'8',$0E,0,0 - DW code_start-1 - DB 0,':' - DB LOAD,'\"' -.fname: DB prog_name - ASSERT ($ - .fname) &lt;= 10 - DB '\"',CODE,$0D -.l10ln: EQU $-.l10 - DB 0,20 ;; Line number 20 - DW .l20ln -.l20: DB RANDOMIZE,USR,\"32768\",$0E,0,0 - DW code_start - DB 0,$0D -.l20ln: EQU $-.l20 - DB 0,99 ;; Line number 99 - DW .l99ln -.l99: DB REM,\"https://github.com/MrKWatkins/ZXSpectrumNextTests/\\r\" -.l99ln: EQU $-.l99 -.l: EQU $-tap_bas - - EMPTYTAP tape_file - SAVETAP tape_file,BASIC,prog_name,tap_bas,tap_bas.l,1 - SAVETAP tape_file,CODE,prog_name,code_start,code_end-code_start,code_start +; ORG $5C00 +;tap_bas: +; DB 0,10 ;; Line number 10 +; DW .l10ln ;; Line length +;.l10: DB CLEAR,'8',$0E,0,0 +; DW code_start-1 +; DB 0,':' +; DB LOAD,'\"' +;.fname: DB prog_name +; ASSERT ($ - .fname) &lt;= 10 +; DB '\"',CODE,$0D +;.l10ln: EQU $-.l10 +; DB 0,20 ;; Line number 20 +; DW .l20ln +;.l20: DB RANDOMIZE,USR,\"32768\",$0E,0,0 +; DW code_start +; DB 0,$0D +;.l20ln: EQU $-.l20 +; DB 0,99 ;; Line number 99 +; DW .l99ln +;.l99: DB REM,\"https://github.com/MrKWatkins/ZXSpectrumNextTests/\\r\" +;.l99ln: EQU $-.l99 +;.l: EQU $-tap_bas +; +; EMPTYTAP tape_file +; SAVETAP tape_file,BASIC,prog_name,tap_bas,tap_bas.l,1 +; SAVETAP tape_file,CODE,prog_name,code_start,code_end-code_start,code_start ;; produce TRD file with the test code - DEFINE trd_file \"z80bltst.trd\" +; DEFINE trd_file \"z80bltst.trd\" ;; 10 CLEAR 32767:RANDOMIZE USR 15619:REM:LOAD \"z80bltst\"CODE ;; 20 RANDOMIZE USR 32768 - ORG $5C00 -trd_bas: - DB 0,10 ;; Line number 10 - DW .l10ln ;; Line length -.l10: DB CLEAR,'8',$0E,0,0 - DW code_start-1 - DB 0,':' - DB RANDOMIZE,USR,\"15619\",$0E,0,0 - DW 15619 - DB 0,':',REM,':',LOAD,'\"' -.fname: DB \"z80bltst\" - ASSERT ($ - .fname) &lt;= 8 - DB '\"',CODE,$0D -.l10ln: EQU $-.l10 - DB 0,20 ;; Line number 20 - DW .l20ln - ASSERT 32768 == code_start -.l20: DB RANDOMIZE,USR,\"32768\",$0E,0,0 - DW code_start - DB 0,$0D -.l20ln: EQU $-.l20 - DB 0,99 ;; Line number 99 - DW .l99ln -.l99: DB REM,\"https://github.com/MrKWatkins/ZXSpectrumNextTests/\\r\" -.l99ln: EQU $-.l99 -.l: EQU $-trd_bas - - EMPTYTRD trd_file - SAVETRD trd_file,\"boot.B\",trd_bas,trd_bas.l,10 - SAVETRD trd_file,\"z80bltst.C\",code_start,code_end-code_start +; ORG $5C00 +;trd_bas: +; DB 0,10 ;; Line number 10 +; DW .l10ln ;; Line length +;.l10: DB CLEAR,'8',$0E,0,0 +; DW code_start-1 +; DB 0,':' +; DB RANDOMIZE,USR,\"15619\",$0E,0,0 +; DW 15619 +; DB 0,':',REM,':',LOAD,'\"' +;.fname: DB \"z80bltst\" +; ASSERT ($ - .fname) &lt;= 8 +; DB '\"',CODE,$0D +;.l10ln: EQU $-.l10 +; DB 0,20 ;; Line number 20 +; DW .l20ln +; ASSERT 32768 == code_start +;.l20: DB RANDOMIZE,USR,\"32768\",$0E,0,0 +; DW code_start +; DB 0,$0D +;.l20ln: EQU $-.l20 +; DB 0,99 ;; Line number 99 +; DW .l99ln +;.l99: DB REM,\"https://github.com/MrKWatkins/ZXSpectrumNextTests/\\r\" +;.l99ln: EQU $-.l99 +;.l: EQU $-trd_bas +; +; EMPTYTRD trd_file +; SAVETRD trd_file,\"boot.B\",trd_bas,trd_bas.l,10 +; SAVETRD trd_file,\"z80bltst.C\",code_start,code_end-code_start +; \\ No newline at end of file . How to compile test suite . | Install sjasmplus | In terminal, run ./sjasmplus Tests/ZX48_ZX128/Z80BlockInstructionFlags/z80_block_flags_test.asm (produces z80bltst.bin) | . Running tests in emuStudio . Create new virtual computer, call it “ZX Spectrum” (see previous section on Patrik Rak’s tests). When the computer is opened, load compiled test suite in memory, file Tests/ZX48_ZX128/Z80BlockInstructionFlags/z80bltst.bin at address 0x8000. Then, open the ZX-display and run emulation. Disclaimer: output will be awful. ZEXALL tests . Another test suite, which actually works in emuStudio with one small support code. The test suite can be downloaded at this repository. How to compile test suite . | Install ZSM4 | Compile using command line: | . zsm4 =zexall/L link zexdoc . Running tests in emuStudio . Create new virtual computer, call it “ZX Spectrum” (see previous section on Patrik Rak’s tests). In source code editor, compile the following support code: . di halt ; bdos simulation org 5 push af push de ld a, 2 cp c ; print char jp nz, str ld a, e out (0x11), a jp exit str: ld a, 9 cp c ; print string jp nz, exit putstr: ld a, (de) inc de cp '$' jp z, exit out (11h), a jp putstr exit: pop de pop af ret . Then, load zexall.com or zexdoc.com at location 0x100 into memory. Set program address to 0x100, open the terminal and run the emulation. ",
    "url": "/documentation/user/altair8800/z80-cpu#testing-the-cpu",
    "relUrl": "/altair8800/z80-cpu#testing-the-cpu"
  },"185": {
    "doc": "CPU \"z80-cpu\"",
    "title": "CPU \"z80-cpu\"",
    "content": " ",
    "url": "/documentation/user/altair8800/z80-cpu",
    "relUrl": "/altair8800/z80-cpu"
  }
}
