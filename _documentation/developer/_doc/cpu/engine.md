---
layout: default
title: Emulator engine
nav_order: 3
parent: Writing a CPU
permalink: /cpu/engine
---

{% include analytics.html category="developer" %}

# Emulator engine

Emulator engine is the core of the emulator. It interprets binary-encoded instructions stored in a memory (emuStudio
assumes it's a von-Neumann-like CPU). Execution of one instruction involves four basic steps: fetch, decode and execute,
and store, executed in order. Those steps can overlap in the implementation.

A pseudo-algorithm for emulator engine can look as follows (using [interpretation technique][interpreter]{:target="_blank"}):

{:.code-example}

```java
public class EmulatorEngine {
    private final CPU cpu;
    private final MemoryContext<Byte> memory;

    // internal CPU registers
    private int currentInstruction;

    EmulatorEngine(MemoryContext<Byte> memory, CPU cpu) {
        this.memory = Objects.requireNonNull(memory);
        this.cpu = Objects.requireNonNull(cpu);
    }

    CPU.RunState step(CPU.RunState currentRunState) {
        int instruction = memory.read(currentInstruction);
        currentInstruction = currentInstruction + 1;

        switch (instruction) {
            case 0: // ADD
                ...
                return CPU.RunState.STATE_STOPPED_BREAK;
            case 4: // JMP
                ...
                return CPU.RunState.STATE_STOPPED_BREAK;
            case 99: // HLT
                return CPU.RunState.STATE_STOPPED_NORMAL;
        }
    }

    CPU.RunState run(CPU.RunState currentRunState) {
        while (currentRunState == CPU.RunState.STATE_STOPPED_BREAK) {
            try {
                if (cpu.isBreakpointSet(currentInstruction)) {
                    return currentRunState;
                }
                currentRunState = step();
            } catch (...){
                currentRunState = CPU.RunState.STATE_STOPPED_XXX;
                break;
            }
        }
        return currentRunState;
    }

    ...
}
```

It uses interpretation emulation technique (the simplest one). Note that breakpoints must be manually handled - after
execution of each instruction it should be checked if the current instruction hasn't a breakpoint, and if yes, return.

## Emulating accurate timing

Accurate timing in the emulation is sometimes necessary to achieve "intended" (real) response times: visual, audio,
or network speed of the emulated computer. 

Often times computer components work in sync together, i.e. the speed of each component is usually derived from one
crystal clock. For example, a Zilog Z80 CPU runs on 3.5MHz, and the video chip runs on 7MHz. In this case, the video
chip generates [two pixels per one CPU cycle][zxdesign]{:target="_blank"}:

> The ZX Spectrum operates at a CPU clock of 3.5MHz. This is exactly half the pixel clock frequency of 7MHz, and accounts 
> for the fact that two pixels are displayed in one T-state. The pixel clock is generated by dividing the output of a 
> 14MHz crystal oscillator with a D-Type flip-flop, which results in a cleaner signal. Dividing it again will give the
> CPU clock.

Timing of computer components in emulators is usually also derived from one "clock", but there are more ways how to 
achieve target speed in the emulator. For example, video redraw speed can be derived from the number of executed CPU
cycles, and CPU speed can be derived from audio buffer size, etc.

In this section, we'll be discussing ways of how to achieve time accurate CPU emulation. When talking about target 
(emulated) CPU speed in relation to the host CPU, we can observe three cases:

1. The host CPU is faster than the emulated CPU
2. The host CPU is slower than the emulated CPU
3. The host CPU speed is equal to the emulated CPU speed

The last case is the ideal one, ofcourse. In the second case there's not much we can do actually, except some drastic
emulation quality reduction (e.g. lowering FPS), if actually possible.

The first case is the most common one, and there are several solutions possible. We know that every instruction takes
several clock ticks (sometimes called t-states) to execute. For example, the Zilog Z80 CPU takes 4 t-states per `NOP`
instruction. Each clock tick takes constant time to execute, based on the clock frequency of the CPU. For example, the
Intel 8080 CPU has a clock frequency of 2 MHz, so every clock tick takes $1 / 2000000 = 5^{e-7} s = 0.5$ microseconds.

One way of achieving accurate timing is to execute the instructions in a loop, and measure the time spent in the loop.
If the time is less than the intended time, we can execute more instructions in the next iteration. If the time is greater,
we can execute less (or no) instructions in the next iteration. This way we can achieve accurate timing.

Computing the "intended" time is therefore based on time measurement on the host, and comparing it with emulation time
computed as the number of executed t-states multiplied by the time of one t-state. Then, if the host time is smaller
than emulated time (we're still talking about the first case above), we need to slow down the emulation actually
"doing nothing" until the host time catches up the emulated time.

The "do nothing" part can be based on calling the `Thread.sleep()` method (or similar), or on busy waiting. Also,
we need to take into consideration time measurement / sleeping accuracy. Usually, a sleep accuracy is ~1ms on today's
host CPU speeds. Even though we have a nano-second timer (`System.nanoTime()`), the accuracy is still ~1ms. This means
that we cannot measure the time of a single t-state, or even few t-states. We can only measure the time of a "bunch" of
t-states, and then we can only "slow down" the emulation in the next iteration.

The general solution, which is very usual in emulators, is to setup a "time slot" (>= the time measurement accuracy)
in the beginning of the emulation. Then, in the loop we calculate target machine cycles which should be executed in the
time slot. Then we execute instructions until we achieve target machine cycles, and "do nothing" until the time slot is
over. Then we repeat the process.

Described algorithm is implemented in emuLib library in the class `AccurateFrequencyRunner`. Usage (taken from Intel 8080 emulator)
is: 

```java
public class EmulatorEngine {
    ...
    private final AccurateFrequencyRunner preciseRunner = new AccurateFrequencyRunner();

    CPU.RunState run() {
        return preciseRunner.run(
                () -> (double) context.getCPUFrequency(),
                () -> {
                    try {
                        if (cpu.isBreakpointSet(PC)) {
                            currentRunState = CPU.RunState.STATE_STOPPED_BREAK;
                        } else {
                            int cycles = dispatch(); // this will update currentRunState
                            preciseRunner.addExecutedCycles(cycles); // this is very much needed!
                            context.passedCycles(cycles);
                        }
                    } catch (IndexOutOfBoundsException e) {
                        LOGGER.error("Unexpected error", e);
                        currentRunState = CPU.RunState.STATE_STOPPED_ADDR_FALLOUT;
                    } catch (Throwable e) {
                        LOGGER.error("Unexpected error", e);
                        currentRunState = CPU.RunState.STATE_STOPPED_BAD_INSTR;
                    }
                    return currentRunState;
                }
        );
    }

    ...
}
```



[zxdesign]: http://www.zxdesign.info/cpu1.shtml
[interpreter]: https://en.wikipedia.org/wiki/Interpreter_(computing)
